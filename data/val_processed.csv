id,text,code,question,code_cleaned,functions,code_context
0,Program to convert Centimeters to Pixels | C ++ program to convert centimeter to pixels ; Function to convert centimeters to pixels ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; void Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; cout << fixed << setprecision ( 2 ) << pixels ; } int main ( ) { double centi = 15 ; Conversion ( centi ) ; return 0 ; },Program to convert Centimeters to Pixels.,#include <bits/stdc++.h>   using namespace std ; void Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; cout << fixed << setprecision ( 2 ) << pixels ; } int main ( ) { double centi = 15 ; Conversion ( centi ) ; return 0 ; },"['void Conversion ( double centi ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void Conversion ( double centi ) {
1,"Kth array element after M replacements of array elements by XOR of adjacent pairs | C ++ program for the above approach ; Method that returns the corresponding output by taking the given inputs . ; If this condition is satisfied , value of M is invalid ; Check if index K is valid ; Loop to perform M operations ; Creating a temporary list ; Traversing the array ; Calculate XOR values of adjacent elements ; Adding this value to the temporary list ; Update the original array ; Getting value at index K ; Driver Code ; Number of elements ; Given array arr [ ] ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 or M > = N ) return -1 ; if ( K < 0 or K > = N - M ) return -1 ; for ( int p = 0 ; p < M ; p ++ ) { vector < int > temp ; for ( int i = 0 ; i < N ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . push_back ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 4 , 5 , 6 , 7 } ; int M = 1 , K = 2 ; cout << xor_operations ( N , arr , M , K ) ; return 0 ; }",Kth array element after M replacements of array elements by XOR of adjacent pairs.,"#include <bits/stdc++.h>   using namespace std ; int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 or M > = N ) return -1 ; if ( K < 0 or K > = N - M ) return -1 ; for ( int p = 0 ; p < M ; p ++ ) { vector < int > temp ; for ( int i = 0 ; i < N ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . push_back ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 4 , 5 , 6 , 7 } ; int M = 1 , K = 2 ; cout << xor_operations ( N , arr , M , K ) ; return 0 ; }","['int xor_operations ( int N , int arr [ ] , int M , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int xor_operations ( int N , int arr [ ] , int M , int K ) {"
2,"Check if N can be divided into K consecutive elements with a sum equal to N | C ++ program for the above approach ; Function to find the K consecutive elements with a sum equal to N ; Iterate over [ 2 , INF ] ; Store the sum ; If the sum exceeds N then break the loop ; Common difference should be divisible by number of terms ; Print value of i & return ; Print "" - 1"" if not possible to break N ; Driver Code ; Given N ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBreakN ( long long n ) { for ( long long i = 2 ; ; i ++ ) { long long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long long k = n - m ; if ( k % i ) continue ; cout << i << endl ; return ; } cout << "" - 1"" ; } int main ( ) { long long N = 12 ; canBreakN ( N ) ; return 0 ; }",Check if N can be divided into K consecutive elements with a sum equal to N.,"#include <bits/stdc++.h>   using namespace std ; void canBreakN ( long long n ) { for ( long long i = 2 ; ; i ++ ) { long long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long long k = n - m ; if ( k % i ) continue ; cout << i << endl ; return ; } cout << "" - 1"" ; } int main ( ) { long long N = 12 ; canBreakN ( N ) ; return 0 ; }","['void canBreakN ( long long n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void canBreakN ( long long n ) {
3,"Coprime divisors of a number | C ++ program to find two coprime divisors of a given number such that both are greater than 1 ; Function which finds the required pair of divisors of N ; We iterate upto sqrt ( N ) as we can find all the divisors of N in this time ; If x is a divisor of N keep dividing as long as possible ; We have found a required pair ; No such pair of divisors of N was found , hence print - 1 ; Driver Code ; Sample example 1 ; Sample example 2","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCoprimePair ( int N ) { for ( int x = 2 ; x <= sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) { while ( N % x == 0 ) { N /= x ; } if ( N > 1 ) { cout << x << "" ▁ "" << N << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 45 ; findCoprimePair ( N ) ; N = 25 ; findCoprimePair ( N ) ; return 0 ; }",Coprime divisors of a number.,"#include <bits/stdc++.h>   using namespace std ; void findCoprimePair ( int N ) { for ( int x = 2 ; x <= sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) { while ( N % x == 0 ) { N /= x ; } if ( N > 1 ) { cout << x << "" ▁ "" << N << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 45 ; findCoprimePair ( N ) ; N = 25 ; findCoprimePair ( N ) ; return 0 ; }","['void findCoprimePair ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void findCoprimePair ( int N ) {
6,"Hexanacci Numbers | C ++ implementation to print Nth term of hexanacci numbers . ; Function to print the Nth term of the Hexanacci number ; Initialize first five numbers to base cases ; Declare a current variable ; Loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth fifth to second , third , fourth , fifth and curr to sixth respectively ; Driver Code",#include <bits/stdc++.h> NEW_LINE using namespace std ; void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) cout << first << endl ; else if ( n == 6 ) cout << sixth << endl ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } cout << curr << endl ; } int main ( ) { int n = 11 ; printhexa ( n ) ; return 0 ; },Hexanacci Numbers.,#include <bits/stdc++.h>   using namespace std ; void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) cout << first << endl ; else if ( n == 6 ) cout << sixth << endl ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } cout << curr << endl ; } int main ( ) { int n = 11 ; printhexa ( n ) ; return 0 ; },"['void printhexa ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void printhexa ( int n ) {
7,Find the smallest number whose sum of digits is N | C ++ program to find the smallest number whose sum of digits is also N ; Function to find the smallest number whose sum of digits is also N ; Driver code,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void smallestNumber ( int N ) { cout << ( N % 9 + 1 ) * pow ( 10 , ( N / 9 ) ) - 1 ; } int main ( ) { int N = 10 ; smallestNumber ( N ) ; return 0 ; }",Find the smallest number whose sum of digits is N.,"#include <iostream>   #include <math.h>   using namespace std ; void smallestNumber ( int N ) { cout << ( N % 9 + 1 ) * pow ( 10 , ( N / 9 ) ) - 1 ; } int main ( ) { int N = 10 ; smallestNumber ( N ) ; return 0 ; }","['void smallestNumber ( int N ) {', 'int main ( ) {']",#include <iostream>   #include <math.h>   using namespace std ; void smallestNumber ( int N ) {
10,"Program to find value of 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k | C ++ Program to find the value 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K ; Function to find value of 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K ; Initialise sum to 0 ; Find the value of pow ( i , 4 ) and then add it to the sum ; Return the sum ; Drivers Code ; Function call to find the sum","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , k ) ; } return sum ; } int main ( ) { int N = 8 , k = 4 ; cout << findSum ( N , k ) << endl ; return 0 ; }",Program to find value of 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k.,"#include <bits/stdc++.h>   using namespace std ; int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , k ) ; } return sum ; } int main ( ) { int N = 8 , k = 4 ; cout << findSum ( N , k ) << endl ; return 0 ; }","['int findSum ( int N , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findSum ( int N , int k ) {"
11,Count of indices in an array that satisfy the given condition | C ++ implementation of the approach ; Function to return the count of indices that satisfy the given condition ; To store the result ; To store the current maximum Initialized to 0 since there are only positive elements in the array ; i is a valid index ; Update the maximum so far ; Increment the counter ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << countIndices ( arr , n ) ; return 0 ; }",Count of indices in an array that satisfy the given condition.,"#include <bits/stdc++.h>   using namespace std ; int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << countIndices ( arr , n ) ; return 0 ; }","['int countIndices ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int countIndices ( int arr [ ] , int n ) {"
12,Maximum frequency of a remainder modulo 2 i | C ++ implementation of the approach ; Binary representation of the digits ; Function to return the maximum frequency of s modulo with a power of 2 ; Store the binary representation ; Convert the octal to binary ; Remove the LSB ; If there is 1 in the binary representation ; Find the number of zeroes in between two 1 's in the binary representation ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const string bin [ ] = { ""000"" , ""001"" , ""010"" , ""011"" , ""100"" , ""101"" , ""110"" , ""111"" } ; int maxFreq ( string s ) { string binary = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s [ i ] - '0' ] ; } binary = binary . substr ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = -1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary [ i ] == '1' ) { count = max ( count , j - prev ) ; prev = j ; } return count ; } int main ( ) { string octal = ""13"" ; cout << maxFreq ( octal ) ; return 0 ; }",Maximum frequency of a remainder modulo 2 i.,"#include <bits/stdc++.h>   using namespace std ; const string bin [ ] = { ""000"" , ""001"" , ""010"" , ""011"" , ""100"" , ""101"" , ""110"" , ""111"" } ; int maxFreq ( string s ) { string binary = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s [ i ] - '0' ] ; } binary = binary . substr ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = -1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary [ i ] == '1' ) { count = max ( count , j - prev ) ; prev = j ; } return count ; } int main ( ) { string octal = ""13"" ; cout << maxFreq ( octal ) ; return 0 ; }","['int maxFreq ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; const string bin [ ] = { ""000"" , ""001"" , ""010"" , ""011"" , ""100"" , ""101"" , ""110"" , ""111"" } ; int maxFreq ( string s ) {"
14,Find the number of cells in the table contains X | C ++ program to find number of cells in the table contains X ; Function to find number of cells in the table contains X ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; } int main ( ) { int n = 6 , x = 12 ; cout << ( Cells ( n , x ) ) ; return 0 ; }",Find the number of cells in the table contains X.,"#include <bits/stdc++.h>   using namespace std ; int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; } int main ( ) { int n = 6 , x = 12 ; cout << ( Cells ( n , x ) ) ; return 0 ; }","['int Cells ( int n , int x ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int Cells ( int n , int x ) {"
15,Find the maximum possible value of the minimum value of modified array | CPP program to find the maximum possible value of the minimum value of modified array ; Function to find the maximum possible value of the minimum value of the modified array ; To store minimum value of array ; To store sum of elements of array ; Solution is not possible ; zero is the possible value ; minimum possible value ; maximum possible value ; to store a required answer ; Binary Search ; If mid is possible then try to increase required answer ; If mid is not possible then decrease required answer ; Return required answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOfMin ( int a [ ] , int n , int S ) { int mi = INT_MAX ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = min ( a [ i ] , mi ) ; } if ( s1 < S ) return -1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } int main ( ) { int a [ ] = { 10 , 10 , 10 , 10 , 10 } ; int S = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxOfMin ( a , n , S ) ; return 0 ; }",Find the maximum possible value of the minimum value of modified array.,"#include <bits/stdc++.h>   using namespace std ; int maxOfMin ( int a [ ] , int n , int S ) { int mi = INT_MAX ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = min ( a [ i ] , mi ) ; } if ( s1 < S ) return -1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } int main ( ) { int a [ ] = { 10 , 10 , 10 , 10 , 10 } ; int S = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxOfMin ( a , n , S ) ; return 0 ; }","['int maxOfMin ( int a [ ] , int n , int S ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxOfMin ( int a [ ] , int n , int S ) {"
16,"Program to print ' N ' alphabet using the number pattern from 1 to n | C ++ implementation of the approach ; Function to print the desired Alphabet N Pattern ; Declaring the values of Right , Left and Diagonal values ; Main Loop for the rows ; For the left Values ; Spaces for the diagonals ; Condition for the diagonals ; Spaces for the Right Values ; For the right values ; Driver Code ; Size of the Pattern ; Calling the function to print the desired Pattern","#include <iostream> NEW_LINE using namespace std ; void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { cout << Left ++ ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) cout << "" ▁ "" ; if ( index != 0 && index != N - 1 ) cout << Diagonal ++ ; else cout << "" ▁ "" ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) cout << "" ▁ "" ; cout << Right ++ ; cout << endl ; } } int main ( int argc , char * * argv ) { int Size = 6 ; Alphabet_N_Pattern ( Size ) ; }",Program to print ' N ' alphabet using the number pattern from 1 to n.,"#include <iostream>   using namespace std ; void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { cout << Left ++ ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) cout << "" ▁ "" ; if ( index != 0 && index != N - 1 ) cout << Diagonal ++ ; else cout << "" ▁ "" ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) cout << "" ▁ "" ; cout << Right ++ ; cout << endl ; } } int main ( int argc , char * * argv ) { int Size = 6 ; Alphabet_N_Pattern ( Size ) ; }","['void Alphabet_N_Pattern ( int N ) {', 'int main ( int argc , char * * argv ) {']",#include <iostream>   using namespace std ; void Alphabet_N_Pattern ( int N ) {
17,Check if the sum of digits of a number N divides it | C ++ program to check if sum of digits of a number divides it ; Function to check if sum of digits of a number divides it ; Calculate sum of all of digits of N ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; } int main ( ) { int N = 12 ; if ( isSumDivides ( N ) ) cout << "" YES "" ; else cout << "" NO "" ; return 0 ; }",Check if the sum of digits of a number N divides it.,"#include <iostream>   using namespace std ; int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; } int main ( ) { int N = 12 ; if ( isSumDivides ( N ) ) cout << "" YES "" ; else cout << "" NO "" ; return 0 ; }","['int isSumDivides ( int N ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int isSumDivides ( int N ) {
18,Sum of numbers from 1 to N which are divisible by 3 or 4 | C ++ program to find sum of numbers from 1 to N which are divisible by 3 or 4 ; Function to calculate the sum of numbers divisible by 3 or 4 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; } int main ( ) { int N = 20 ; cout << sum ( 12 ) ; return 0 ; }",Sum of numbers from 1 to N which are divisible by 3 or 4.,"#include <bits/stdc++.h>   using namespace std ; int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; } int main ( ) { int N = 20 ; cout << sum ( 12 ) ; return 0 ; }","['int sum ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int sum ( int N ) {
19,Next greater number than N with exactly one bit different in binary representation of N | CPP program to find next greater number than N with exactly one bit different in binary representation of N ; Function to find next greater number than N with exactly one bit different in binary representation of N ; It is guaranteed that there is a bit zero in the number ; If the shifted bit is zero then break ; increase the bit shift ; increase the power of 2 ; set the lowest bit of the number ; Driver code ; display the next number,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long nextGreater ( long long N ) { long long power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; } int main ( ) { long long N = 11 ; cout << "" The ▁ next ▁ number ▁ is ▁ = ▁ "" << nextGreater ( N ) ; return 0 ; }",Next greater number than N with exactly one bit different in binary representation of N.,"#include <bits/stdc++.h>   using namespace std ; long long nextGreater ( long long N ) { long long power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; } int main ( ) { long long N = 11 ; cout << "" The ▁ next ▁ number ▁ is ▁ = ▁ "" << nextGreater ( N ) ; return 0 ; }","['long nextGreater ( long long N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; long long nextGreater ( long long N ) {
20,"Count number of ways to cover a distance | Set 2 | C ++ implementation of the approach ; Function to return the count of the total number of ways to cover the distance with 1 , 2 and 3 steps ; Base conditions ; To store the last three stages ; Find the numbers of steps required to reach the distance i ; Return the required answer ; Driver code","#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 , ans ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }",Count number of ways to cover a distance.,"#include <iostream>   using namespace std ; int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 , ans ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }","['int countWays ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int countWays ( int n ) {
23,Find the number of Chicks in a Zoo at Nth day | C ++ implementation of the approach ; Function to return the number of chicks on the nth day ; Size of dp [ ] has to be at least 6 ( 1 - based indexing ) ; Every day current population will be three times of the previous day ; Manually calculated value ; From 8 th day onwards ; Chick population decreases by 2 / 3 everyday . For 8 th day on [ i - 6 ] i . e 2 nd day population was 3 and so 2 new born die on the 6 th day and so on for the upcoming days ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getChicks ( int n ) { int size = max ( n , 7 ) ; ll dp [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 7 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }",Find the number of Chicks in a Zoo at Nth day.,"#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   ll getChicks ( int n ) { int size = max ( n , 7 ) ; ll dp [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 7 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }","['ll getChicks ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   ll getChicks ( int n ) {
24,Find the number of Chicks in a Zoo at Nth day | C ++ implementation of the approach ; Function to return the number of chicks on the nth day ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getChicks ( int n ) { ll chicks = ( ll ) pow ( 3 , n - 1 ) ; return chicks ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }",Find the number of Chicks in a Zoo at Nth day.,"#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   ll getChicks ( int n ) { ll chicks = ( ll ) pow ( 3 , n - 1 ) ; return chicks ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }","['ll getChicks ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   ll getChicks ( int n ) {
25,Find minimum steps required to reach the end of a matrix | Set 2 | C ++ implementation of the approach ; 2d array to store states of dp ; Array to determine whether a state has been solved before ; Function to return the minimum steps required ; Base cases ; If a state has been solved before it won 't be evaluated again ; Recurrence relation ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( int k = max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 4 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }",Find minimum steps required to reach the end of a matrix.,"#include <bits/stdc++.h>   #define n  3   using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( int k = max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 4 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }","['int minSteps ( int i , int j , int arr [ ] [ n ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   #define n  3   using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) {"
26,Find minimum steps required to reach the end of a matrix | Set | C ++ program to implement above approach ; 2d array to store states of dp ; array to determine whether a state has been solved before ; Function to find the minimum number of steps to reach the end of matrix ; base cases ; if a state has been solved before it won 't be evaluated again. ; recurrence relation ; Driver Code,"#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }",Find minimum steps required to reach the end of a matrix.,"#include <bits/stdc++.h>   #define n  3   using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }","['int minSteps ( int i , int j , int arr [ ] [ n ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   #define n  3   using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) {"
27,Treasure and Cities | A memoization based program to find maximum treasure that can be collected . ; k is current index and col is previous color . ; if ( k == n ) base case ; if ( col == color [ k ] ) check if color of this city is equal to prev visited city ; return max of both options ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1001 ; int dp [ MAX ] [ MAX ] ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != -1 ) return dp [ k ] [ col ] ; int sum = 0 ; sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }",Treasure and Cities.,"#include <bits/stdc++.h>   using namespace std ; const int MAX = 1001 ; int dp [ MAX ] [ MAX ] ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != -1 ) return dp [ k ] [ col ] ; int sum = 0 ; sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }","['int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; const int MAX = 1001 ; int dp [ MAX ] [ MAX ] ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) {"
28,Tetranacci Numbers | A DP based CPP program to print the nth tetranacci number ; Function to print the N - th tetranacci number ; base cases ; Driver code,#include <iostream> NEW_LINE using namespace std ; int printTetra ( int n ) { int dp [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; cout << dp [ n ] ; } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; },Tetranacci Numbers.,#include <iostream>   using namespace std ; int printTetra ( int n ) { int dp [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; cout << dp [ n ] ; } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; },"['int printTetra ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int printTetra ( int n ) {
30,"Permutation Coefficient | A O ( n ) solution that uses table fact [ ] to calculate the Permutation Coefficient ; Returns value of Permutation Coefficient P ( n , k ) ; Base case ; Calculate value factorials up to n ; P ( n , k ) = n ! / ( n - k ) ! ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; } int main ( ) { int n = 10 , k = 2 ; cout << "" Value ▁ of ▁ P ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << permutationCoeff ( n , k ) ; return 0 ; }",Permutation Coefficient.,"#include <bits/stdc++.h>   using namespace std ; int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; } int main ( ) { int n = 10 , k = 2 ; cout << "" Value ▁ of ▁ P ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << permutationCoeff ( n , k ) ; return 0 ; }","['int permutationCoeff ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int permutationCoeff ( int n , int k ) {"
31,"Dynamic Programming | A recursive solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following : ( a ) including the last element ( b ) excluding the last element ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ with ▁ given ▁ sum "" ; return 0 ; }",Dynamic Programming.,"#include <iostream>   using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ with ▁ given ▁ sum "" ; return 0 ; }","['bool isSubsetSum ( int set [ ] , int n , int sum ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) {"
33,Lexicographically smallest K | C ++ program for the above approach ; Function to find lexicographically smallest subsequence of size K ; Length of string ; Stores the minimum subsequence ; Traverse the string S ; If the stack is empty ; Iterate till the current character is less than the the character at the top of stack ; Check if there are enough characters remaining to obtain length K ; If stack size is < K ; Push the current character into it ; Stores the resultant string ; Iterate until stack is empty ; Reverse the string ; Print the string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestSubsequence ( string & S , int K ) { int N = S . size ( ) ; stack < char > answer ; for ( int i = 0 ; i < N ; ++ i ) { if ( answer . empty ( ) ) { answer . push ( S [ i ] ) ; } else { while ( ( ! answer . empty ( ) ) && ( S [ i ] < answer . top ( ) ) && ( answer . size ( ) - 1 + N - i >= K ) ) { answer . pop ( ) ; } if ( answer . empty ( ) || answer . size ( ) < K ) { answer . push ( S [ i ] ) ; } } } string ret ; while ( ! answer . empty ( ) ) { ret . push_back ( answer . top ( ) ) ; answer . pop ( ) ; } reverse ( ret . begin ( ) , ret . end ( ) ) ; cout << ret ; } int main ( ) { string S = "" aabdaabc "" ; int K = 3 ; smallestSubsequence ( S , K ) ; return 0 ; }",Lexicographically smallest K.,"#include <bits/stdc++.h>   using namespace std ; void smallestSubsequence ( string & S , int K ) { int N = S . size ( ) ; stack < char > answer ; for ( int i = 0 ; i < N ; ++ i ) { if ( answer . empty ( ) ) { answer . push ( S [ i ] ) ; } else { while ( ( ! answer . empty ( ) ) && ( S [ i ] < answer . top ( ) ) && ( answer . size ( ) - 1 + N - i >= K ) ) { answer . pop ( ) ; } if ( answer . empty ( ) || answer . size ( ) < K ) { answer . push ( S [ i ] ) ; } } } string ret ; while ( ! answer . empty ( ) ) { ret . push_back ( answer . top ( ) ) ; answer . pop ( ) ; } reverse ( ret . begin ( ) , ret . end ( ) ) ; cout << ret ; } int main ( ) { string S = "" aabdaabc "" ; int K = 3 ; smallestSubsequence ( S , K ) ; return 0 ; }","['void smallestSubsequence ( string & S , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void smallestSubsequence ( string & S , int K ) {"
34,Check if string is right to left diagonal or not | C ++ program to Check if the given string is right to left diagonal or not ; Function to check if the given string is right to left diagonal or not ; Iterate over string ; If character is not same as the first character then return false ; Driver Code ; Given String str ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int is_rtol ( string s ) { int tmp = sqrt ( s . length ( ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; } int main ( ) { string str = "" abcxabxcaxbcxabc "" ; if ( is_rtol ( str ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }",Check if string is right to left diagonal or not.,"#include <bits/stdc++.h>   using namespace std ; int is_rtol ( string s ) { int tmp = sqrt ( s . length ( ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; } int main ( ) { string str = "" abcxabxcaxbcxabc "" ; if ( is_rtol ( str ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }","['int is_rtol ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int is_rtol ( string s ) {
35,"Split a given string into substrings of length K with equal sum of ASCII values | C ++ program to check if a given string can be split into substrings of size K having an equal sum of ASCII values . ; Function for checking string ; Check if the string can be split into substrings of K length only ; Compute the sum of first substring of length K ; Compute the sum of remaining substrings ; Check if sum is equal to that of the first substring ; Since all sums are not equal , return false ; All sums are equal , Return true ; All substrings cannot be of size K ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str , int K ) { if ( str . size ( ) % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] ; } for ( int j = i ; j < str . size ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str [ p ] ; if ( s_comp != sum ) return false ; } return true ; } return false ; } int main ( ) { int K = 3 ; string str = "" abdcbbdba "" ; if ( check ( str , K ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; }",Split a given string into substrings of length K with equal sum of ASCII values.,"#include <bits/stdc++.h>   using namespace std ; bool check ( string str , int K ) { if ( str . size ( ) % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] ; } for ( int j = i ; j < str . size ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str [ p ] ; if ( s_comp != sum ) return false ; } return true ; } return false ; } int main ( ) { int K = 3 ; string str = "" abdcbbdba "" ; if ( check ( str , K ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; }","['bool check ( string str , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool check ( string str , int K ) {"
36,Maximize count of 0 s in left and 1 s in right substring by splitting given Binary string | C ++ program for the above approach ; Function to maximize the sum of the count of zeros and ones in the left and right substring ; To store the total ones ; Count the total numbers of ones in string str ; To store the count of zeros and ones while traversing string ; Iterate the given string and update the maximum sum ; Update the maximum Sum ; Driver Code ; Given binary string ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( string & str ) { int maximumSum = 0 ; int totalOnes ; totalOnes = count ( str . begin ( ) , str . end ( ) , '1' ) ; int zero = 0 , ones = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { ones ++ ; } maximumSum = max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; } int main ( ) { string str = ""011101"" ; cout << maxSum ( str ) ; return 0 ; }",Maximize count of 0 s in left and 1 s in right substring by splitting given Binary string.,"#include <bits/stdc++.h>   using namespace std ; int maxSum ( string & str ) { int maximumSum = 0 ; int totalOnes ; totalOnes = count ( str . begin ( ) , str . end ( ) , '1' ) ; int zero = 0 , ones = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { ones ++ ; } maximumSum = max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; } int main ( ) { string str = ""011101"" ; cout << maxSum ( str ) ; return 0 ; }","['int maxSum ( string & str ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int maxSum ( string & str ) {
37,Longest substring such that no three consecutive characters are same | C ++ implementation of the approach ; Function to return the length of the longest substring such that no three consecutive characters are same ; If the length of the given string is less than 3 ; Initialize temporary and final ans to 2 as this is the minimum length of substring when length of the given string is greater than 2 ; Traverse the string from the third character to the last ; If no three consecutive characters are same then increment temporary count ; Else update the final ans and reset the temporary count ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLenSubStr ( string & s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = max ( temp , ans ) ; temp = 2 ; } } ans = max ( temp , ans ) ; return ans ; } int main ( ) { string s = "" baaabbabbb "" ; cout << maxLenSubStr ( s ) ; return 0 ; }",Longest substring such that no three consecutive characters are same.,"#include <bits/stdc++.h>   using namespace std ; int maxLenSubStr ( string & s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = max ( temp , ans ) ; temp = 2 ; } } ans = max ( temp , ans ) ; return ans ; } int main ( ) { string s = "" baaabbabbb "" ; cout << maxLenSubStr ( s ) ; return 0 ; }","['int maxLenSubStr ( string & s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int maxLenSubStr ( string & s ) {
38,Number of ways to remove a sub | C ++ program to count number of ways of removing a substring from a string such that all remaining characters are equal ; Function to return the number of ways of removing a sub - string from s such that all the remaining characters are same ; To store the count of prefix and suffix ; Loop to count prefix ; Loop to count suffix ; First and last characters of the string are same ; Otherwise ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int no_of_ways ( string s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } int main ( ) { string s = "" geeksforgeeks "" ; cout << no_of_ways ( s ) ; return 0 ; }",Number of ways to remove a sub.,"#include <bits/stdc++.h>   using namespace std ; int no_of_ways ( string s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } int main ( ) { string s = "" geeksforgeeks "" ; cout << no_of_ways ( s ) ; return 0 ; }","['int no_of_ways ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int no_of_ways ( string s ) {
40,Find the direction from given string | CPP implementation of above approach ; Function to find the final direction ; if count is positive that implies resultant is clockwise direction ; if count is negative that implies resultant is anti - clockwise direction ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string findDirection ( string s ) { int count = 0 ; string d = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ 0 ] == ' ' ) return NULL ; if ( s [ i ] == ' L ' ) count -- ; else { if ( s [ i ] == ' R ' ) count ++ ; } } if ( count > 0 ) { if ( count % 4 == 0 ) d = "" N "" ; else if ( count % 4 == 1 ) d = "" E "" ; else if ( count % 4 == 2 ) d = "" S "" ; else if ( count % 4 == 3 ) d = "" W "" ; } if ( count < 0 ) { if ( count % 4 == 0 ) d = "" N "" ; else if ( count % 4 == -1 ) d = "" W "" ; else if ( count % 4 == -2 ) d = "" S "" ; else if ( count % 4 == -3 ) d = "" E "" ; } return d ; } int main ( ) { string s = "" LLRLRRL "" ; cout << ( findDirection ( s ) ) << endl ; s = "" LL "" ; cout << ( findDirection ( s ) ) << endl ; }",Find the direction from given string.,"#include <bits/stdc++.h>   using namespace std ; string findDirection ( string s ) { int count = 0 ; string d = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ 0 ] == ' ' ) return NULL ; if ( s [ i ] == ' L ' ) count -- ; else { if ( s [ i ] == ' R ' ) count ++ ; } } if ( count > 0 ) { if ( count % 4 == 0 ) d = "" N "" ; else if ( count % 4 == 1 ) d = "" E "" ; else if ( count % 4 == 2 ) d = "" S "" ; else if ( count % 4 == 3 ) d = "" W "" ; } if ( count < 0 ) { if ( count % 4 == 0 ) d = "" N "" ; else if ( count % 4 == -1 ) d = "" W "" ; else if ( count % 4 == -2 ) d = "" S "" ; else if ( count % 4 == -3 ) d = "" E "" ; } return d ; } int main ( ) { string s = "" LLRLRRL "" ; cout << ( findDirection ( s ) ) << endl ; s = "" LL "" ; cout << ( findDirection ( s ) ) << endl ; }","['string findDirection ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; string findDirection ( string s ) {
41,Check if lowercase and uppercase characters are in same order | C ++ program to check if lowercase and uppercase characters are in same order ; Function to check if both the case follow the same order ; Traverse the string ; Store both lowercase and uppercase in two different strings ; using transform ( ) function and :: toupper in STL ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCheck ( string str ) { int len = str . length ( ) ; string lowerStr = "" "" , upperStr = "" "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= 65 && str [ i ] <= 91 ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } transform ( lowerStr . begin ( ) , lowerStr . end ( ) , lowerStr . begin ( ) , :: toupper ) ; return lowerStr == upperStr ; } int main ( ) { string str = "" geeGkEEsKS "" ; isCheck ( str ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Check if lowercase and uppercase characters are in same order.,"#include <bits/stdc++.h>   using namespace std ; bool isCheck ( string str ) { int len = str . length ( ) ; string lowerStr = "" "" , upperStr = "" "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= 65 && str [ i ] <= 91 ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } transform ( lowerStr . begin ( ) , lowerStr . end ( ) , lowerStr . begin ( ) , :: toupper ) ; return lowerStr == upperStr ; } int main ( ) { string str = "" geeGkEEsKS "" ; isCheck ( str ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }","['bool isCheck ( string str ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; bool isCheck ( string str ) {
42,Replace every character of string by character whose ASCII value is K times more than it | CPP program to move every character K times ahead in a given string ; Function to move string character ; changed string ; iterate for every characters ; ASCII value ; store the duplicate ; if k - th ahead character exceed ' z ' ; print the new string ; driver code ; function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void encode ( string s , int k ) { string newS ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int val = int ( s [ i ] ) ; int dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += char ( 96 + k ) ; } else newS += char ( val + k ) ; k = dup ; } cout << newS ; } int main ( ) { string str = "" abc "" ; int k = 28 ; encode ( str , k ) ; return 0 ; }",Replace every character of string by character whose ASCII value is K times more than it.,"#include <bits/stdc++.h>   using namespace std ; void encode ( string s , int k ) { string newS ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int val = int ( s [ i ] ) ; int dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += char ( 96 + k ) ; } else newS += char ( val + k ) ; k = dup ; } cout << newS ; } int main ( ) { string str = "" abc "" ; int k = 28 ; encode ( str , k ) ; return 0 ; }","['void encode ( string s , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void encode ( string s , int k ) {"
45,Tridecagonal Number | C ++ program to find N - th Tridecagonal number ; Function to find N - th Tridecagonal number ; Formula to calculate nth Tridecagonal number ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Tridecagonal_num ( n ) << endl ; n = 10 ; cout << Tridecagonal_num ( n ) << endl ; return 0 ; },Tridecagonal Number.,#include <bits/stdc++.h>   using namespace std ; int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Tridecagonal_num ( n ) << endl ; n = 10 ; cout << Tridecagonal_num ( n ) << endl ; return 0 ; },"['int Tridecagonal_num ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int Tridecagonal_num ( int n ) {
46,Check if a given Binary Tree is Heap | C ++ program to checks if a binary tree is max heap or not ; Tree node structure ; To add a new node ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int k ) { struct Node * node = new Node ; node -> data = k ; node -> right = node -> left = NULL ; return node ; } bool isHeap ( Node * root ) { queue < Node * > q ; q . push ( root ) ; bool nullish = false ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { if ( nullish temp -> left -> data > = temp -> data ) { return false ; } q . push ( temp -> left ) ; } else { nullish = true ; } if ( temp -> right ) { if ( nullish temp -> right -> data > = temp -> data ) { return false ; } q . push ( temp -> right ) ; } else { nullish = true ; } } return true ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 3 ) ; root -> left -> left -> right = newNode ( 2 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( isHeap ( root ) ) cout << "" Given ▁ binary ▁ tree ▁ is ▁ a ▁ Heap STRNEWLINE "" ; else cout << "" Given ▁ binary ▁ tree ▁ is ▁ not ▁ a ▁ Heap STRNEWLINE "" ; return 0 ; }",Check if a given Binary Tree is Heap.,"#include <bits/stdc++.h>   using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int k ) { struct Node * node = new Node ; node -> data = k ; node -> right = node -> left = NULL ; return node ; } bool isHeap ( Node * root ) { queue < Node * > q ; q . push ( root ) ; bool nullish = false ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { if ( nullish temp -> left -> data > = temp -> data ) { return false ; } q . push ( temp -> left ) ; } else { nullish = true ; } if ( temp -> right ) { if ( nullish temp -> right -> data > = temp -> data ) { return false ; } q . push ( temp -> right ) ; } else { nullish = true ; } } return true ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 3 ) ; root -> left -> left -> right = newNode ( 2 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( isHeap ( root ) ) cout << "" Given ▁ binary ▁ tree ▁ is ▁ a ▁ Heap STRNEWLINE "" ; else cout << "" Given ▁ binary ▁ tree ▁ is ▁ not ▁ a ▁ Heap STRNEWLINE "" ; return 0 ; }","['bool isHeap ( Node * root ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int k ) { struct Node * node = new Node ; node -> data = k ; node -> right = node -> left = NULL ; return node ; } bool isHeap ( Node * root ) {
48,Maximum height of triangular arrangement of array values | C ++ program to find the maximum height of Pyramidal Arrangement of array values ; Just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) / 2 elements in the array ; updating the result value each time ; otherwise we have exceeded n value ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; } int main ( ) { int arr [ ] = { 40 , 100 , 20 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaximumHeight ( arr , n ) ; return 0 ; }",Maximum height of triangular arrangement of array values.,"#include <bits/stdc++.h>   using namespace std ; int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; } int main ( ) { int arr [ ] = { 40 , 100 , 20 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaximumHeight ( arr , n ) ; return 0 ; }","['int MaximumHeight ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int MaximumHeight ( int a [ ] , int n ) {"
49,k | CPP program to find k - th element in the Odd - Even sequence . ; insert all the odd numbers from 1 to n . ; insert all the even numbers from 1 to n . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int n , int k ) { vector < long > a ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push_back ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push_back ( i ) ; return ( a [ k - 1 ] ) ; } int main ( ) { long n = 10 , k = 3 ; cout << findK ( n , k ) << endl ; return 0 ; }",k.,"#include <bits/stdc++.h>   using namespace std ; int findK ( int n , int k ) { vector < long > a ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push_back ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push_back ( i ) ; return ( a [ k - 1 ] ) ; } int main ( ) { long n = 10 , k = 3 ; cout << findK ( n , k ) << endl ; return 0 ; }","['int findK ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findK ( int n , int k ) {"
50,One line function for factorial of a number | C ++ program to find factorial of given number ; single line to find factorial ; Driver Code,"#include <iostream> NEW_LINE int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; printf ( "" Factorial ▁ of ▁ % d ▁ is ▁ % d "" , num , factorial ( num ) ) ; return 0 ; }",One line function for factorial of a number.,"#include <iostream>   int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; printf ( "" Factorial ▁ of ▁ % d ▁ is ▁ % d "" , num , factorial ( num ) ) ; return 0 ; }","['int factorial ( int n ) {', 'int main ( ) {']",#include <iostream>   int factorial ( int n ) {
51,Pell Number | Iterative Pell Number Series in C ++ ; Calculate nth pell number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; } int main ( ) { int n = 4 ; cout << pell ( n ) ; return 0 ; }",Pell Number.,"#include <bits/stdc++.h>   using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; } int main ( ) { int n = 4 ; cout << pell ( n ) ; return 0 ; }","['int pell ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int pell ( int n ) {
52,An efficient way to check whether n | A simple C ++ program to check if n - th Fibonacci number is multiple of 10. ; Returns true if n - th Fibonacci number is multiple of 10. ; main function,"#include <bits/stdc++.h> NEW_LINE bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; } int main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) printf ( "" Yes STRNEWLINE "" ) ; else printf ( "" No STRNEWLINE "" ) ; return 0 ; }",An efficient way to check whether n.,"#include <bits/stdc++.h>   bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; } int main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) printf ( "" Yes STRNEWLINE "" ) ; else printf ( "" No STRNEWLINE "" ) ; return 0 ; }","['bool isMultipleOf10 ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   bool isMultipleOf10 ( int n ) {
55,Program for factorial of a number | C ++ program to find factorial of given number ; function to find factorial of given number ; Driver code,"#include <iostream> NEW_LINE using namespace std ; unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << "" Factorial ▁ of ▁ "" << num << "" ▁ is ▁ "" << factorial ( num ) << endl ; return 0 ; }",Program for factorial of a number.,"#include <iostream>   using namespace std ; unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << "" Factorial ▁ of ▁ "" << num << "" ▁ is ▁ "" << factorial ( num ) << endl ; return 0 ; }","['int factorial ( unsigned int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; unsigned int factorial ( unsigned int n ) {
56,Turn off the rightmost set bit | Set 2 | C ++ program to unset the rightmost set bit ; Unsets the rightmost set bit of n and returns the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int FlipBits ( unsigned int n ) { return n -= ( n & ( - n ) ) ; } int main ( ) { int N = 12 ; cout << "" The ▁ number ▁ after ▁ unsetting ▁ the "" ; cout << "" ▁ rightmost ▁ set ▁ bit : ▁ "" << FlipBits ( N ) ; return 0 ; }",Turn off the rightmost set bit.,"#include <bits/stdc++.h>   using namespace std ; int FlipBits ( unsigned int n ) { return n -= ( n & ( - n ) ) ; } int main ( ) { int N = 12 ; cout << "" The ▁ number ▁ after ▁ unsetting ▁ the "" ; cout << "" ▁ rightmost ▁ set ▁ bit : ▁ "" << FlipBits ( N ) ; return 0 ; }","['int FlipBits ( unsigned int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int FlipBits ( unsigned int n ) {
57,Maximum value of XOR among all triplets of an array | C ++ implementation of the approach ; function to count maximum XOR value for a triplet ; set is used to avoid repetitions ; store all possible unique XOR value of pairs ; store maximum value ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maximum_xor_Triplet ( int n , int a [ ] ) { set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { s . insert ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; for ( auto i : s ) { for ( int j = 0 ; j < n ; j ++ ) { ans = max ( ans , i ^ a [ j ] ) ; } } cout << ans << "" STRNEWLINE "" ; } int main ( ) { int a [ ] = { 1 , 3 , 8 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Maximum_xor_Triplet ( n , a ) ; return 0 ; }",Maximum value of XOR among all triplets of an array.,"#include <bits/stdc++.h>   using namespace std ; void Maximum_xor_Triplet ( int n , int a [ ] ) { set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { s . insert ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; for ( auto i : s ) { for ( int j = 0 ; j < n ; j ++ ) { ans = max ( ans , i ^ a [ j ] ) ; } } cout << ans << "" STRNEWLINE "" ; } int main ( ) { int a [ ] = { 1 , 3 , 8 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Maximum_xor_Triplet ( n , a ) ; return 0 ; }","['void Maximum_xor_Triplet ( int n , int a [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void Maximum_xor_Triplet ( int n , int a [ ] ) {"
58,"Find missing elements of a range | A sorting based C ++ program to find missing elements from an array ; Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; Do binary search for ' low ' in sorted array and find index of first element which either equal to or greater than low . ; Start from the found index and linearly search every range element x after this index in arr [ ] ; If x doesn 't math with current element  print it ; If x matches , move to next element in arr [ ] ; Move to next element in range [ low , high ] ; Print range elements thar are greater than the last element of sorted array . ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { sort ( arr , arr + n ) ; int * ptr = lower_bound ( arr , arr + n , low ) ; int index = ptr - arr ; int i = index , x = low ; while ( i < n && x <= high ) { if ( arr [ i ] != x ) cout << x << "" ▁ "" ; else i ++ ; x ++ ; } while ( x <= high ) cout << x ++ << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }",Find missing elements of a range.,"#include <bits/stdc++.h>   using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { sort ( arr , arr + n ) ; int * ptr = lower_bound ( arr , arr + n , low ) ; int index = ptr - arr ; int i = index , x = low ; while ( i < n && x <= high ) { if ( arr [ i ] != x ) cout << x << "" ▁ "" ; else i ++ ; x ++ ; } while ( x <= high ) cout << x ++ << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }","['void printMissing ( int arr [ ] , int n , int low , int high ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) {"
59,"Find missing elements of a range | An array based C ++ program to find missing elements from an array ; Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; Create boolean array of size high - low + 1 , each index i representing wether ( i + low ) th element found or not . ; if ith element of arr is in range low to high then mark corresponding index as true in array ; Traverse through the range and print all elements whose value is false ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { bool points_of_range [ high - low + 1 ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; } for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) cout << low + x << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }",Find missing elements of a range.,"#include <bits/stdc++.h>   using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { bool points_of_range [ high - low + 1 ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; } for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) cout << low + x << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }","['void printMissing ( int arr [ ] , int n , int low , int high ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) {"
60,"Find missing elements of a range | A hashing based C ++ program to find missing elements from an array ; Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; Insert all elements of arr [ ] in set ; Traverse throught the range an print all missing elements ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int x = low ; x <= high ; x ++ ) if ( s . find ( x ) == s . end ( ) ) cout << x << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }",Find missing elements of a range.,"#include <bits/stdc++.h>   using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int x = low ; x <= high ; x ++ ) if ( s . find ( x ) == s . end ( ) ) cout << x << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }","['void printMissing ( int arr [ ] , int n , int low , int high ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) {"
61,k | C ++ program to find the k - th missing element in a given sequence ; Returns k - th missing element . It returns - 1 if no k is more than number of missing elements . ; Insert all elements of givens sequence b [ ] . ; Traverse through increasing sequence and keep track of count of missing numbers . ; driver program to test the above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return -1 ; } int main ( ) { int a [ ] = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int b [ ] = { 4 , 10 , 6 , 8 , 12 } ; int n1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int n2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; int k = 3 ; cout << find ( a , b , k , n1 , n2 ) ; return 0 ; }",k.,"#include <bits/stdc++.h>   using namespace std ; int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return -1 ; } int main ( ) { int a [ ] = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int b [ ] = { 4 , 10 , 6 , 8 , 12 } ; int n1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int n2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; int k = 3 ; cout << find ( a , b , k , n1 , n2 ) ; return 0 ; }","['int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) {"
62,"Minimize steps to form string S from any random string of length K using a fixed length subsequences | C ++ program for the above approach ; Function to find the minimum number of string required to generate the original string ; Stores the frequency of each character of String S ; Iterate over the range [ 0 , 25 ] ; Stores the frequency of each character of String S ; Count unique characters in S ; If unique characters is greater then N , then return - 1 ; Otherwise ; Perform Binary Search ; Find the value of mid ; Iterate over the range [ 0 , 26 ] ; If the amount [ i ] is greater than 0 ; Update the ranges ; Find the resultant string ; Generate the subsequence ; If the length of resultant string is less than N than add a character ' a ' ; Print the string ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findString ( string S , int N ) { int amounts [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; } for ( int i = 0 ; i < S . length ( ) ; i ++ ) { amounts [ int ( S [ i ] ) - 97 ] ++ ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; } if ( count > N ) { cout << "" - 1"" ; } else { string ans = "" "" ; int high = 100001 ; int low = 0 ; int mid , total ; while ( ( high - low ) > 1 ) { total = 0 ; mid = ( high + low ) / 2 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / mid + 1 ; } } if ( total <= N ) { high = mid ; } else { low = mid ; } } cout << high << "" ▁ "" ; total = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / high + 1 ; for ( int j = 0 ; j < ( ( amounts [ i ] - 1 ) / high + 1 ) ; j ++ ) { ans += char ( i + 97 ) ; } } } for ( int i = total ; i < N ; i ++ ) { ans += ' a ' ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; cout << ans ; } } int main ( ) { string S = "" toffee "" ; int K = 4 ; findString ( S , K ) ; return 0 ; }",Minimize steps to form string S from any random string of length K using a fixed length subsequences.,"#include <bits/stdc++.h>   using namespace std ; void findString ( string S , int N ) { int amounts [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; } for ( int i = 0 ; i < S . length ( ) ; i ++ ) { amounts [ int ( S [ i ] ) - 97 ] ++ ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; } if ( count > N ) { cout << "" - 1"" ; } else { string ans = "" "" ; int high = 100001 ; int low = 0 ; int mid , total ; while ( ( high - low ) > 1 ) { total = 0 ; mid = ( high + low ) / 2 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / mid + 1 ; } } if ( total <= N ) { high = mid ; } else { low = mid ; } } cout << high << "" ▁ "" ; total = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / high + 1 ; for ( int j = 0 ; j < ( ( amounts [ i ] - 1 ) / high + 1 ) ; j ++ ) { ans += char ( i + 97 ) ; } } } for ( int i = total ; i < N ; i ++ ) { ans += ' a ' ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; cout << ans ; } } int main ( ) { string S = "" toffee "" ; int K = 4 ; findString ( S , K ) ; return 0 ; }","['void findString ( string S , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findString ( string S , int N ) {"
63,"Find the first repeating element in an array of integers | C ++ program to find first repeating element in arr [ ] ; This function prints the first repeating element in arr [ ] ; Initialize index of first repeating element ; Creates an empty hashset ; Traverse the input array from right to left ; If element is already in hash set , update min ; Else add element to hash set ; Print the result ; Driver method to test above method","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int min = -1 ; set < int > myset ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i ; else myset . insert ( arr [ i ] ) ; } if ( min != -1 ) cout << "" The ▁ first ▁ repeating ▁ element ▁ is ▁ "" << arr [ min ] ; else cout << "" There ▁ are ▁ no ▁ repeating ▁ elements "" ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }",Find the first repeating element in an array of integers.,"#include <bits/stdc++.h>   using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int min = -1 ; set < int > myset ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i ; else myset . insert ( arr [ i ] ) ; } if ( min != -1 ) cout << "" The ▁ first ▁ repeating ▁ element ▁ is ▁ "" << arr [ min ] ; else cout << "" There ▁ are ▁ no ▁ repeating ▁ elements "" ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }","['void printFirstRepeating ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) {"
64,"Find the first repeating element in an array of integers | C ++ program to find first repeating element in arr [ ] ; This function prints the first repeating element in arr [ ] ; This will set k = 1 , if any repeating element found ; max = maximum from ( all elements & n ) ; Array a is for storing 1 st time occurence of element initialized by 0 ; Store 1 in array b if element is duplicate initialized by 0 ; Duplicate element found ; storing 1 st occurence of arr [ i ] ; trace array a & find repeating element with min index ; Driver method to test above method","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int k = 0 ; int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ; int a [ max + 1 ] = { } ; int b [ max + 1 ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ arr [ i ] ] ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else a [ arr [ i ] ] = i ; } if ( k == 0 ) cout << "" No ▁ repeating ▁ element ▁ found "" << endl ; else { int min = max + 1 ; for ( int i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] && min > a [ i ] && b [ i ] ) min = a [ i ] ; cout << arr [ min ] ; } cout << endl ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }",Find the first repeating element in an array of integers.,"#include <bits/stdc++.h>   using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int k = 0 ; int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ; int a [ max + 1 ] = { } ; int b [ max + 1 ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ arr [ i ] ] ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else a [ arr [ i ] ] = i ; } if ( k == 0 ) cout << "" No ▁ repeating ▁ element ▁ found "" << endl ; else { int min = max + 1 ; for ( int i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] && min > a [ i ] && b [ i ] ) min = a [ i ] ; cout << arr [ min ] ; } cout << endl ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }","['void printFirstRepeating ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) {"
65,k | C ++ program to print k - th distinct element in a given array ; Returns k - th distinct element in arr . ; Check if current element is present somewhere else . ; If element is unique ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; } int main ( ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; int k = 2 ; cout << printKDistinct ( ar , n , k ) ; return 0 ; }",k.,"#include <bits/stdc++.h>   using namespace std ; int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; } int main ( ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; int k = 2 ; cout << printKDistinct ( ar , n , k ) ; return 0 ; }","['int printKDistinct ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int printKDistinct ( int arr [ ] , int n , int k ) {"
66,Count subarrays having an equal count of 0 s and 1 s segregated | C ++ program for the above approach ; Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together ; Stores the count ; Initialize cur with first element ; If the next element is same as the current element ; Increment count ; Update curr ; Iterate over the array count ; Consider the minimum ; Driver code ; Given arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int A [ ] , int N ) { int res = 0 ; int curr = A [ 0 ] ; vector < int > cnt = { 1 } ; for ( int c = 1 ; c < N ; c ++ ) { if ( A == curr ) cnt [ cnt . size ( ) - 1 ] ++ ; else curr = A ; cnt . push_back ( 1 ) ; } for ( int i = 1 ; i < cnt . size ( ) ; i ++ ) { res += min ( cnt [ i - 1 ] , cnt [ i ] ) ; } cout << ( res - 1 ) ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }",Count subarrays having an equal count of 0 s and 1 s segregated.,"#include <bits/stdc++.h>   using namespace std ; void countSubarrays ( int A [ ] , int N ) { int res = 0 ; int curr = A [ 0 ] ; vector < int > cnt = { 1 } ; for ( int c = 1 ; c < N ; c ++ ) { if ( A == curr ) cnt [ cnt . size ( ) - 1 ] ++ ; else curr = A ; cnt . push_back ( 1 ) ; } for ( int i = 1 ; i < cnt . size ( ) ; i ++ ) { res += min ( cnt [ i - 1 ] , cnt [ i ] ) ; } cout << ( res - 1 ) ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }","['void countSubarrays ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void countSubarrays ( int A [ ] , int N ) {"
68,Maximize minimum distance between repetitions from any permutation of the given Array | C ++ Program to implement the above approach ; Size of the array ; Stores the frequency of array elements ; Find the highest frequency in the array ; Increase count of max frequent element ; If no repetition is present ; Find the maximum distance ; Return the max distance ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLen ( vector < int > & a ) { int n = a . size ( ) ; int freq [ n + 1 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } int maxFreqElement = INT_MIN ; int maxFreqCount = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; } else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } int ans ; if ( maxFreqElement == 1 ) ans = 0 ; else { ans = ( ( n - maxFreqCount ) / ( maxFreqElement - 1 ) ) ; } return ans ; } int main ( ) { vector < int > a = { 1 , 2 , 1 , 2 } ; cout << findMaxLen ( a ) << endl ; }",Maximize minimum distance between repetitions from any permutation of the given Array.,"#include <bits/stdc++.h>   using namespace std ; int findMaxLen ( vector < int > & a ) { int n = a . size ( ) ; int freq [ n + 1 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } int maxFreqElement = INT_MIN ; int maxFreqCount = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; } else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } int ans ; if ( maxFreqElement == 1 ) ans = 0 ; else { ans = ( ( n - maxFreqCount ) / ( maxFreqElement - 1 ) ) ; } return ans ; } int main ( ) { vector < int > a = { 1 , 2 , 1 , 2 } ; cout << findMaxLen ( a ) << endl ; }","['int findMaxLen ( vector < int > & a ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int findMaxLen ( vector < int > & a ) {
70,Find number of pairs in an array such that their XOR is 0 | C ++ program to find number of pairs in an array such that their XOR is 0 ; Function to calculate the count ; Sorting the list using built in function ; Traversing through the elements ; Counting frequency of each elements ; Adding the contribution of the frequency to the answer ; Driver Code ; Print the count,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }",Find number of pairs in an array such that their XOR is 0.,"#include <bits/stdc++.h>   using namespace std ; int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }","['int calculate ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int calculate ( int a [ ] , int n ) {"
71,Find number of pairs in an array such that their XOR is 0 | C ++ program to find number of pairs in an array such that their XOR is 0 ; Function to calculate the answer ; Finding the maximum of the array ; Creating frequency array With initial value 0 ; Traversing through the array ; Counting frequency ; Traversing through the frequency array ; Calculating answer ; Driver Code ; Function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { int * maximum = max_element ( a , a + n ) ; int frequency [ * maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( calculate ( a , n ) ) ; }",Find number of pairs in an array such that their XOR is 0.,"#include <bits/stdc++.h>   using namespace std ; int calculate ( int a [ ] , int n ) { int * maximum = max_element ( a , a + n ) ; int frequency [ * maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( calculate ( a , n ) ) ; }","['int calculate ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int calculate ( int a [ ] , int n ) {"
72,"Largest subarray with equal number of 0 s and 1 s | A simple C ++ program to find the largest subarray with equal number of 0 s and 1 s ; This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray . ; Pick a starting point as i ; Consider all subarrays starting from i ; If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << "" No ▁ such ▁ subarray "" ; else cout << startindex << "" ▁ to ▁ "" << startindex + maxsize - 1 ; return maxsize ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }",Largest subarray with equal number of 0 s and 1 s.,"#include <bits/stdc++.h>   using namespace std ; int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << "" No ▁ such ▁ subarray "" ; else cout << startindex << "" ▁ to ▁ "" << startindex + maxsize - 1 ; return maxsize ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }","['int findSubArray ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findSubArray ( int arr [ ] , int n ) {"
73,"Maximum element in a sorted and rotated array |  ; Function to return the maximum element ; If there is only one element left ; Find mid ; Check if mid reaches 0 , it is greater than next element or not ; Check if mid itself is maximum element ; Decide whether we need to go to the left half or the right half ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMax ( int arr [ ] , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } } int main ( ) { int arr [ ] = { 6 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMax ( arr , 0 , n - 1 ) ; return 0 ; }",Maximum element in a sorted and rotated array.,"#include <bits/stdc++.h>   using namespace std ; int findMax ( int arr [ ] , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } } int main ( ) { int arr [ ] = { 6 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMax ( arr , 0 , n - 1 ) ; return 0 ; }","['int findMax ( int arr [ ] , int low , int high ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMax ( int arr [ ] , int low , int high ) {"
75,Majority Element | Set |  ; function to print the majority Number ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int majorityNumber ( int arr [ ] , int n ) { int ans = -1 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq [ arr [ i ] ] > n / 2 ) ans = arr [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 2 , 2 , 1 , 1 , 1 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << majorityNumber ( a , n ) ; return 0 ; }",Majority Element.,"#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   int majorityNumber ( int arr [ ] , int n ) { int ans = -1 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq [ arr [ i ] ] > n / 2 ) ans = arr [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 2 , 2 , 1 , 1 , 1 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << majorityNumber ( a , n ) ; return 0 ; }","['int majorityNumber ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   int majorityNumber ( int arr [ ] , int n ) {"
76,"Search an element in a sorted and rotated array | Search an element in sorted and rotated array using single pass of Binary Search ; Returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1 ; If arr [ l ... mid ] is sorted ; As this subarray is sorted , we can quickly check if key lies in half or other half ; If key not lies in first half subarray , Divide other half into two subarrays , such that we can quickly check if key lies in other half ; If arr [ l . . mid ] first subarray is not sorted , then arr [ mid ... h ] must be sorted subarray ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != -1 ) cout << "" Index : ▁ "" << i << endl ; else cout << "" Key ▁ not ▁ found "" ; }",Search an element in a sorted and rotated array.,"#include <bits/stdc++.h>   using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != -1 ) cout << "" Index : ▁ "" << i << endl ; else cout << "" Key ▁ not ▁ found "" ; }","['int search ( int arr [ ] , int l , int h , int key ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int search ( int arr [ ] , int l , int h , int key ) {"
77,"Find the minimum element in a sorted and rotated array | C ++ program to find minimum element in a sorted and rotated array ; This condition is needed to handle the case when array is not rotated at all ; If there is only one element left ; Find mid ; Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 } ; Check if mid itself is minimum element ; Decide whether we need to go to left half or right half ; Driver program to test above functions","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }",Find the minimum element in a sorted and rotated array.,"#include <bits/stdc++.h>   using namespace std ; int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }","['int findMin ( int arr [ ] , int low , int high ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMin ( int arr [ ] , int low , int high ) {"
78,Find the minimum element in a sorted and rotated array | C ++ program to find minimum element in a sorted and rotated array contating duplicate elements . ; Function to find minimum element ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }",Find the minimum element in a sorted and rotated array.,"#include <bits/stdc++.h>   using namespace std ; int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }","['int findMin ( int arr [ ] , int low , int high ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMin ( int arr [ ] , int low , int high ) {"
80,Find the smallest and second smallest elements in an array | C ++ program to find smallest and second smallest elements ; For INT_MAX ; There should be atleast two elements ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void print2Smallest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { cout << "" ▁ Invalid ▁ Input ▁ "" ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) cout << "" There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE "" ; else cout << "" The ▁ smallest ▁ element ▁ is ▁ "" << first << "" ▁ and ▁ second ▁ "" "" Smallest ▁ element ▁ is ▁ "" << second << endl ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2Smallest ( arr , n ) ; return 0 ; }",Find the smallest and second smallest elements in an array.,"#include <bits/stdc++.h>   using namespace std ; void print2Smallest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { cout << "" ▁ Invalid ▁ Input ▁ "" ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) cout << "" There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE "" ; else cout << "" The ▁ smallest ▁ element ▁ is ▁ "" << first << "" ▁ and ▁ second ▁ "" "" Smallest ▁ element ▁ is ▁ "" << second << endl ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2Smallest ( arr , n ) ; return 0 ; }","['void print2Smallest ( int arr [ ] , int arr_size ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void print2Smallest ( int arr [ ] , int arr_size ) {"
82,"Count possible decoding of a given digit sequence with hidden characters |  ; check the first character of the string if it is ' * ' then 9 ways ; traverse the string ; If s [ i ] = = ' * ' there can be 9 possible values of * ; If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 ) ; If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 ) ; If the previous digit is * then all 15 2 - digit characters can be formed ; taking the value from previous step ; If previous character is 1 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] . ; If previous character is 2 and ith character is less than 6 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] . ; If previous character is * then it will contain the above 2 cases ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { vector < int > dp ( ( int ) s . size ( ) + 1 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ ( int ) s . size ( ) ] ; } int main ( ) { string s = ""12"" ; cout << waysOfDecoding ( s ) ; return 0 ; }",Count possible decoding of a given digit sequence with hidden characters.,"#include <bits/stdc++.h>   using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { vector < int > dp ( ( int ) s . size ( ) + 1 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ ( int ) s . size ( ) ] ; } int main ( ) { string s = ""12"" ; cout << waysOfDecoding ( s ) ; return 0 ; }","['int waysOfDecoding ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) {
83,Count ways to split array into two subsets having difference between their sum equal to K | C ++ program for the above approach ; Function to count the number of ways to divide the array into two subsets and such that the difference between their sums is equal to diff ; Store the sum of the set S1 ; Initializing the matrix ; Number of ways to get sum using 0 elements is 0 ; Number of ways to get sum 0 using i elements is 1 ; Traverse the 2D array ; If the value is greater than the sum store the value of previous state ; Return the result ; Driver Code ; Given Input ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubset ( int arr [ ] , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; } int main ( ) { int diff = 1 , n = 4 ; int arr [ ] = { 1 , 1 , 2 , 3 } ; cout << countSubset ( arr , n , diff ) ; }",Count ways to split array into two subsets having difference between their sum equal to K.,"#include <bits/stdc++.h>   using namespace std ; int countSubset ( int arr [ ] , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; } int main ( ) { int diff = 1 , n = 4 ; int arr [ ] = { 1 , 1 , 2 , 3 } ; cout << countSubset ( arr , n , diff ) ; }","['int countSubset ( int arr [ ] , int n , int diff ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int countSubset ( int arr [ ] , int n , int diff ) {"
84,Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers | C ++ program for above approach ; Function to calculate probability that the sum of numbers on N throws of dice lies between A and B ; Base case ; Add the probability for all the numbers between a and b ; Driver Code ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int a , int b ) { float probability = 0.0 ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = 1.0 / 6 ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = find ( N , a , b ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }",Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers.,"#include <bits/stdc++.h>   using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int a , int b ) { float probability = 0.0 ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = 1.0 / 6 ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = find ( N , a , b ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }","['float find ( int N , int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int a , int b ) {"
86,"Subset Sum Problem in O ( sum ) space | Returns true if there exists a subset with given sum in arr [ ] ; Returns true if there exists a subset with given sum in arr [ ] ; The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ] ; A subset with sum 0 is always possible ; If there exists no element no sum is possible ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; } int main ( ) { int arr [ ] = { 6 , 2 , 5 } ; int sum = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSubsetSum ( arr , n , sum ) == true ) cout << "" There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ exists ▁ with ▁ given ▁ sum "" ; return 0 ; }",Subset Sum Problem in O ( sum ) space.,"#include <iostream>   using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; } int main ( ) { int arr [ ] = { 6 , 2 , 5 } ; int sum = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSubsetSum ( arr , n , sum ) == true ) cout << "" There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ exists ▁ with ▁ given ▁ sum "" ; return 0 ; }","['bool isSubsetSum ( int arr [ ] , int n , int sum ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) {"
87,Maximum equlibrium sum in an array | CPP program to find maximum equilibrium sum . ; Function to find maximum equilibrium sum . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }",Maximum equlibrium sum in an array.,"#include <bits/stdc++.h>   using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }","['int findMaxSum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMaxSum ( int arr [ ] , int n ) {"
88,Maximum equlibrium sum in an array | CPP program to find maximum equilibrium sum . ; Function to find maximum equilibrium sum . ; Array to store prefix sum . ; Array to store suffix sum . ; Variable to store maximum sum . ; Calculate prefix sum . ; Calculate suffix sum and compare it with prefix sum . Update ans accordingly . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }",Maximum equlibrium sum in an array.,"#include <bits/stdc++.h>   using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }","['int findMaxSum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMaxSum ( int arr [ ] , int n ) {"
89,Maximum equlibrium sum in an array | CPP program to find maximum equilibrium sum . ; Function to find maximum equilibrium sum . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int sum = accumulate ( arr , arr + n , 0 ) ; int prefix_sum = 0 , res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }",Maximum equlibrium sum in an array.,"#include <bits/stdc++.h>   using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int sum = accumulate ( arr , arr + n , 0 ) ; int prefix_sum = 0 , res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }","['int findMaxSum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMaxSum ( int arr [ ] , int n ) {"
90,Majority Element | C ++ program to find Majority element in an array ; Function to find Majority element in an array ; sentinels ; update maxCount if count of current element is greater ; if maxCount is greater than n / 2 return the corresponding element ; Driver code ; Function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << "" No ▁ Majority ▁ Element "" << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }",Majority Element.,"#include <bits/stdc++.h>   using namespace std ; void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << "" No ▁ Majority ▁ Element "" << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }","['void findMajority ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findMajority ( int arr [ ] , int n ) {"
91,"Majority Element | C ++ program to demonstrate insert operation in binary search tree . ; A utility function to create a new BST node ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; find the max count ; return the ( unchanged ) node pointer ; A utility function to do inorder traversal of BST ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int key ; int c = 0 ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> c = 1 ; temp -> left = temp -> right = NULL ; return temp ; } struct node * insert ( struct node * node , int key , int & ma ) { if ( node == NULL ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; } if ( key < node -> key ) node -> left = insert ( node -> left , key , ma ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key , ma ) ; else node -> c ++ ; ma = max ( ma , node -> c ) ; return node ; } void inorder ( struct node * root , int s ) { if ( root != NULL ) { inorder ( root -> left , s ) ; if ( root -> c > ( s / 2 ) ) printf ( "" % d ▁ STRNEWLINE "" , root -> key ) ; inorder ( root -> right , s ) ; } } int main ( ) { int a [ ] = { 1 , 3 , 3 , 3 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; struct node * root = NULL ; int ma = 0 ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] , ma ) ; } if ( ma > ( size / 2 ) ) inorder ( root , size ) ; else cout << "" No ▁ majority ▁ element STRNEWLINE "" ; return 0 ; }",Majority Element.,"#include <bits/stdc++.h>   using namespace std ; struct node { int key ; int c = 0 ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> c = 1 ; temp -> left = temp -> right = NULL ; return temp ; } struct node * insert ( struct node * node , int key , int & ma ) { if ( node == NULL ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; } if ( key < node -> key ) node -> left = insert ( node -> left , key , ma ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key , ma ) ; else node -> c ++ ; ma = max ( ma , node -> c ) ; return node ; } void inorder ( struct node * root , int s ) { if ( root != NULL ) { inorder ( root -> left , s ) ; if ( root -> c > ( s / 2 ) ) printf ( "" % d ▁ STRNEWLINE "" , root -> key ) ; inorder ( root -> right , s ) ; } } int main ( ) { int a [ ] = { 1 , 3 , 3 , 3 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; struct node * root = NULL ; int ma = 0 ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] , ma ) ; } if ( ma > ( size / 2 ) ) inorder ( root , size ) ; else cout << "" No ▁ majority ▁ element STRNEWLINE "" ; return 0 ; }","['void inorder ( struct node * root , int s ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; struct node { int key ; int c = 0 ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> c = 1 ; temp -> left = temp -> right = NULL ; return temp ; } struct node * insert ( struct node * node , int key , int & ma ) { if ( node == NULL ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; } if ( key < node -> key ) node -> left = insert ( node -> left , key , ma ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key , ma ) ; else node -> c ++ ; ma = max ( ma , node -> c ) ; return node ; } void inorder ( struct node * root , int s ) {"
93,Majority Element | C ++ program for finding out majority element in an array ; Driver code ; Function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int size ) { unordered_map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) m [ arr [ i ] ] ++ ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; cout << "" Majority ▁ found ▁ : - ▁ "" << i . first << endl ; break ; } } if ( count == 0 ) cout << "" No ▁ Majority ▁ element "" << endl ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }",Majority Element.,"#include <bits/stdc++.h>   using namespace std ; void findMajority ( int arr [ ] , int size ) { unordered_map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) m [ arr [ i ] ] ++ ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; cout << "" Majority ▁ found ▁ : - ▁ "" << i . first << endl ; break ; } } if ( count == 0 ) cout << "" No ▁ Majority ▁ element "" << endl ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }","['void findMajority ( int arr [ ] , int size ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findMajority ( int arr [ ] , int size ) {"
94,"Majority Element | C ++ program to find Majority element in an array ; Function to find Majority element in an array it returns - 1 if there is no majority element ; sort the array in O ( nlogn ) ; increases the count if the same element occurs otherwise starts counting new element ; sets maximum count and stores maximum occured element so far if maximum count becomes greater than n / 2 it breaks out setting the flag ; returns maximum occured element if there is no such element , returns - 1 ; Driver code ; Function calling","#include <bits/stdc++.h> NEW_LINE using namespace std ; int majorityElement ( int * arr , int n ) { sort ( arr , arr + n ) ; int count = 1 , max_ele = -1 , temp = arr [ 0 ] , ele , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : -1 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << majorityElement ( arr , n ) ; return 0 ; }",Majority Element.,"#include <bits/stdc++.h>   using namespace std ; int majorityElement ( int * arr , int n ) { sort ( arr , arr + n ) ; int count = 1 , max_ele = -1 , temp = arr [ 0 ] , ele , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : -1 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << majorityElement ( arr , n ) ; return 0 ; }","['int majorityElement ( int * arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int majorityElement ( int * arr , int n ) {"
95,"Dynamic Programming | A Dynamic Programming solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; uncomment this code to print table ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( "" % 4d "" , subset [ i ] [ j ] ) ; cout << "" STRNEWLINE "" ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ with ▁ given ▁ sum "" ; return 0 ; }",Dynamic Programming.,"#include <iostream>   using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( "" % 4d "" , subset [ i ] [ j ] ) ; cout << "" STRNEWLINE "" ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ with ▁ given ▁ sum "" ; return 0 ; }","['bool isSubsetSum ( int set [ ] , int n , int sum ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) {"
96,Dynamic Programming | CPP program for the above approach ; Taking the matrix as globally ; Check if possible subset with given sum is possible or not ; If the sum is zero it means we got our expected sum ; If the value is not - 1 it means it already call the function with the same value . it will save our from the repetition . ; if the value of a [ n - 1 ] is greater than the sum . we call for the next value ; Here we do two calls because we don ' t ▁ know ▁ which ▁ value ▁ is ▁ ▁ full - fill ▁ our ▁ criteria ▁ ▁ that ' s why we doing two calls ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int tab [ 2000 ] [ 2000 ] ; int subsetSum ( int a [ ] , int n , int sum ) { if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != -1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } } int main ( ) { memset ( tab , -1 , sizeof ( tab ) ) ; int n = 5 ; int a [ ] = { 1 , 5 , 3 , 7 , 4 } ; int sum = 12 ; if ( subsetSum ( a , n , sum ) ) { cout << "" YES "" << endl ; } else cout << "" NO "" << endl ; }",Dynamic Programming.,"#include <bits/stdc++.h>   using namespace std ; int tab [ 2000 ] [ 2000 ] ; int subsetSum ( int a [ ] , int n , int sum ) { if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != -1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } } int main ( ) { memset ( tab , -1 , sizeof ( tab ) ) ; int n = 5 ; int a [ ] = { 1 , 5 , 3 , 7 , 4 } ; int sum = 12 ; if ( subsetSum ( a , n , sum ) ) { cout << "" YES "" << endl ; } else cout << "" NO "" << endl ; }","['int subsetSum ( int a [ ] , int n , int sum ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int tab [ 2000 ] [ 2000 ] ; int subsetSum ( int a [ ] , int n , int sum ) {"
98,Find the maximum length of the prefix | C ++ implementation of the approach ; Function to return the maximum length of the required prefix ; Array to store the frequency of each element of the array ; Iterating for all the elements ; Update the frequency of the current element i . e . v ; Sorted positive values from counts array ; If current prefix satisfies the given conditions ; Return the maximum length ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Maximum_Length ( vector < int > a ) { int counts [ 11 ] = { 0 } ; int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) { counts [ a [ index ] ] += 1 ; vector < int > k ; for ( auto i : counts ) if ( i != 0 ) k . push_back ( i ) ; sort ( k . begin ( ) , k . end ( ) ) ; if ( k . size ( ) == 1 || ( k [ 0 ] == k [ k . size ( ) - 2 ] && k . back ( ) - k [ k . size ( ) - 2 ] == 1 ) || ( k [ 0 ] == 1 and k [ 1 ] == k . back ( ) ) ) ans = index ; } return ans + 1 ; } int main ( ) { vector < int > a = { 1 , 1 , 1 , 2 , 2 , 2 } ; cout << ( Maximum_Length ( a ) ) ; }",Find the maximum length of the prefix.,"#include <bits/stdc++.h>   using namespace std ; int Maximum_Length ( vector < int > a ) { int counts [ 11 ] = { 0 } ; int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) { counts [ a [ index ] ] += 1 ; vector < int > k ; for ( auto i : counts ) if ( i != 0 ) k . push_back ( i ) ; sort ( k . begin ( ) , k . end ( ) ) ; if ( k . size ( ) == 1 || ( k [ 0 ] == k [ k . size ( ) - 2 ] && k . back ( ) - k [ k . size ( ) - 2 ] == 1 ) || ( k [ 0 ] == 1 and k [ 1 ] == k . back ( ) ) ) ans = index ; } return ans + 1 ; } int main ( ) { vector < int > a = { 1 , 1 , 1 , 2 , 2 , 2 } ; cout << ( Maximum_Length ( a ) ) ; }","['int Maximum_Length ( vector < int > a ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int Maximum_Length ( vector < int > a ) {
99,Online Queries for GCD of array after divide operations | C ++ implementation of the approach ; Function to calculate gcd of onine queries ; stores the gcd of the initial array elements ; calculates the gcd ; performing online queries ; index is 1 based ; divide the array element ; calculates the current gcd ; print the gcd after each step ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_gcd_online ( int n , int m , int query [ ] [ 2 ] , int arr [ ] ) { int max_gcd = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) max_gcd = __gcd ( max_gcd , arr [ i ] ) ; for ( i = 0 ; i < m ; i ++ ) { query [ i ] [ 0 ] -- ; arr [ query [ i ] [ 0 ] ] /= query [ i ] [ 1 ] ; max_gcd = __gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ; cout << max_gcd << endl ; } } int main ( ) { int n = 3 ; int m = 3 ; int query [ m ] [ 2 ] ; int arr [ ] = { 36 , 24 , 72 } ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ; return 0 ; }",Online Queries for GCD of array after divide operations.,"#include <bits/stdc++.h>   using namespace std ; void print_gcd_online ( int n , int m , int query [ ] [ 2 ] , int arr [ ] ) { int max_gcd = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) max_gcd = __gcd ( max_gcd , arr [ i ] ) ; for ( i = 0 ; i < m ; i ++ ) { query [ i ] [ 0 ] -- ; arr [ query [ i ] [ 0 ] ] /= query [ i ] [ 1 ] ; max_gcd = __gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ; cout << max_gcd << endl ; } } int main ( ) { int n = 3 ; int m = 3 ; int query [ m ] [ 2 ] ; int arr [ ] = { 36 , 24 , 72 } ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ; return 0 ; }","['void print_gcd_online ( int n , int m , int query [ ] [ 2 ] , int arr [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void print_gcd_online ( int n , int m , int query [ ] [ 2 ] , int arr [ ] ) {"
100,"Numbers in range [ L , R ] such that the count of their divisors is both even and prime | C ++ implementation of the approach ; stores whether the number is prime or not ; stores the count of prime numbers less than or equal to the index ; create the sieve ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all the entries as true . A value in prime [ i ] will finally be false if ' i ' is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; stores the prefix sum of number of primes less than or equal to ' i ' ; Driver code ; create the sieve ; ' l ' and ' r ' are the lower and upper bounds of the range ; get the value of count ; display the count","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX + 1 ] ; int sum [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; memset ( sum , 0 , sizeof ( sum ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } } int main ( ) { SieveOfEratosthenes ( ) ; int l = 3 , r = 9 ; int c = ( sum [ r ] - sum [ l - 1 ] ) ; cout << "" Count : ▁ "" << c << endl ; return 0 ; }","Numbers in range [ L , R ] such that the count of their divisors is both even and prime.","#include <bits/stdc++.h>   using namespace std ; #define MAX  1000000   bool prime [ MAX + 1 ] ; int sum [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; memset ( sum , 0 , sizeof ( sum ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } } int main ( ) { SieveOfEratosthenes ( ) ; int l = 3 , r = 9 ; int c = ( sum [ r ] - sum [ l - 1 ] ) ; cout << "" Count : ▁ "" << c << endl ; return 0 ; }","['void SieveOfEratosthenes ( ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define MAX  1000000   bool prime [ MAX + 1 ] ; int sum [ MAX + 1 ] ; void SieveOfEratosthenes ( ) {
101,Area of a circle inscribed in a rectangle which is inscribed in a semicircle | C ++ Program to find the area of the circle inscribed within the rectangle which in turn is inscribed in a semicircle ; Function to find the area of the circle ; radius cannot be negative ; area of the circle ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }",Area of a circle inscribed in a rectangle which is inscribed in a semicircle.,"#include <bits/stdc++.h>   using namespace std ; float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }","['float area ( float r ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; float area ( float r ) {
104,Primality Test | Set 5 ( Using Lucas | CPP program to check for primality using Lucas - Lehmer series . ; Function to check whether ( 2 ^ p - 1 ) is prime or not . ; generate the number ; First number of the series ; Generate the rest ( p - 2 ) terms of the series . ; now if the ( p - 1 ) th term is 0 return true else false . ; Driver Program ; Check whether 2 ^ p - 1 is prime or not .,"#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool isPrime ( int p ) { long long checkNumber = pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; } int main ( ) { int p = 7 ; long long checkNumber = pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) cout << checkNumber << "" ▁ is ▁ Prime . "" ; else cout << checkNumber << "" ▁ is ▁ not ▁ Prime . "" ; return 0 ; }",Primality Test.,"#include <cmath>   #include <iostream>   using namespace std ; bool isPrime ( int p ) { long long checkNumber = pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; } int main ( ) { int p = 7 ; long long checkNumber = pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) cout << checkNumber << "" ▁ is ▁ Prime . "" ; else cout << checkNumber << "" ▁ is ▁ not ▁ Prime . "" ; return 0 ; }","['bool isPrime ( int p ) {', 'int main ( ) {']",#include <cmath>   #include <iostream>   using namespace std ; bool isPrime ( int p ) {
108,Program to find whether a given number is power of 2 | C ++ program for above approach ; Function which checks whether a number is a power of 2 ; base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 ) ; all other odd numbers are not powers of 2 ; recursive function call ; Driver Code ; True ; False,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; if ( powerOf2 ( m ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; }",Program to find whether a given number is power of 2.,"#include <bits/stdc++.h>   using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; if ( powerOf2 ( m ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; }","['bool powerOf2 ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; bool powerOf2 ( int n ) {
109,Program to find whether a given number is power of 2 |  ; Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerOfTwo ( 64 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }",Program to find whether a given number is power of 2.,"#include <bits/stdc++.h>   using namespace std ; #define bool  int   bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerOfTwo ( 64 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }","['bool isPowerOfTwo ( int x ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define bool  int   bool isPowerOfTwo ( int x ) {
110,Program to find whether a given number is power of 2 |  ; Function to check if x is power of 2 ; Driver code,"#include <iostream> NEW_LINE using namespace std ; bool isPowerofTwo ( long long n ) { if ( n == 0 ) return 0 ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return 1 ; return 0 ; } int main ( ) { isPowerofTwo ( 30 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerofTwo ( 128 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }",Program to find whether a given number is power of 2.,"#include <iostream>   using namespace std ; bool isPowerofTwo ( long long n ) { if ( n == 0 ) return 0 ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return 1 ; return 0 ; } int main ( ) { isPowerofTwo ( 30 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerofTwo ( 128 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }","['bool isPowerofTwo ( long long n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; bool isPowerofTwo ( long long n ) {
112,Toggling k | CPP program to toggle k - th bit of n ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } int main ( ) { int n = 5 , k = 1 ; cout << toggleKthBit ( n , k ) ; return 0 ; }",Toggling k.,"#include <iostream>   using namespace std ; int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } int main ( ) { int n = 5 , k = 1 ; cout << toggleKthBit ( n , k ) ; return 0 ; }","['int toggleKthBit ( int n , int k ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; int toggleKthBit ( int n , int k ) {"
113,Smallest power of 2 greater than or equal to n | C ++ program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.,#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; },"['int nextPowerOf2 ( unsigned int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) {
115,Add elements in start to sort the array | Variation of Stalin Sort | C ++ implementation to sort the array by using the variation of the Stalin sort ; Function to sort the array ; Iterator < Integer > index = arr . iterator ( ) ; ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void variationStalinsort ( vector < int > arr ) { int j = 0 ; while ( true ) { int moved = 0 ; for ( int i = 0 ; i < ( arr . size ( ) - 1 - j ) ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { vector < int > :: iterator index ; int temp ; index = arr . begin ( ) + i + 1 ; temp = arr [ i + 1 ] ; arr . erase ( index ) ; arr . insert ( arr . begin ( ) + moved , temp ) ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { vector < int > arr = { 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 } ; variationStalinsort ( arr ) ; }",Add elements in start to sort the array.,"#include <bits/stdc++.h>   using namespace std ; void variationStalinsort ( vector < int > arr ) { int j = 0 ; while ( true ) { int moved = 0 ; for ( int i = 0 ; i < ( arr . size ( ) - 1 - j ) ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { vector < int > :: iterator index ; int temp ; index = arr . begin ( ) + i + 1 ; temp = arr [ i + 1 ] ; arr . erase ( index ) ; arr . insert ( arr . begin ( ) + moved , temp ) ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { vector < int > arr = { 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 } ; variationStalinsort ( arr ) ; }","['void variationStalinsort ( vector < int > arr ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void variationStalinsort ( vector < int > arr ) {
117,Maximum sum of values of N items in 0 | C ++ Program to implement the above approach ; Function to find the maximum value ; base condition ; K elements already reduced to half of their weight ; Dont include item ; If weight of the item is less than or equal to the remaining weight then include the item ; Return the maximum of both cases ; If the weight reduction to half is possible ; Skip the item ; Include item with full weight if weight of the item is less than the remaining weight ; Include item with half weight if half weight of the item is less than the remaining weight ; Return the maximum of all 3 cases ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index , int val_len ) { if ( index >= val_len ) { return 0 ; } if ( flag == K ) { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } return max ( full , skip ) ; } else { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; int half = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } if ( weight [ index ] / 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 , val_len ) ; } return max ( full , max ( skip , half ) ) ; } } int main ( ) { int value [ ] = { 17 , 20 , 10 , 15 } ; int weight [ ] = { 4 , 2 , 7 , 5 } ; int K = 1 ; int W = 4 ; int val_len = sizeof ( value ) / sizeof ( value [ 0 ] ) ; cout << ( maximum ( value , weight , W , 0 , K , 0 , val_len ) ) ; return 0 ; }",Maximum sum of values of N items in 0.,"#include <bits/stdc++.h>   using namespace std ; int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index , int val_len ) { if ( index >= val_len ) { return 0 ; } if ( flag == K ) { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } return max ( full , skip ) ; } else { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; int half = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } if ( weight [ index ] / 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 , val_len ) ; } return max ( full , max ( skip , half ) ) ; } } int main ( ) { int value [ ] = { 17 , 20 , 10 , 15 } ; int weight [ ] = { 4 , 2 , 7 , 5 } ; int K = 1 ; int W = 4 ; int val_len = sizeof ( value ) / sizeof ( value [ 0 ] ) ; cout << ( maximum ( value , weight , W , 0 , K , 0 , val_len ) ) ; return 0 ; }","['int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index , int val_len ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index , int val_len ) {"
118,d | C ++ program to find the size of the minimum dominating set of the tree ; Definition of a tree node ; Helper function that allocates a new node ; DP array to precompute and store the results ; minDominatingSettion to return the size of the minimum dominating set of the array ; Base case ; Setting the compulsory value if needed ; Check if the answer is already computed ; If it is compulsory to select the node ; Choose the node and set its children as covered ; If it is covered ; If the current node is neither covered nor needs to be selected compulsorily ; Store the result ; Driver code ; initialising the DP array ; Constructing the tree,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1005 NEW_LINE struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ( ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int dp [ N ] [ 5 ] [ 5 ] ; int minDominatingSet ( Node * root , int covered , int compulsory ) { if ( ! root ) return 0 ; if ( ! root -> left and ! root -> right and ! covered ) compulsory = true ; if ( dp [ root -> data ] [ covered ] [ compulsory ] != -1 ) return dp [ root -> data ] [ covered ] [ compulsory ] ; if ( compulsory ) { return dp [ root -> data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; } if ( covered ) { return dp [ root -> data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; if ( root -> left ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 1 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } if ( root -> right ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 1 ) ) ; } return dp [ root -> data ] [ covered ] [ compulsory ] = ans ; } signed main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 5 ) ; root -> left -> left -> left -> left = newNode ( 6 ) ; root -> left -> left -> left -> right = newNode ( 7 ) ; root -> left -> left -> left -> right -> right = newNode ( 10 ) ; root -> left -> left -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> left -> left -> right = newNode ( 9 ) ; cout << minDominatingSet ( root , 0 , 0 ) << endl ; return 0 ; }",d.,"#include <bits/stdc++.h>   using namespace std ; #define N  1005   struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ( ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int dp [ N ] [ 5 ] [ 5 ] ; int minDominatingSet ( Node * root , int covered , int compulsory ) { if ( ! root ) return 0 ; if ( ! root -> left and ! root -> right and ! covered ) compulsory = true ; if ( dp [ root -> data ] [ covered ] [ compulsory ] != -1 ) return dp [ root -> data ] [ covered ] [ compulsory ] ; if ( compulsory ) { return dp [ root -> data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; } if ( covered ) { return dp [ root -> data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; if ( root -> left ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 1 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } if ( root -> right ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 1 ) ) ; } return dp [ root -> data ] [ covered ] [ compulsory ] = ans ; } signed main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 5 ) ; root -> left -> left -> left -> left = newNode ( 6 ) ; root -> left -> left -> left -> right = newNode ( 7 ) ; root -> left -> left -> left -> right -> right = newNode ( 10 ) ; root -> left -> left -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> left -> left -> right = newNode ( 9 ) ; cout << minDominatingSet ( root , 0 , 0 ) << endl ; return 0 ; }","['int minDominatingSet ( Node * root , int covered , int compulsory ) {', 'signed main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define N  1005   struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ( ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int dp [ N ] [ 5 ] [ 5 ] ; int minDominatingSet ( Node * root , int covered , int compulsory ) {"
119,"Number of subsets with zero sum |  ; variable to store states of dp ; To find the number of subsets with sum equal to 0 Since S can be negative , we will maxSum to it to make it positive ; Base cases ; Returns the value if a state is already solved ; If the state is not visited , then continue ; Recurrence relation ; Returning the value ; Driver function","#include <bits/stdc++.h> NEW_LINE #define maxSum  100 NEW_LINE #define arrSize  51 NEW_LINE using namespace std ; int dp [ arrSize ] [ maxSum ] ; bool visit [ arrSize ] [ maxSum ] ; int SubsetCnt ( int i , int s , int arr [ ] , int n ) { if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; } if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ; visit [ i ] [ s + maxSum ] = 1 ; dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + maxSum ] ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , -4 , -4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << SubsetCnt ( 0 , 0 , arr , n ) ; }",Number of subsets with zero sum.,"#include <bits/stdc++.h>   #define maxSum  100   #define arrSize  51   using namespace std ; int dp [ arrSize ] [ maxSum ] ; bool visit [ arrSize ] [ maxSum ] ; int SubsetCnt ( int i , int s , int arr [ ] , int n ) { if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; } if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ; visit [ i ] [ s + maxSum ] = 1 ; dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + maxSum ] ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , -4 , -4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << SubsetCnt ( 0 , 0 , arr , n ) ; }","['int SubsetCnt ( int i , int s , int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   #define maxSum  100   #define arrSize  51   using namespace std ; int dp [ arrSize ] [ maxSum ] ; bool visit [ arrSize ] [ maxSum ] ; int SubsetCnt ( int i , int s , int arr [ ] , int n ) {"
121,"Tetranacci Numbers | A space optimized based CPP program to print the nth tetranacci number ; Function to print the N - th tetranacci number ; Initialize first four numbers to base cases ; declare a current variable ; Loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively ; Driver code","#include <iostream> NEW_LINE using namespace std ; void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } cout << curr ; } } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; }",Tetranacci Numbers.,"#include <iostream>   using namespace std ; void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } cout << curr ; } } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; }","['void printTetra ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; void printTetra ( int n ) {
122,"Count ways to reach the nth stair using step 1 , 2 or 3 | A C ++ program to count number of ways to reach n 't stair when ; A recursive function used by countWays ; Driver program to test above functions",#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; },"Count ways to reach the nth stair using step 1 , 2 or 3.",#include <iostream>   using namespace std ; int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; },"['int countWays ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int countWays ( int n ) {
123,"Count ways to reach the nth stair using step 1 , 2 or 3 | A C ++ program to count number of ways to reach nth stair when ; A recursive function used by countWays ; Declaring three variables and holding the ways for first three stairs ; fourth variable ; Starting from 4 as already counted for 3 stairs ; Driver program to test above functions","#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }","Count ways to reach the nth stair using step 1 , 2 or 3.","#include <iostream>   using namespace std ; int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }","['int countWays ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int countWays ( int n ) {
124,Subset Sum Problem in O ( sum ) space |  ; Initializing with 1 as sum 0 is always possible ; Loop to go through every element of the elements array ; To change the values of all possible sum values to 1 ; If sum is possible then return 1 ; Driver code,"#include <iostream> NEW_LINE using namespace std ; bool isPossible ( int elements [ ] , int sum , int n ) { int dp [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; } int main ( ) { int elements [ ] = { 6 , 2 , 5 } ; int n = sizeof ( elements ) / sizeof ( elements [ 0 ] ) ; int sum = 7 ; if ( isPossible ( elements , sum , n ) ) cout << ( "" YES "" ) ; else cout << ( "" NO "" ) ; return 0 ; }",Subset Sum Problem in O ( sum ) space.,"#include <iostream>   using namespace std ; bool isPossible ( int elements [ ] , int sum , int n ) { int dp [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; } int main ( ) { int elements [ ] = { 6 , 2 , 5 } ; int n = sizeof ( elements ) / sizeof ( elements [ 0 ] ) ; int sum = 7 ; if ( isPossible ( elements , sum , n ) ) cout << ( "" YES "" ) ; else cout << ( "" NO "" ) ; return 0 ; }","['bool isPossible ( int elements [ ] , int sum , int n ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; bool isPossible ( int elements [ ] , int sum , int n ) {"
127,Kth character after replacing each character of String by its frequency exactly X times | C ++ program for the above approach ; Function to find the Kth character after X days ; Variable to store the KthChar ; Traverse the string ; Convert char into int ; Calculate characters ; If K is less than sum than ans = str [ i ] ; Return answer ; Driver Code ; Given Input ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; char FindKthChar ( string str , long long K , int X ) { char ans ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = str [ i ] - '0' ; int range = pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; } int main ( ) { string str = ""123"" ; long long K = 9 ; int X = 3 ; char ans = FindKthChar ( str , K , X ) ; cout << ans << "" STRNEWLINE "" ; return 0 ; }",Kth character after replacing each character of String by its frequency exactly X times.,"#include <bits/stdc++.h>   using namespace std ; char FindKthChar ( string str , long long K , int X ) { char ans ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = str [ i ] - '0' ; int range = pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; } int main ( ) { string str = ""123"" ; long long K = 9 ; int X = 3 ; char ans = FindKthChar ( str , K , X ) ; cout << ans << "" STRNEWLINE "" ; return 0 ; }","['char FindKthChar ( string str , long long K , int X ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; char FindKthChar ( string str , long long K , int X ) {"
128,"Total character pairs from two strings , with equal number of set bits in their ascii value | C ++ implementation of the approach ; Function to return the count of valid pairs ; Store frequency of number of set bits for s1 ; Store frequency of number of set bits for s2 ; Calculate total pairs ; Return the count of valid pairs ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( string s1 , string s2 ) { int count = 0 ; int arr1 [ 7 ] , arr2 [ 7 ] ; for ( int i = 1 ; i <= 6 ; i ++ ) { arr1 [ i ] = 0 ; arr2 [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s1 [ i ] ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s2 [ i ] ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) count += ( arr1 [ i ] * arr2 [ i ] ) ; return count ; } int main ( ) { string s1 = "" geeks "" ; string s2 = "" forgeeks "" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }","Total character pairs from two strings , with equal number of set bits in their ascii value.","#include <bits/stdc++.h>   using namespace std ; int totalPairs ( string s1 , string s2 ) { int count = 0 ; int arr1 [ 7 ] , arr2 [ 7 ] ; for ( int i = 1 ; i <= 6 ; i ++ ) { arr1 [ i ] = 0 ; arr2 [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s1 [ i ] ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s2 [ i ] ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) count += ( arr1 [ i ] * arr2 [ i ] ) ; return count ; } int main ( ) { string s1 = "" geeks "" ; string s2 = "" forgeeks "" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }","['int totalPairs ( string s1 , string s2 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int totalPairs ( string s1 , string s2 ) {"
129,"Count substrings that starts with character X and ends with character Y | C ++ implementation to count substrings starting with character X and ending with character Y ; function to count substrings starting with character X and ending with character Y ; to store total count of required substrings ; to store count of character ' x ' up to the point the string ' str ' has been traversed so far ; traverse ' str ' form left to right ; if true , increment ' count _ x ' ; if true accumulate ' count _ x ' to ' tot _ count ' ; required count ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstr ( string str , int n , char x , char y ) { int tot_count = 0 ; int count_x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) count_x ++ ; if ( str [ i ] == y ) tot_count += count_x ; } return tot_count ; } int main ( ) { string str = "" abbcaceghcak "" ; int n = str . size ( ) ; char x = ' a ' , y = ' c ' ; cout << "" Count ▁ = ▁ "" << countSubstr ( str , n , x , y ) ; return 0 ; }",Count substrings that starts with character X and ends with character Y.,"#include <bits/stdc++.h>   using namespace std ; int countSubstr ( string str , int n , char x , char y ) { int tot_count = 0 ; int count_x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) count_x ++ ; if ( str [ i ] == y ) tot_count += count_x ; } return tot_count ; } int main ( ) { string str = "" abbcaceghcak "" ; int n = str . size ( ) ; char x = ' a ' , y = ' c ' ; cout << "" Count ▁ = ▁ "" << countSubstr ( str , n , x , y ) ; return 0 ; }","['int countSubstr ( string str , int n , char x , char y ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int countSubstr ( string str , int n , char x , char y ) {"
131,Enneadecagonal number | C ++ program to find nth Enneadecagonal number ; Function to calculate Enneadecagonal number ; Formula for finding nth Enneadecagonal number ; Drivers code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthEnneadecagonal ( long int n ) { return ( 17 * n * n - 15 * n ) / 2 ; } int main ( ) { long int n = 6 ; cout << n << "" th ▁ Enneadecagonal ▁ number ▁ : "" << nthEnneadecagonal ( n ) ; return 0 ; }",Enneadecagonal number.,"#include <bits/stdc++.h>   using namespace std ; int nthEnneadecagonal ( long int n ) { return ( 17 * n * n - 15 * n ) / 2 ; } int main ( ) { long int n = 6 ; cout << n << "" th ▁ Enneadecagonal ▁ number ▁ : "" << nthEnneadecagonal ( n ) ; return 0 ; }","['int nthEnneadecagonal ( long int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int nthEnneadecagonal ( long int n ) {
132,Area of a Circumscribed Circle of a Square | C ++ Program to find the area of a circumscribed circle ; Utiity function ; Driver code,"#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; } int main ( ) { float a = 6 ; printf ( "" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : ▁ % .2f ▁ "" , areacircumscribed ( a ) ) ; return 0 ; }",Area of a Circumscribed Circle of a Square.,"#include <stdio.h>   #define PI  3.14159265   float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; } int main ( ) { float a = 6 ; printf ( "" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : ▁ % .2f ▁ "" , areacircumscribed ( a ) ) ; return 0 ; }","['float areacircumscribed ( float a ) {', 'int main ( ) {']",#include <stdio.h>   #define PI  3.14159265   float areacircumscribed ( float a ) {
133,Find Nth item distributed from infinite items of infinite types based on given conditions | C ++ program for the above approach ; Function to find the type of the item given out according to the given rules ; Stores the count of item given out at each step ; Iterate to find the Nth day present is given out ; Find the number of presents given on day is day * ( day + 1 ) / 2 ; Iterate over the type ; Return the resultant type ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int itemType ( int n ) { int count = 0 ; int day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; },Find Nth item distributed from infinite items of infinite types based on given conditions.,#include <bits/stdc++.h>   using namespace std ; int itemType ( int n ) { int count = 0 ; int day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; },"['int itemType ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int itemType ( int n ) {
134,Check if linked list is sorted ( Iterative and Recursive ) | C ++ program to check Linked List is sorted in descending order or not ; Linked list node ; function to Check Linked List is sorted in descending order or not ; Traverse the list till last node and return false if a node is smaller than or equal its next . ; Driver program to test above,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL ) return true ; for ( Node * t = head ; t -> next != NULL ; t = t -> next ) if ( t -> data <= t -> next -> data ) return false ; return true ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Check if linked list is sorted ( Iterative and Recursive ).,"#include <bits/stdc++.h>   using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL ) return true ; for ( Node * t = head ; t -> next != NULL ; t = t -> next ) if ( t -> data <= t -> next -> data ) return false ; return true ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }","['bool isSortedDesc ( struct Node * head ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) {
136,"Minimize coins required to obtain all possible values up to N | Function to find minimum count of { 1 , 2 , 5 } valued coins required to make a change of all values in the range [ 1 , N ] ; Number of 5 valueds coins required ; Number of 1 valued coins required ; Number of 2 valued coins required ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void find ( int N ) { int T , F , O ; F = int ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = floor ( ( N - 5 * F - O ) / 2 ) ; cout << "" Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ "" << F << endl ; cout << "" Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ "" << T << endl ; cout << "" Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ "" << O << endl ; } int main ( ) { int N = 8 ; find ( N ) ; return 0 ; }",Minimize coins required to obtain all possible values up to N.,"#include <bits/stdc++.h>   using namespace std ; void find ( int N ) { int T , F , O ; F = int ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = floor ( ( N - 5 * F - O ) / 2 ) ; cout << "" Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ "" << F << endl ; cout << "" Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ "" << T << endl ; cout << "" Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ "" << O << endl ; } int main ( ) { int N = 8 ; find ( N ) ; return 0 ; }","['void find ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void find ( int N ) {
137,"Replace ' ? ' to convert given string to a binary string with maximum count of '0' and ""10"" | C ++ program to implement the above approach ; Function to maximize count of 0 and 10 by replacing character ' ? ' to '0' or '1' ; Traverse the given string ; If current character is ' ? ' ; Replace str [ i ] to '0' ; Driver Code ; Given string","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxOccurence ( string str , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ? ' ) { str [ i ] = '0' ; } } cout << str << endl ; } int main ( ) { string str = ""10?0?11"" ; int N = str . length ( ) ; findMaxOccurence ( str , N ) ; return 0 ; }","Replace ' ? ' to convert given string to a binary string with maximum count of '0' and ""10"".","#include <bits/stdc++.h>   using namespace std ; void findMaxOccurence ( string str , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ? ' ) { str [ i ] = '0' ; } } cout << str << endl ; } int main ( ) { string str = ""10?0?11"" ; int N = str . length ( ) ; findMaxOccurence ( str , N ) ; return 0 ; }","['void findMaxOccurence ( string str , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findMaxOccurence ( string str , int N ) {"
139,"Minimum change in lanes required to cross all barriers | C ++ program for the above approach ; Function to find the minimum number of changes of lane required ; If there is a barrier , then add very large value ; Add the minimum value to move forword with or without crossing barrier ; Return the minimum value of dp [ 0 ] , dp [ 1 ] and dp [ 2 ] ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) ; } int main ( ) { int barrier [ ] = { 0 , 1 , 2 , 3 , 0 } ; int N = sizeof ( barrier ) / sizeof ( barrier [ 0 ] ) ; cout << minChangeInLane ( barrier , N ) ; return 0 ; }",Minimum change in lanes required to cross all barriers.,"#include <bits/stdc++.h>   using namespace std ; int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) ; } int main ( ) { int barrier [ ] = { 0 , 1 , 2 , 3 , 0 } ; int N = sizeof ( barrier ) / sizeof ( barrier [ 0 ] ) ; cout << minChangeInLane ( barrier , N ) ; return 0 ; }","['int minChangeInLane ( int barrier [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int minChangeInLane ( int barrier [ ] , int n ) {"
140,Queries to count groups of N students possible having sum of ratings within given range | C ++ program for the above approach ; Function to count number of ways to get given sum groups ; Initialise dp array ; Mark all 1 st row values as 1 since the mat [ 0 ] [ i ] is all possible sums in first row ; Fix the ith row ; Fix the sum ; Iterate through all values of ith row ; If sum can be obtained ; Find the prefix sum of last row ; Traverse each query ; No of ways to form groups ; Driver Code ; Given n batches and k students ; Given ratings ; Given Queries ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void numWays ( int ratings [ n ] [ k ] , int queries [ ] [ 2 ] ) { int dp [ n ] [ 10000 + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int sum = 0 ; sum <= 10000 ; sum ++ ) { for ( int j = 0 ; j < k ; j ++ ) { if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } } for ( int sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; } for ( int q = 0 ; q < 2 ; q ++ ) { int a = queries [ q ] [ 0 ] ; int b = queries [ q ] [ 1 ] ; cout << dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] << "" ▁ "" ; } } int main ( ) { #define n  2 NEW_LINE #define k  3 NEW_LINE int ratings [ n ] [ k ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; int queries [ ] [ 2 ] = { { 6 , 6 } , { 1 , 6 } } ; numWays ( ratings , queries ) ; return 0 ; }",Queries to count groups of N students possible having sum of ratings within given range.,"#include <bits/stdc++.h>   using namespace std ; void numWays ( int ratings [ n ] [ k ] , int queries [ ] [ 2 ] ) { int dp [ n ] [ 10000 + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int sum = 0 ; sum <= 10000 ; sum ++ ) { for ( int j = 0 ; j < k ; j ++ ) { if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } } for ( int sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; } for ( int q = 0 ; q < 2 ; q ++ ) { int a = queries [ q ] [ 0 ] ; int b = queries [ q ] [ 1 ] ; cout << dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] << "" ▁ "" ; } } int main ( ) { #define n  2   #define k  3   int ratings [ n ] [ k ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; int queries [ ] [ 2 ] = { { 6 , 6 } , { 1 , 6 } } ; numWays ( ratings , queries ) ; return 0 ; }","['void numWays ( int ratings [ n ] [ k ] , int queries [ ] [ 2 ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void numWays ( int ratings [ n ] [ k ] , int queries [ ] [ 2 ] ) {"
141,Number of permutation with K inversions | Set 2 | C ++ program for the above approach ; Function to count permutations with K inversions ; Store number of permutations with K inversions ; If N = 1 only 1 permutation with no inversion ; For K = 0 only 1 permutation with no inversion ; Otherwise Update each dp state as per the reccurrance relation formed ; Print final count ; Driver Code ; Given N and K ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfPermWithKInversion ( int N , int K ) { int dp [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) dp [ i % 2 ] [ j ] = ( j == 0 ) ; else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; ; } } cout << dp [ N % 2 ] [ K ] ; } int main ( ) { int N = 3 , K = 2 ; numberOfPermWithKInversion ( N , K ) ; return 0 ; }",Number of permutation with K inversions.,"#include <bits/stdc++.h>   using namespace std ; int numberOfPermWithKInversion ( int N , int K ) { int dp [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) dp [ i % 2 ] [ j ] = ( j == 0 ) ; else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; ; } } cout << dp [ N % 2 ] [ K ] ; } int main ( ) { int N = 3 , K = 2 ; numberOfPermWithKInversion ( N , K ) ; return 0 ; }","['int numberOfPermWithKInversion ( int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int numberOfPermWithKInversion ( int N , int K ) {"
143,Treasure and Cities | k is current index and col is previous color . ; base case ; check if color of this city is equal to prev visited city ; return max of both options ; Driver code ; Initially begin with color 0,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }",Treasure and Cities.,"#include <bits/stdc++.h>   using namespace std ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }","['int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) {"
147,Permutation Coefficient | A O ( n ) time and O ( 1 ) extra space solution to calculate the Permutation Coefficient ; Compute n * ( n - 1 ) * ( n - 2 ) . ... ( n - k + 1 ) ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int PermutationCoeff ( int n , int k ) { int P = 1 ; for ( int i = 0 ; i < k ; i ++ ) P *= ( n - i ) ; return P ; } int main ( ) { int n = 10 , k = 2 ; cout << "" Value ▁ of ▁ P ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << PermutationCoeff ( n , k ) ; return 0 ; }",Permutation Coefficient.,"#include <iostream>   using namespace std ; int PermutationCoeff ( int n , int k ) { int P = 1 ; for ( int i = 0 ; i < k ; i ++ ) P *= ( n - i ) ; return P ; } int main ( ) { int n = 10 , k = 2 ; cout << "" Value ▁ of ▁ P ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << PermutationCoeff ( n , k ) ; return 0 ; }","['int PermutationCoeff ( int n , int k ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; int PermutationCoeff ( int n , int k ) {"
148,"Partition problem | DP | A Dynamic Programming based C ++ program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; initialize top row as true ; initialize leftmost column , except part [ 0 ] [ 0 ] , as 0 ; Fill the partition table in bottom up manner ; uncomment this part to print table ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] [ n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ sum / 2 ] [ n ] ; } int main ( ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }",Partition problem.,"#include <bits/stdc++.h>   using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] [ n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ sum / 2 ] [ n ] ; } int main ( ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }","['bool findPartiion ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool findPartiion ( int arr [ ] , int n ) {"
149,Minimum number of Appends of X or Y characters from the end to the front required to obtain given string | C ++ program for the above approach ; Function to find the minimum operations required to get the given string after appending m or n characters from the end to the front of the string in each operation ; Store the original string ; Stores the count of operations ; Traverse the string ; Cut m letters from end ; Add cut m letters to beginning ; Update j ; Check if strings are the same ; Cut n letters from end ; Add cut n letters to beginning ; Update j ; Check if strings are the same ; Update the turn ; Driver Code ; Given string S ; Function Call,"#include <iostream> NEW_LINE using namespace std ; int minimumOperations ( string orig_str , int m , int n ) { string orig = orig_str ; int turn = 1 ; int j = 1 ; for ( auto i : orig_str ) { string m_cut = orig_str . substr ( orig_str . length ( ) - m ) ; orig_str . erase ( orig_str . length ( ) - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( orig != orig_str ) { turn = turn + 1 ; string n_cut = orig_str . substr ( orig_str . length ( ) - n ) ; orig_str . erase ( orig_str . length ( ) - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig == orig_str ) { break ; } turn = turn + 1 ; } cout << turn ; } int main ( ) { string S = "" GeeksforGeeks "" ; int X = 5 , Y = 3 ; minimumOperations ( S , X , Y ) ; return 0 ; }",Minimum number of Appends of X or Y characters from the end to the front required to obtain given string.,"#include <iostream>   using namespace std ; int minimumOperations ( string orig_str , int m , int n ) { string orig = orig_str ; int turn = 1 ; int j = 1 ; for ( auto i : orig_str ) { string m_cut = orig_str . substr ( orig_str . length ( ) - m ) ; orig_str . erase ( orig_str . length ( ) - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( orig != orig_str ) { turn = turn + 1 ; string n_cut = orig_str . substr ( orig_str . length ( ) - n ) ; orig_str . erase ( orig_str . length ( ) - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig == orig_str ) { break ; } turn = turn + 1 ; } cout << turn ; } int main ( ) { string S = "" GeeksforGeeks "" ; int X = 5 , Y = 3 ; minimumOperations ( S , X , Y ) ; return 0 ; }","['int minimumOperations ( string orig_str , int m , int n ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; int minimumOperations ( string orig_str , int m , int n ) {"
154,Print characters having even frequencies in order of occurrence | C ++ implementation of the approach ; Function to print the even frequency characters in the order of their occurrence ; To store the frequency of each of the character of the string ; Initialize all elements of freq [ ] to 0 ; Update the frequency of each character ; Traverse str character by character ; If frequency of current character is even ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { cout << str [ i ] ; } } } int main ( ) { string str = "" geeksforgeeks "" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }",Print characters having even frequencies in order of occurrence.,"#include <bits/stdc++.h>   using namespace std ; #define SIZE  26   void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { cout << str [ i ] ; } } } int main ( ) { string str = "" geeksforgeeks "" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }","['void printChar ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define SIZE  26   void printChar ( string str , int n ) {"
156,Queries to print the character that occurs the maximum number of times in a given range | C ++ program to find the sum of the addition of all possible subsets . ; Function that answers all the queries ; Length of the string ; Number of queries ; Prefix array ; Iterate for all the characters ; Increase the count of the character ; Presum array for all 26 characters ; Update the prefix array ; Answer every query ; Range ; Iterate for all characters ; Times the lowercase character j occurs till r - th index ; Subtract the times it occurred till ( l - 1 ) th index ; Max times it occurs ; Print the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void solveQueries ( string str , vector < vector < int > > & query ) { int len = str . size ( ) ; int Q = query . size ( ) ; int pre [ len ] [ 26 ] ; memset ( pre , 0 , sizeof pre ) ; for ( int i = 0 ; i < len ; i ++ ) { pre [ i ] [ str [ i ] - ' a ' ] ++ ; if ( i ) { for ( int j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } } for ( int i = 0 ; i < Q ; i ++ ) { int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int maxi = 0 ; char c = ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { int times = pre [ r ] [ j ] ; if ( l ) times -= pre [ l - 1 ] [ j ] ; if ( times > maxi ) { maxi = times ; c = char ( ' a ' + j ) ; } } cout << "" Query ▁ "" << i + 1 << "" : ▁ "" << c << endl ; } } int main ( ) { string str = "" striver "" ; vector < vector < int > > query ; query . push_back ( { 0 , 1 } ) ; query . push_back ( { 1 , 6 } ) ; query . push_back ( { 5 , 6 } ) ; solveQueries ( str , query ) ; }",Queries to print the character that occurs the maximum number of times in a given range.,"#include <bits/stdc++.h>   using namespace std ; void solveQueries ( string str , vector < vector < int > > & query ) { int len = str . size ( ) ; int Q = query . size ( ) ; int pre [ len ] [ 26 ] ; memset ( pre , 0 , sizeof pre ) ; for ( int i = 0 ; i < len ; i ++ ) { pre [ i ] [ str [ i ] - ' a ' ] ++ ; if ( i ) { for ( int j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } } for ( int i = 0 ; i < Q ; i ++ ) { int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int maxi = 0 ; char c = ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { int times = pre [ r ] [ j ] ; if ( l ) times -= pre [ l - 1 ] [ j ] ; if ( times > maxi ) { maxi = times ; c = char ( ' a ' + j ) ; } } cout << "" Query ▁ "" << i + 1 << "" : ▁ "" << c << endl ; } } int main ( ) { string str = "" striver "" ; vector < vector < int > > query ; query . push_back ( { 0 , 1 } ) ; query . push_back ( { 1 , 6 } ) ; query . push_back ( { 5 , 6 } ) ; solveQueries ( str , query ) ; }","['void solveQueries ( string str , vector < vector < int > > & query ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void solveQueries ( string str , vector < vector < int > > & query ) {"
158,Print characters having odd frequencies in order of occurrence | C ++ implementation of the approach ; Function to print the odd frequency characters in the order of their occurrence ; To store the frequency of each of the character of the string ; Initialize all elements of freq [ ] to 0 ; Update the frequency of each character ; Traverse str character by character ; If frequency of current character is odd ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { cout << str [ i ] ; } } } int main ( ) { string str = "" geeksforgeeks "" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }",Print characters having odd frequencies in order of occurrence.,"#include <bits/stdc++.h>   using namespace std ; #define SIZE  26   void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { cout << str [ i ] ; } } } int main ( ) { string str = "" geeksforgeeks "" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }","['void printChar ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define SIZE  26   void printChar ( string str , int n ) {"
159,Minimum number of operations to move all uppercase characters before all lower case characters | C ++ implementation of the approach ; Function to return the minimum number of operations required ; To store the indices of the last uppercase and the first lowercase character ; Find the last uppercase character ; Find the first lowercase character ; If all the characters are either uppercase or lowercase ; Count of uppercase characters that appear after the first lowercase character ; Count of lowercase characters that appear before the last uppercase character ; Return the minimum operations required ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string str , int n ) { int i , lastUpper = -1 , firstLower = -1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == -1 firstLower == -1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return min ( countLower , countUpper ) ; } int main ( ) { string str = "" geEksFOrGEekS "" ; int n = str . length ( ) ; cout << minOperations ( str , n ) << endl ; }",Minimum number of operations to move all uppercase characters before all lower case characters.,"#include <bits/stdc++.h>   using namespace std ; int minOperations ( string str , int n ) { int i , lastUpper = -1 , firstLower = -1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == -1 firstLower == -1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return min ( countLower , countUpper ) ; } int main ( ) { string str = "" geEksFOrGEekS "" ; int n = str . length ( ) ; cout << minOperations ( str , n ) << endl ; }","['int minOperations ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int minOperations ( string str , int n ) {"
160,Find the sum of all Betrothed numbers up to N | C ++ program to find the sum of the all betrothed numbers up to N ; Function to find the sum of the all betrothed numbers ; To store the betrothed numbers ; Calculate sum of number_1 's divisors  1 is always a divisor ; i = 2 because we don 't  want to include  1 as a divisor. ; Sum all betrothed numbers up to N ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int Betrothed_Sum ( int n ) { vector < int > Set ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 and number_1 <= n && number_2 <= n ) { Set . push_back ( number_1 ) ; Set . push_back ( number_2 ) ; } } } int Summ = 0 ; for ( auto i : Set ) { if ( i <= n ) Summ += i ; } return Summ ; } int main ( ) { int n = 78 ; cout << Betrothed_Sum ( n ) ; return 0 ; },Find the sum of all Betrothed numbers up to N.,#include <bits/stdc++.h>   using namespace std ; int Betrothed_Sum ( int n ) { vector < int > Set ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 and number_1 <= n && number_2 <= n ) { Set . push_back ( number_1 ) ; Set . push_back ( number_2 ) ; } } } int Summ = 0 ; for ( auto i : Set ) { if ( i <= n ) Summ += i ; } return Summ ; } int main ( ) { int n = 78 ; cout << Betrothed_Sum ( n ) ; return 0 ; },"['int Betrothed_Sum ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int Betrothed_Sum ( int n ) {
161,Probability of rain on N + 1 th day | C ++ code to find the probability of rain on n + 1 - th day when previous day 's data is given ; Function to find the probability ; count 1 ; find probability ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; } int main ( ) { int a [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << rainDayProbability ( a , n ) ; return 0 ; }",Probability of rain on N + 1 th day.,"#include <bits/stdc++.h>   using namespace std ; float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; } int main ( ) { int a [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << rainDayProbability ( a , n ) ; return 0 ; }","['float rainDayProbability ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; float rainDayProbability ( int a [ ] , int n ) {"
162,Program to find the sum of a Series 1 + 1 / 2 ^ 2 + 1 / 3 ^ 3 + â €¦ . . + 1 / n ^ n | C ++ program to calculate the following series ; Function to calculate the following series ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; } int main ( ) { int n = 3 ; double res = Series ( n ) ; cout << res ; return 0 ; }",Program to find the sum of a Series 1 + 1 / 2 ^ 2 + 1 / 3 ^ 3 + â €¦ . . + 1 / n ^ n.,"#include <bits/stdc++.h>   using namespace std ; double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; } int main ( ) { int n = 3 ; double res = Series ( n ) ; cout << res ; return 0 ; }","['double Series ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; double Series ( int n ) {
163,"Lexicographically largest string formed in minimum moves by replacing characters of given String | C ++ program for the above approach ; Function to print the lexicographically the largest string obtained in process of obtaining a string containing first N lower case english alphabtes ; Store the frequency of each character ; Traverse the string S ; Stores the characters which are not appearing in S ; Stores the index of the largest character in the array V , that need to be replaced ; Traverse the string , S ; If frequency of S [ i ] is greater than 1 or it is outside the range ; Decrement its frequency by 1 ; Update S [ i ] ; Decrement j by 1 ; Traverse the string , S ; Decrement its frequency by 1 ; Update S [ i ] ; increment l by 1 ; Return S ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; string lexicographicallyMaximum ( string S , int N ) { unordered_map < char , int > M ; for ( int i = 0 ; i < N ; ++ i ) { M [ S [ i ] ] ++ ; } vector < char > V ; for ( char i = ' a ' ; i < ( char ) ( ' a ' + min ( N , 25 ) ) ; ++ i ) { if ( M [ i ] == 0 ) { V . push_back ( i ) ; } } int j = V . size ( ) - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { if ( V [ j ] < S [ i ] ) continue ; M [ S [ i ] ] -- ; S [ i ] = V [ j ] ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { M [ S [ i ] ] -- ; S [ i ] = V [ l ] ; l ++ ; } } return S ; } int main ( ) { string S = "" abccefghh "" ; int N = S . length ( ) ; cout << lexicographicallyMaximum ( S , N ) ; return 0 ; }",Lexicographically largest string formed in minimum moves by replacing characters of given String.,"#include <bits/stdc++.h>   using namespace std ; string lexicographicallyMaximum ( string S , int N ) { unordered_map < char , int > M ; for ( int i = 0 ; i < N ; ++ i ) { M [ S [ i ] ] ++ ; } vector < char > V ; for ( char i = ' a ' ; i < ( char ) ( ' a ' + min ( N , 25 ) ) ; ++ i ) { if ( M [ i ] == 0 ) { V . push_back ( i ) ; } } int j = V . size ( ) - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { if ( V [ j ] < S [ i ] ) continue ; M [ S [ i ] ] -- ; S [ i ] = V [ j ] ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { M [ S [ i ] ] -- ; S [ i ] = V [ l ] ; l ++ ; } } return S ; } int main ( ) { string S = "" abccefghh "" ; int N = S . length ( ) ; cout << lexicographicallyMaximum ( S , N ) ; return 0 ; }","['string lexicographicallyMaximum ( string S , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; string lexicographicallyMaximum ( string S , int N ) {"
165,Count composite fibonacci numbers from given array | C ++ program to implement the above approach ; Function to find all Fibonacci numbers up to Max ; Store all Fibonacci numbers upto Max ; Stores previous element of Fibonacci sequence ; Stores previous element of Fibonacci sequence ; Insert prev into hashmap ; Insert all the Fibonacci numbers up to Max ; Insert curr into hashmap ; Stores curr into temp ; Update curr ; Update prev ; Function to find all Composite numbers up to Max ; isPrime [ i ] : Stores if i is a prime number or not ; Calculate all prime numbers up to Max using Sieve of Eratosthenes ; If P is a prime number ; Set all multiple of P as non - prime ; Update isPrime ; Function to find the numbers which is both a composite and Fibonacci number ; Stores the largest element of the array ; Traverse the array arr [ ] ; Update Max ; isPrim [ i ] check i is a prime number or not ; Stores all the Fibonacci numbers ; Traverse the array arr [ ] ; current element is not a composite number ; If current element is a Fibonacci and composite number ; Print current element ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; set < int > createhashmap ( int Max ) { set < int > hashmap ; int curr = 1 ; int prev = 0 ; hashmap . insert ( prev ) ; while ( curr <= Max ) { hashmap . insert ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; } vector < bool > SieveOfEratosthenes ( int Max ) { vector < bool > isPrime ( Max , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; } int cntFibonacciPrime ( int arr [ ] , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = max ( Max , arr [ i ] ) ; } vector < bool > isPrime = SieveOfEratosthenes ( Max ) ; set < int > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . count ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { cout << arr [ i ] << "" ▁ "" ; } } } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cntFibonacciPrime ( arr , N ) ; return 0 ; }",Count composite fibonacci numbers from given array.,"#include <bits/stdc++.h>   using namespace std ; set < int > createhashmap ( int Max ) { set < int > hashmap ; int curr = 1 ; int prev = 0 ; hashmap . insert ( prev ) ; while ( curr <= Max ) { hashmap . insert ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; } vector < bool > SieveOfEratosthenes ( int Max ) { vector < bool > isPrime ( Max , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; } int cntFibonacciPrime ( int arr [ ] , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = max ( Max , arr [ i ] ) ; } vector < bool > isPrime = SieveOfEratosthenes ( Max ) ; set < int > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . count ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { cout << arr [ i ] << "" ▁ "" ; } } } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cntFibonacciPrime ( arr , N ) ; return 0 ; }","['int cntFibonacciPrime ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; set < int > createhashmap ( int Max ) { set < int > hashmap ; int curr = 1 ; int prev = 0 ; hashmap . insert ( prev ) ; while ( curr <= Max ) { hashmap . insert ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; } vector < bool > SieveOfEratosthenes ( int Max ) { vector < bool > isPrime ( Max , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; } int cntFibonacciPrime ( int arr [ ] , int N ) {"
166,Reduce a given number to form a key by the given operations | C ++ program of the above approach ; Function to find the key of the given number ; Convert the integer to String ; Iterate the num - string to get the result ; Check if digit is even or odd ; Iterate until odd sum is obtained by adding consecutive digits ; Check if sum becomes odd ; Add the result in ans ; Assign the digit index to num string ; If the number is odd ; Iterate until odd sum is obtained by adding consecutive digits ; Check if sum becomes even ; Add the result in ans ; assign the digit index to main numstring ; Check if all digits are visited or not ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int key ( int N ) { string num = "" "" + to_string ( N ) ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . length ( ) ; j ++ ) { if ( ( num [ j ] - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num [ num . length ( ) - 1 ] - 48 ; } } int main ( ) { int N = 1667848271 ; cout << key ( N ) ; return 0 ; }",Reduce a given number to form a key by the given operations.,"#include <bits/stdc++.h>   using namespace std ; int key ( int N ) { string num = "" "" + to_string ( N ) ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . length ( ) ; j ++ ) { if ( ( num [ j ] - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num [ num . length ( ) - 1 ] - 48 ; } } int main ( ) { int N = 1667848271 ; cout << key ( N ) ; return 0 ; }","['int key ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int key ( int N ) {
167,Sentinel Linear Search | C ++ implementation of the approach ; Function to search x in the given array ; Last element of the array ; Element to be searched is placed at the last index ; Put the last element back ; Driver code,"#include <iostream> NEW_LINE using namespace std ; void sentinelSearch ( int arr [ ] , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) cout << key << "" ▁ is ▁ present ▁ at ▁ index ▁ "" << i ; else cout << "" Element ▁ Not ▁ found "" ; } int main ( ) { int arr [ ] = { 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 180 ; sentinelSearch ( arr , n , key ) ; return 0 ; }",Sentinel Linear Search.,"#include <iostream>   using namespace std ; void sentinelSearch ( int arr [ ] , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) cout << key << "" ▁ is ▁ present ▁ at ▁ index ▁ "" << i ; else cout << "" Element ▁ Not ▁ found "" ; } int main ( ) { int arr [ ] = { 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 180 ; sentinelSearch ( arr , n , key ) ; return 0 ; }","['void sentinelSearch ( int arr [ ] , int n , int key ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; void sentinelSearch ( int arr [ ] , int n , int key ) {"
168,Maximum possible middle element of the array after deleting exactly k elements | C ++ implementation of the approach ; Function to calculate maximum possible middle value of the array after deleting exactly k elements ; Initialize answer as - 1 ; Calculate range of elements that can give maximum possible middle value of the array since index of maximum possible middle value after deleting exactly k elements from array will lie in between low and high ; Find maximum element of the array in range low and high ; since indexing is 1 based so check element at index i - 1 ; Return the maximum possible middle value of the array after deleting exactly k elements from the array ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = -1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = max ( ans , arr [ i - 1 ] ) ; } return ans ; } int main ( ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; cout << maximum_middle_value ( n , k , arr ) << endl ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; cout << maximum_middle_value ( n , k , arr1 ) << endl ; return 0 ; }",Maximum possible middle element of the array after deleting exactly k elements.,"#include <bits/stdc++.h>   using namespace std ; int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = -1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = max ( ans , arr [ i - 1 ] ) ; } return ans ; } int main ( ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; cout << maximum_middle_value ( n , k , arr ) << endl ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; cout << maximum_middle_value ( n , k , arr1 ) << endl ; return 0 ; }","['int maximum_middle_value ( int n , int k , int arr [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maximum_middle_value ( int n , int k , int arr [ ] ) {"
170,Minimum number of points to be removed to get remaining points on one side of axis | CPP program to find minimum points to be moved so that all points are on same side . ; Structure to store the coordinates of a point . ; Function to find the minimum number of points ; Number of points on the left of Y - axis . ; Number of points on the right of Y - axis . ; Number of points above X - axis . ; Number of points below X - axis . ; Driver Function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; struct Point { int x , y ; } ; int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return min ( { a , b , c , d } ) ; } int main ( ) { Point p [ ] = { { 1 , 1 } , { 2 , 2 } , { -1 , -1 } , { -2 , 2 } } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << findmin ( p , n ) ; return 0 ; }",Minimum number of points to be removed to get remaining points on one side of axis.,"#include <bits/stdc++.h>   using namespace std ; typedef long long ll ; struct Point { int x , y ; } ; int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return min ( { a , b , c , d } ) ; } int main ( ) { Point p [ ] = { { 1 , 1 } , { 2 , 2 } , { -1 , -1 } , { -2 , 2 } } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << findmin ( p , n ) ; return 0 ; }","['int findmin ( Point p [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; typedef long long ll ; struct Point { int x , y ; } ; int findmin ( Point p [ ] , int n ) {"
171,Maximum number of pair reductions possible on a given triplet | C ++ program for the above approach ; Function to count the maximum number of pair reductions possible on a given triplet ; Convert them into an array ; Stores count of operations ; Sort the array ; If the first two array elements reduce to 0 ; Apply the operations ; Increment count ; Print the maximum count ; Driver Code ; Given triplet,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxOps ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; int count = 0 ; while ( 1 ) { sort ( arr , arr + 3 ) ; if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } cout << count ; } int main ( ) { int a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ; return 0 ; }",Maximum number of pair reductions possible on a given triplet.,"#include <bits/stdc++.h>   using namespace std ; void maxOps ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; int count = 0 ; while ( 1 ) { sort ( arr , arr + 3 ) ; if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } cout << count ; } int main ( ) { int a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ; return 0 ; }","['void maxOps ( int a , int b , int c ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void maxOps ( int a , int b , int c ) {"
173,Print characters and their frequencies in order of occurrence | C ++ implementation to print the character and its frequency in order of its occurrence ; function to print the character and its frequency in order of its occurrence ; size of the string ' str ' ; ' freq [ ] ' implemented as hash table ; initialize all elements of freq [ ] to 0 ; accumulate frequency of each character in ' str ' ; traverse ' str ' from left to right ; if frequency of character str [ i ] is not equal to 0 ; print the character along with its frequency ; update frequency of str [ i ] to 0 so that the same character is not printed again ; Driver program to test above,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printCharWithFreq ( string str ) { int n = str . size ( ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { cout << str [ i ] << freq [ str [ i ] - ' a ' ] << "" ▁ "" ; freq [ str [ i ] - ' a ' ] = 0 ; } } } int main ( ) { string str = "" geeksforgeeks "" ; printCharWithFreq ( str ) ; return 0 ; }",Print characters and their frequencies in order of occurrence.,"#include <bits/stdc++.h>   using namespace std ; #define SIZE  26   void printCharWithFreq ( string str ) { int n = str . size ( ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { cout << str [ i ] << freq [ str [ i ] - ' a ' ] << "" ▁ "" ; freq [ str [ i ] - ' a ' ] = 0 ; } } } int main ( ) { string str = "" geeksforgeeks "" ; printCharWithFreq ( str ) ; return 0 ; }","['void printCharWithFreq ( string str ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define SIZE  26   void printCharWithFreq ( string str ) {
178,Largest number in BST which is less than or equal to N | C ++ code to find the largest value smaller than or equal to N ; To create new BST Node ; To insert a new node in BST ; if tree is empty return new node ; if key is less then or greater then node value then recur down the tree ; return the ( unchanged ) node pointer ; function to find max value less then N ; Start from root and keep looking for larger ; If root is smaller go to right side ; If root is greater go to left side ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } void findMaxforN ( Node * root , int N ) { while ( root != NULL && root -> right != NULL ) { if ( N > root -> key && N >= root -> right -> key ) root = root -> right ; else if ( N < root -> key ) root = root -> left ; else break ; } if ( root == NULL root -> key > N ) cout << -1 ; else cout << root -> key ; } int main ( ) { int N = 50 ; Node * root = insert ( root , 5 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; findMaxforN ( root , N ) ; return 0 ; }",Largest number in BST which is less than or equal to N.,"#include <bits/stdc++.h>   using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } void findMaxforN ( Node * root , int N ) { while ( root != NULL && root -> right != NULL ) { if ( N > root -> key && N >= root -> right -> key ) root = root -> right ; else if ( N < root -> key ) root = root -> left ; else break ; } if ( root == NULL root -> key > N ) cout << -1 ; else cout << root -> key ; } int main ( ) { int N = 50 ; Node * root = insert ( root , 5 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; findMaxforN ( root , N ) ; return 0 ; }","['void findMaxforN ( Node * root , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } void findMaxforN ( Node * root , int N ) {"
185,"Check horizontal and vertical symmetry in binary matrix | C ++ program to find if a matrix is symmetric . ; Initializing as both horizontal and vertical symmetric . ; Checking for Horizontal Symmetry . We compare first row with last row , second row with second last row and so on . ; Checking each cell of a column . ; check if every cell is identical ; Checking for Vertical Symmetry . We compare first column with last column , second xolumn with second last column and so on . ; Checking each cell of a row . ; check if every cell is identical ; Driven Program","#include <bits/stdc++.h> NEW_LINE #define MAX  1000 NEW_LINE using namespace std ; void checkHV ( int arr [ ] [ MAX ] , int N , int M ) { bool horizontal = true , vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { vertical = false ; break ; } } } if ( ! horizontal && ! vertical ) cout << "" NO STRNEWLINE "" ; else if ( horizontal && ! vertical ) cout << "" HORIZONTAL STRNEWLINE "" ; else if ( vertical && ! horizontal ) cout << "" VERTICAL STRNEWLINE "" ; else cout << "" BOTH STRNEWLINE "" ; } int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; return 0 ; }",Check horizontal and vertical symmetry in binary matrix.,"#include <bits/stdc++.h>   #define MAX  1000   using namespace std ; void checkHV ( int arr [ ] [ MAX ] , int N , int M ) { bool horizontal = true , vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { vertical = false ; break ; } } } if ( ! horizontal && ! vertical ) cout << "" NO STRNEWLINE "" ; else if ( horizontal && ! vertical ) cout << "" HORIZONTAL STRNEWLINE "" ; else if ( vertical && ! horizontal ) cout << "" VERTICAL STRNEWLINE "" ; else cout << "" BOTH STRNEWLINE "" ; } int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; return 0 ; }","['void checkHV ( int arr [ ] [ MAX ] , int N , int M ) {', 'int main ( ) {']","#include <bits/stdc++.h>   #define MAX  1000   using namespace std ; void checkHV ( int arr [ ] [ MAX ] , int N , int M ) {"
187,"Program for addition of two matrices | C ++ program for addition of two matrices ; This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; cout << "" Result ▁ matrix ▁ is ▁ "" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << "" ▁ "" ; cout << endl ; } return 0 ; }",Program for addition of two matrices.,"#include <bits/stdc++.h>   using namespace std ; #define N  4   void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; cout << "" Result ▁ matrix ▁ is ▁ "" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << "" ▁ "" ; cout << endl ; } return 0 ; }","['void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define N  4   void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) {"
188,"Program for subtraction of matrices | C ++ program for subtraction of matrices ; This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; cout << "" Result ▁ matrix ▁ is ▁ "" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << "" ▁ "" ; cout << endl ; } return 0 ; }",Program for subtraction of matrices.,"#include <bits/stdc++.h>   using namespace std ; #define N  4   void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; cout << "" Result ▁ matrix ▁ is ▁ "" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << "" ▁ "" ; cout << endl ; } return 0 ; }","['void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define N  4   void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) {"
189,Find a Fixed Point ( Value equal to index ) in a given array | C ++ program to check fixed point in an array using linear search ; If no fixed point present then return - 1 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Fixed ▁ Point ▁ is ▁ "" << linearSearch ( arr , n ) ; return 0 ; }",Find a Fixed Point ( Value equal to index ) in a given array.,"#include <bits/stdc++.h>   using namespace std ; int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Fixed ▁ Point ▁ is ▁ "" << linearSearch ( arr , n ) ; return 0 ; }","['int linearSearch ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int linearSearch ( int arr [ ] , int n ) {"
190,Find a Fixed Point ( Value equal to index ) in a given array | C ++ program to check fixed point in an array using binary search ; low + ( high - low ) / 2 ; ; Return - 1 if there is no Fixed Point ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; } int main ( ) { int arr [ 10 ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Fixed ▁ Point ▁ is ▁ "" << binarySearch ( arr , 0 , n - 1 ) ; return 0 ; }",Find a Fixed Point ( Value equal to index ) in a given array.,"#include <bits/stdc++.h>   using namespace std ; int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; } int main ( ) { int arr [ 10 ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Fixed ▁ Point ▁ is ▁ "" << binarySearch ( arr , 0 , n - 1 ) ; return 0 ; }","['int binarySearch ( int arr [ ] , int low , int high ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int binarySearch ( int arr [ ] , int low , int high ) {"
191,Maximum triplet sum in array | C ++ code to find maximum triplet sum ; Initialize sum with INT_MIN ; Driven code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }",Maximum triplet sum in array.,"#include <bits/stdc++.h>   using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }","['int maxTripletSum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxTripletSum ( int arr [ ] , int n ) {"
192,Maximum triplet sum in array | C ++ code to find maximum triplet sum ; This function assumes that there are at least three elements in arr [ ] . ; sort the given array ; After sorting the array . Add last three element of the given array ; Driven code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }",Maximum triplet sum in array.,"#include <bits/stdc++.h>   using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }","['int maxTripletSum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxTripletSum ( int arr [ ] , int n ) {"
194,"Linear Search | C ++ code to linearly search x in arr [ ] . If x is present then return its location , otherwise return - 1 ; Driver code ; Function call","#include <iostream> NEW_LINE using namespace std ; int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = search ( arr , n , x ) ; ( result == -1 ) ? cout << "" Element ▁ is ▁ not ▁ present ▁ in ▁ array "" : cout << "" Element ▁ is ▁ present ▁ at ▁ index ▁ "" << result ; return 0 ; }",Linear Search.,"#include <iostream>   using namespace std ; int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = search ( arr , n , x ) ; ( result == -1 ) ? cout << "" Element ▁ is ▁ not ▁ present ▁ in ▁ array "" : cout << "" Element ▁ is ▁ present ▁ at ▁ index ▁ "" << result ; return 0 ; }","['int search ( int arr [ ] , int n , int x ) {', 'int main ( void ) {']","#include <iostream>   using namespace std ; int search ( int arr [ ] , int n , int x ) {"
195,Linear Search | C ++ program for linear search ; Run loop from 0 to right ; If search_element is found with left variable ; If search_element is found with right variable ; If element not found ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( vector < int > arr , int search_Element ) { int left = 0 ; int length = arr . size ( ) ; int position = -1 ; int right = length - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; cout << "" Element ▁ found ▁ in ▁ Array ▁ at ▁ "" << position + 1 << "" ▁ Position ▁ with ▁ "" << left + 1 << "" ▁ Attempt "" ; break ; } if ( arr [ right ] == search_Element ) { position = right ; cout << "" Element ▁ found ▁ in ▁ Array ▁ at ▁ "" << position + 1 << "" ▁ Position ▁ with ▁ "" << length - right << "" ▁ Attempt "" ; break ; } left ++ ; right -- ; } if ( position == -1 ) cout << "" Not ▁ found ▁ in ▁ Array ▁ with ▁ "" << left << "" ▁ Attempt "" ; } int main ( ) { vector < int > arr { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ; search ( arr , search_element ) ; }",Linear Search.,"#include <bits/stdc++.h>   using namespace std ; void search ( vector < int > arr , int search_Element ) { int left = 0 ; int length = arr . size ( ) ; int position = -1 ; int right = length - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; cout << "" Element ▁ found ▁ in ▁ Array ▁ at ▁ "" << position + 1 << "" ▁ Position ▁ with ▁ "" << left + 1 << "" ▁ Attempt "" ; break ; } if ( arr [ right ] == search_Element ) { position = right ; cout << "" Element ▁ found ▁ in ▁ Array ▁ at ▁ "" << position + 1 << "" ▁ Position ▁ with ▁ "" << length - right << "" ▁ Attempt "" ; break ; } left ++ ; right -- ; } if ( position == -1 ) cout << "" Not ▁ found ▁ in ▁ Array ▁ with ▁ "" << left << "" ▁ Attempt "" ; } int main ( ) { vector < int > arr { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ; search ( arr , search_element ) ; }","['void search ( vector < int > arr , int search_Element ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void search ( vector < int > arr , int search_Element ) {"
196,"Counting Sort | C ++ Program for counting sort ; The main function that sort the given string arr [ ] in alphabetical order ; The output character array that will have sorted arr ; Create a count array to store count of individual characters and initialize count array as 0 ; Store count of each character ; Change count [ i ] so that count [ i ] now contains actual position of this character in output array ; Build the output character array ; Copy the output array to arr , so that arr now contains sorted characters ; Driver code","#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; #define RANGE  255 NEW_LINE void countSort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; } int main ( ) { char arr [ ] = "" geeksforgeeks "" ; countSort ( arr ) ; cout << "" Sorted ▁ character ▁ array ▁ is ▁ "" << arr ; return 0 ; }",Counting Sort.,"#include <bits/stdc++.h>   #include <string.h>   using namespace std ; #define RANGE  255   void countSort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; } int main ( ) { char arr [ ] = "" geeksforgeeks "" ; countSort ( arr ) ; cout << "" Sorted ▁ character ▁ array ▁ is ▁ "" << arr ; return 0 ; }","['void countSort ( char arr [ ] ) {', 'int main ( ) {']",#include <bits/stdc++.h>   #include <string.h>   using namespace std ; #define RANGE  255   void countSort ( char arr [ ] ) {
198,"Binomial Coefficient | DP | A naive recursive C ++ implementation ; Returns value of Binomial Coefficient C ( n , k ) ; Base Cases ; Recur ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } int main ( ) { int n = 5 , k = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << binomialCoeff ( n , k ) ; return 0 ; }",Binomial Coefficient.,"#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } int main ( ) { int n = 5 , k = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << binomialCoeff ( n , k ) ; return 0 ; }","['int binomialCoeff ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int k ) {"
199,Binomial Coefficient | DP | C ++ program for space optimized Dynamic Programming Solution of Binomial Coefficient ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 5 , k = 2 ; printf ( "" Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ "" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }",Binomial Coefficient.,"#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 5 , k = 2 ; printf ( "" Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ "" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }","['int binomialCoeff ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int k ) {"
200,Binomial Coefficient | DP | C ++ program for the above approach ; Function to find binomial coefficient ; Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007 ; for 1 / ( r ! ) part ; for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << r << "" ) ▁ is ▁ "" << binomialCoeff ( n , r ) << endl ; return 0 ; }",Binomial Coefficient.,"#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << r << "" ) ▁ is ▁ "" << binomialCoeff ( n , r ) << endl ; return 0 ; }","['int binomialCoeff ( int n , int r ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int r ) {"
201,"Partition problem | DP | A Dynamic Programming based C ++ program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; Initialze the part array as 0 ; Fill the partition table in bottom up manner ; the element to be included in the sum cannot be greater than the sum ; check if sum - arr [ i ] could be formed from a subset using elements before index i ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }",Partition problem.,"#include <bits/stdc++.h>   using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }","['bool findPartiion ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool findPartiion ( int arr [ ] , int n ) {"
202,"Dynamic Programming | A recursive solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following : ( a ) including the last element ( b ) excluding the last element ; Driver code","#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ) ; else printf ( "" No ▁ subset ▁ with ▁ given ▁ sum "" ) ; return 0 ; }",Dynamic Programming.,"#include <stdio.h>   bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ) ; else printf ( "" No ▁ subset ▁ with ▁ given ▁ sum "" ) ; return 0 ; }","['bool isSubsetSum ( int set [ ] , int n , int sum ) {', 'int main ( ) {']","#include <stdio.h>   bool isSubsetSum ( int set [ ] , int n , int sum ) {"
203,"Dynamic Programming | A Dynamic Programming solution for subset sum problem ; Returns true if there is a subset of set [ ] with sun equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in botton up manner ; print table ; Driver code","#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( "" % 4d "" , subset [ i ] [ j ] ) ; printf ( "" STRNEWLINE "" ) ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ) ; else printf ( "" No ▁ subset ▁ with ▁ given ▁ sum "" ) ; return 0 ; }",Dynamic Programming.,"#include <stdio.h>   bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( "" % 4d "" , subset [ i ] [ j ] ) ; printf ( "" STRNEWLINE "" ) ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ) ; else printf ( "" No ▁ subset ▁ with ▁ given ▁ sum "" ) ; return 0 ; }","['bool isSubsetSum ( int set [ ] , int n , int sum ) {', 'int main ( ) {']","#include <stdio.h>   bool isSubsetSum ( int set [ ] , int n , int sum ) {"
204,"How to print maximum number of A 's using given four keys | A recursive C ++ program to print maximum number of A 's using following four keys  ; A recursive function that returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; Initialize result ; TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way . ; If the breakpoint is s at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ "" << N << "" ▁ keystrokes ▁ is ▁ "" << findoptimal ( N ) << endl ; }",How to print maximum number of A 's using given four keys.,"#include <bits/stdc++.h>   using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ "" << N << "" ▁ keystrokes ▁ is ▁ "" << findoptimal ( N ) << endl ; }","['int findoptimal ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int findoptimal ( int N ) {
205,"How to print maximum number of A 's using given four keys | A Dynamic Programming based C program to find maximum number of A 's that can be printed using four keys  ; this function returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; An array to store result of subproblems ; To pick a breakpoint ; Initializing the optimal lengths array for uptil 6 input strokes . ; Solve all subproblems in bottom manner ; Initialize length of optimal string for n keystrokes ; For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way . ; if the breakpoint is at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","#include <iostream> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ "" << N << "" ▁ keystrokes ▁ is ▁ "" << findoptimal ( N ) << endl ; }",How to print maximum number of A 's using given four keys.,"#include <iostream>   using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ "" << N << "" ▁ keystrokes ▁ is ▁ "" << findoptimal ( N ) << endl ; }","['int findoptimal ( int N ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int findoptimal ( int N ) {
206,"How to print maximum number of A 's using given four keys | A Dynamic Programming based C ++ program to find maximum number of A 's that can be printed using four keys ; This function returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; An array to store result of subproblems ; To pick a breakpoint ; Initializing the optimal lengths array for uptil 6 input strokes . ; Solve all subproblems in bottom - up manner ; for any keystroke n , we will need to choose between : - 1. pressing Ctrl - V once after copying the A ' s ▁ obtained ▁ by ▁ n - 3 ▁ keystrokes . ▁ ▁ 2 . ▁ pressing ▁ Ctrl - V ▁ twice ▁ after ▁ copying ▁ the ▁ A ' s obtained by n - 4 keystrokes . 3. pressing Ctrl - V thrice after copying the A 's  obtained by n-5 keystrokes. ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) printf ( "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ % d ▁ keystrokes ▁ is ▁ % d STRNEWLINE "" , N , findoptimal ( N ) ) ; }",How to print maximum number of A 's using given four keys.,"#include <bits/stdc++.h>   using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) printf ( "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ % d ▁ keystrokes ▁ is ▁ % d STRNEWLINE "" , N , findoptimal ( N ) ) ; }","['int findoptimal ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int findoptimal ( int N ) {
207,"Write a program to calculate pow ( x , n ) | C ++ program to calculate pow ( x , n ) ; Function to calculate x raised to the power y ; Driver code","#include <iostream> NEW_LINE using namespace std ; class gfg { public : int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } } ; int main ( ) { gfg g ; int x = 2 ; unsigned int y = 3 ; cout << g . power ( x , y ) ; return 0 ; }","Write a program to calculate pow ( x , n ).","#include <iostream>   using namespace std ; class gfg { public : int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } } ; int main ( ) { gfg g ; int x = 2 ; unsigned int y = 3 ; cout << g . power ( x , y ) ; return 0 ; }","['int power ( int x , unsigned int y ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; class gfg { public : int power ( int x , unsigned int y ) {"
209,"Write a program to calculate pow ( x , n ) | Extended version of power function that can work for float x and negative y ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } int main ( ) { float x = 2 ; int y = -3 ; cout << power ( x , y ) ; return 0 ; }","Write a program to calculate pow ( x , n ).","#include <bits/stdc++.h>   using namespace std ; float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } int main ( ) { float x = 2 ; int y = -3 ; cout << power ( x , y ) ; return 0 ; }","['float power ( float x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; float power ( float x , int y ) {"
210,"Write a program to calculate pow ( x , n ) | C ++ program for the above approach ; If x ^ 0 return 1 ; If we need to find of 0 ^ y ; For all other cases ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }","Write a program to calculate pow ( x , n ).","#include <bits/stdc++.h>   using namespace std ; int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }","['int power ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int power ( int x , int y ) {"
211,"Write a program to calculate pow ( x , n ) | C ++ program for the above approach ; return type of pow ( ) function is double ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { return ( int ) pow ( x , y ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }","Write a program to calculate pow ( x , n ).","#include <bits/stdc++.h>   using namespace std ; int power ( int x , int y ) { return ( int ) pow ( x , y ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }","['int power ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int power ( int x , int y ) {"
212,Babylonian method for square root |  ; Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e decides the accuracy level ; Driver program to test above function,"#include <iostream> NEW_LINE using namespace std ; class gfg { public : float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } } ; int main ( ) { gfg g ; int n = 50 ; cout << "" Square ▁ root ▁ of ▁ "" << n << "" ▁ is ▁ "" << g . squareRoot ( n ) ; getchar ( ) ; }",Babylonian method for square root.,"#include <iostream>   using namespace std ; class gfg { public : float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } } ; int main ( ) { gfg g ; int n = 50 ; cout << "" Square ▁ root ▁ of ▁ "" << n << "" ▁ is ▁ "" << g . squareRoot ( n ) ; getchar ( ) ; }","['float squareRoot ( float n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; class gfg { public : float squareRoot ( float n ) {
215,"Space and time efficient Binomial Coefficient | Program to calculate C ( n , k ) ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ] ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 8 , k = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << binomialCoeff ( n , k ) ; return 0 ; }",Space and time efficient Binomial Coefficient.,"#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 8 , k = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << binomialCoeff ( n , k ) ; return 0 ; }","['int binomialCoeff ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int k ) {"
216,"Efficient program to print all prime factors of a given number | C ++ program to print all prime factors ; A function to print all prime factors of a given number n ; Print the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void primeFactors ( int n ) { while ( n % 2 == 0 ) { cout << 2 << "" ▁ "" ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { cout << i << "" ▁ "" ; n = n / i ; } } if ( n > 2 ) cout << n << "" ▁ "" ; } int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }",Efficient program to print all prime factors of a given number.,"#include <bits/stdc++.h>   using namespace std ; void primeFactors ( int n ) { while ( n % 2 == 0 ) { cout << 2 << "" ▁ "" ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { cout << i << "" ▁ "" ; n = n / i ; } } if ( n > 2 ) cout << n << "" ▁ "" ; } int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }","['void primeFactors ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void primeFactors ( int n ) {
219,"Count all possible groups of size 2 or 3 that have sum as multiple of 3 | C ++ Program to count all possible groups of size 2 or 3 that have sum as multiple of 3 ; Returns count of all possible groups that can be formed from elements of a [ ] . ; Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i ; To store the result ; Count elements with remainder 0 , 1 and 2 ; Case 3. a : Count groups of size 2 from 0 remainder elements ; Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder ; Case 4. a : Count groups of size 3 with all 0 remainder elements ; Case 4. b : Count groups of size 3 with all 1 remainder elements ; Case 4. c : Count groups of size 3 with all 2 remainder elements ; Case 4. c : Count groups of size 3 with different remainders ; Return total count stored in res ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Required ▁ number ▁ of ▁ groups ▁ are ▁ "" << findgroups ( arr , n ) << endl ; return 0 ; }",Count all possible groups of size 2 or 3 that have sum as multiple of 3.,"#include <bits/stdc++.h>   using namespace std ; int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Required ▁ number ▁ of ▁ groups ▁ are ▁ "" << findgroups ( arr , n ) << endl ; return 0 ; }","['int findgroups ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findgroups ( int arr [ ] , int n ) {"
220,Smallest power of 2 greater than or equal to n | C ++ program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.,#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; },"['int nextPowerOf2 ( unsigned int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) {
221,Smallest power of 2 greater than or equal to n | C ++ program to find smallest power of 2 greater than or equal to n ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.,#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; },"['int nextPowerOf2 ( unsigned int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) {
222,Smallest power of 2 greater than or equal to n | C ++ program to Finds next power of two for n . If n itself is a power of two then returns n ; Finds next power of two for n . If n itself is a power of two then returns n ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.,#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; },"['int nextPowerOf2 ( unsigned int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) {
224,Segregate 0 s and 1 s in an array | C ++ program to sort a binary array in one pass ; Function to put all 0 s on left and all 1 s on right ; Initialize left and right indexes ; Increment left index while we see 0 at left ; Decrement right index while we see 1 at right ; If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ] ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << "" Array ▁ after ▁ segregation ▁ "" ; for ( i = 0 ; i < 6 ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Segregate 0 s and 1 s in an array.,"#include <bits/stdc++.h>   using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << "" Array ▁ after ▁ segregation ▁ "" ; for ( i = 0 ; i < 6 ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }","['void segregate0and1 ( int arr [ ] , int size ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void segregate0and1 ( int arr [ ] , int size ) {"
225,Segregate 0 s and 1 s in an array | C ++ program to sort a binary array in one pass ; Function to put all 0 s on left and all 1 s on right ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << "" Array ▁ after ▁ segregation ▁ is ▁ "" ; for ( i = 0 ; i < arr_size ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Segregate 0 s and 1 s in an array.,"#include <bits/stdc++.h>   using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << "" Array ▁ after ▁ segregation ▁ is ▁ "" ; for ( i = 0 ; i < arr_size ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }","['void segregate0and1 ( int arr [ ] , int size ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void segregate0and1 ( int arr [ ] , int size ) {"
226,Distinct adjacent elements in an array | C ++ program to check if we can make neighbors distinct . ; map used to count the frequency of each element occurring in the array ; In this loop we count the frequency of element through map m . ; mx store the frequency of element which occurs most in array . ; In this loop we calculate the maximum frequency and store it in variable mx . ; By swapping we can adjust array only when the frequency of the element which occurs most is less than or equal to ( n + 1 ) / 2 . ; Driver program to test the above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void distinctAdjacentElement ( int a [ ] , int n ) { map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) m [ a [ i ] ] ++ ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( mx < m [ a [ i ] ] ) mx = m [ a [ i ] ] ; if ( mx > ( n + 1 ) / 2 ) cout << "" NO "" << endl ; else cout << "" YES "" << endl ; } int main ( ) { int a [ ] = { 7 , 7 , 7 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; distinctAdjacentElement ( a , n ) ; return 0 ; }",Distinct adjacent elements in an array.,"#include <bits/stdc++.h>   using namespace std ; void distinctAdjacentElement ( int a [ ] , int n ) { map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) m [ a [ i ] ] ++ ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( mx < m [ a [ i ] ] ) mx = m [ a [ i ] ] ; if ( mx > ( n + 1 ) / 2 ) cout << "" NO "" << endl ; else cout << "" YES "" << endl ; } int main ( ) { int a [ ] = { 7 , 7 , 7 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; distinctAdjacentElement ( a , n ) ; return 0 ; }","['void distinctAdjacentElement ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void distinctAdjacentElement ( int a [ ] , int n ) {"
227,"Given an array arr [ ] , find the maximum j | CPP program for the above approach ; For a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ] ; Driver program to test above functions","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxDiff = maxIndexDiff ( arr , n ) ; cout << "" STRNEWLINE "" << maxDiff ; return 0 ; }","Given an array arr [ ] , find the maximum j.","#include <bits/stdc++.h>   using namespace std ; int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxDiff = maxIndexDiff ( arr , n ) ; cout << "" STRNEWLINE "" << maxDiff ; return 0 ; }","['int maxIndexDiff ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxIndexDiff ( int arr [ ] , int n ) {"
229,"Given an array arr [ ] , find the maximum j | C ++ implementation of the hashmap approach ; Function to find maximum index difference ; Initilaise unordered_map ; Iterate from 0 to n - 1 ; Sort arr ; Iterate from 0 to n - 1 ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( vector < int > & arr , int n ) { unordered_map < int , vector < int > > hashmap ; for ( int i = 0 ; i < n ; i ++ ) { hashmap [ arr [ i ] ] . push_back ( i ) ; } sort ( arr . begin ( ) , arr . end ( ) ) ; int maxDiff = INT_MIN ; int temp = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap [ arr [ i ] ] [ 0 ] ) { temp = hashmap [ arr [ i ] ] [ 0 ] ; } maxDiff = max ( maxDiff , hashmap [ arr [ i ] ] [ hashmap [ arr [ i ] ] . size ( ) - 1 ] - temp ) ; } return maxDiff ; } int main ( ) { int n = 9 ; vector < int > arr { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int ans = maxIndexDiff ( arr , n ) ; cout << "" The ▁ maxIndexDiff ▁ is ▁ : ▁ "" << ans << endl ; return 1 ; }","Given an array arr [ ] , find the maximum j.","#include <bits/stdc++.h>   using namespace std ; int maxIndexDiff ( vector < int > & arr , int n ) { unordered_map < int , vector < int > > hashmap ; for ( int i = 0 ; i < n ; i ++ ) { hashmap [ arr [ i ] ] . push_back ( i ) ; } sort ( arr . begin ( ) , arr . end ( ) ) ; int maxDiff = INT_MIN ; int temp = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap [ arr [ i ] ] [ 0 ] ) { temp = hashmap [ arr [ i ] ] [ 0 ] ; } maxDiff = max ( maxDiff , hashmap [ arr [ i ] ] [ hashmap [ arr [ i ] ] . size ( ) - 1 ] - temp ) ; } return maxDiff ; } int main ( ) { int n = 9 ; vector < int > arr { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int ans = maxIndexDiff ( arr , n ) ; cout << "" The ▁ maxIndexDiff ▁ is ▁ : ▁ "" << ans << endl ; return 1 ; }","['int maxIndexDiff ( vector < int > & arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxIndexDiff ( vector < int > & arr , int n ) {"
230,Print sorted distinct elements of array | CPP program to print sorted distinct elements . ; Create a set using array elements ; Print contents of the set . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { set < int > s ( arr , arr + size ) ; for ( auto x : s ) cout << x << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , n ) ; return 0 ; }",Print sorted distinct elements of array.,"#include <bits/stdc++.h>   using namespace std ; void printRepeating ( int arr [ ] , int size ) { set < int > s ( arr , arr + size ) ; for ( auto x : s ) cout << x << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , n ) ; return 0 ; }","['void printRepeating ( int arr [ ] , int size ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void printRepeating ( int arr [ ] , int size ) {"
232,k |  ; Function to find k - th missing element ; interating over the array ; check if i - th and ( i + 1 ) - th element are not consecutive ; save their difference ; check for difference and given k ; if found ; Driver code ; Input array ; k - th missing element to be found in the array ; calling function to find missing element,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = 1 ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; } int main ( ) { int a [ ] = { 1 , 5 , 11 , 19 } ; int k = 11 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int missing = missingK ( a , k , n ) ; cout << missing << endl ; return 0 ; }",k.,"#include <bits/stdc++.h>   using namespace std ; int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = 1 ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; } int main ( ) { int a [ ] = { 1 , 5 , 11 , 19 } ; int k = 11 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int missing = missingK ( a , k , n ) ; cout << missing << endl ; return 0 ; }","['int missingK ( int a [ ] , int k , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int missingK ( int a [ ] , int k , int n ) {"
237,Minimum rotations required to get the same string | C ++ program to determine minimum number of rotations required to yield same string . ; Returns count of rotations to get the same string back . ; tmp is the concatenated string . ; substring from i index of original string size . ; if substring matches with original string then we will come out of the loop . ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int findRotations ( string str ) { string tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { string substring = tmp . substr ( i , str . size ( ) ) ; if ( str == substring ) return i ; } return n ; } int main ( ) { string str = "" abc "" ; cout << findRotations ( str ) << endl ; return 0 ; }",Minimum rotations required to get the same string.,"#include <iostream>   using namespace std ; int findRotations ( string str ) { string tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { string substring = tmp . substr ( i , str . size ( ) ) ; if ( str == substring ) return i ; } return n ; } int main ( ) { string str = "" abc "" ; cout << findRotations ( str ) << endl ; return 0 ; }","['int findRotations ( string str ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int findRotations ( string str ) {
239,Count of integral coordinates that lies inside a Square | C ++ program for the above approach ; Function to calculate the integral points inside a square ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; } int main ( ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; return 0 ; }",Count of integral coordinates that lies inside a Square.,"#include <bits/stdc++.h>   using namespace std ; void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; } int main ( ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; return 0 ; }","['void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) {"
240,Find Next number having distinct digits from the given number N | C ++ implementation to find the next distinct digits number ; Function to find the next distinct digits number ; Loop to find the distinct digits using hash array and the number of digits ; Loop to find the most significant distinct digit of the next number ; Condition to check if the number is possible with the same number of digits count ; Condition to check if the desired most siginificant distinct digit is found ; Loop to find the minimum next digit which is not present in the number ; Computation of the number ; Condition to check if the number is greater than the given number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNextNumber ( int n ) { int h [ 10 ] = { 0 } ; int i = 0 , msb = n , rem = 0 ; int next_num = -1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == -1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) cout << next_num << "" STRNEWLINE "" ; else cout << "" Not ▁ Possible ▁ STRNEWLINE "" ; } else { cout << "" Not ▁ Possible ▁ STRNEWLINE "" ; } } int main ( ) { int n = 2019 ; findNextNumber ( n ) ; return 0 ; }",Find Next number having distinct digits from the given number N.,"#include <bits/stdc++.h>   using namespace std ; void findNextNumber ( int n ) { int h [ 10 ] = { 0 } ; int i = 0 , msb = n , rem = 0 ; int next_num = -1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == -1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) cout << next_num << "" STRNEWLINE "" ; else cout << "" Not ▁ Possible ▁ STRNEWLINE "" ; } else { cout << "" Not ▁ Possible ▁ STRNEWLINE "" ; } } int main ( ) { int n = 2019 ; findNextNumber ( n ) ; return 0 ; }","['void findNextNumber ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void findNextNumber ( int n ) {
241,"Find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is equal to N | C ++ program for the above approach ; Function to find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is N ; Iterate over the range [ 0 , N7 ] ; Iterate over the range [ 0 , N5 ] ; Find the value of A ; If A is greater than or equal to 0 and divisible by 3 ; Otherwise , print - 1 ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { int A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { cout << "" A ▁ = ▁ "" << A / 3 << "" , ▁ B ▁ = ▁ "" << B << "" , ▁ C ▁ = ▁ "" << C << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 19 ; CalculateValues ( 19 ) ; return 0 ; }","Find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is equal to N.","#include <bits/stdc++.h>   using namespace std ; void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { int A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { cout << "" A ▁ = ▁ "" << A / 3 << "" , ▁ B ▁ = ▁ "" << B << "" , ▁ C ▁ = ▁ "" << C << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 19 ; CalculateValues ( 19 ) ; return 0 ; }","['void CalculateValues ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void CalculateValues ( int N ) {
242,Minimize total time taken by two persons to visit N cities such that none of them meet | C ++ program for the above approach ; Function to find the minimum time to visit all the cities such that both the person never meets ; Initialize sum as 0 ; Find the maximum element ; Traverse the array ; Increment sum by arr [ i ] ; Print maximum of 2 * T and sum ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumTime ( arr , N ) ; return 0 ; }",Minimize total time taken by two persons to visit N cities such that none of them meet.,"#include <bits/stdc++.h>   using namespace std ; void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumTime ( arr , N ) ; return 0 ; }","['void minimumTime ( int * arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void minimumTime ( int * arr , int n ) {"
243,"Lexicographically largest string possible by reversing substrings having even number of 1 s | C ++ program for the above approach ; Function to find the lexicographically maximum string by reversing substrings having even numbers of 1 s ; Store size of string ; Traverse the string ; Count the number of 1 s ; Stores the starting index ; Stores the end index ; Increment count , when 1 is encountered ; Traverse the remaining string ; Reverse the string from starting and end index ; Printing the string ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexicographicallyMax ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int beg = i ; int end = i ; if ( s [ i ] == '1' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } } reverse ( s . begin ( ) + beg , s . begin ( ) + end + 1 ) ; } cout << s << "" STRNEWLINE "" ; } int main ( ) { string S = ""0101"" ; lexicographicallyMax ( S ) ; return 0 ; }",Lexicographically largest string possible by reversing substrings having even number of 1 s.,"#include <bits/stdc++.h>   using namespace std ; void lexicographicallyMax ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int beg = i ; int end = i ; if ( s [ i ] == '1' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } } reverse ( s . begin ( ) + beg , s . begin ( ) + end + 1 ) ; } cout << s << "" STRNEWLINE "" ; } int main ( ) { string S = ""0101"" ; lexicographicallyMax ( S ) ; return 0 ; }","['void lexicographicallyMax ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void lexicographicallyMax ( string s ) {
244,Count maximum possible pairs from an array having sum K | C ++ program for the above approach ; Function to count the maximum number of pairs from given array with sum K ; Sort array in increasing order ; Stores the final result ; Initialize the left and right pointers ; Traverse array until start < end ; Decrement right by 1 ; Increment left by 1 ; Increment result and left pointer by 1 and decrement right pointer by 1 ; Print the result ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPairs ( int nums [ ] , int n , int k ) { sort ( nums , nums + n ) ; int result = 0 ; int start = 0 , end = n - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } cout << result << endl ; ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; maxPairs ( arr , n , K ) ; return 0 ; }",Count maximum possible pairs from an array having sum K.,"#include <bits/stdc++.h>   using namespace std ; void maxPairs ( int nums [ ] , int n , int k ) { sort ( nums , nums + n ) ; int result = 0 ; int start = 0 , end = n - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } cout << result << endl ; ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; maxPairs ( arr , n , K ) ; return 0 ; }","['void maxPairs ( int nums [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void maxPairs ( int nums [ ] , int n , int k ) {"
245,"Count maximum possible pairs from an array having sum K | C ++ program for the above approach ; Function to find the maximum number of pairs with a sum K such that same element can 't be used twice ; Initialize a hashm ; Store the final result ; Iterate over the array nums [ ] ; Decrement its frequency in m and increment the result by 1 ; Increment its frequency by 1 if it is already present in m . Otherwise , set its frequency to 1 ; Print the result ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; void maxPairs ( vector < int > nums , int k ) { map < int , int > m ; int result = 0 ; for ( auto i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { m [ k - i ] = m [ k - i ] + 1 ; } } cout << result ; } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 4 } ; int K = 5 ; maxPairs ( arr , K ) ; }",Count maximum possible pairs from an array having sum K.,"#include <bits/stdc++.h>   #include <string.h>   using namespace std ; void maxPairs ( vector < int > nums , int k ) { map < int , int > m ; int result = 0 ; for ( auto i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { m [ k - i ] = m [ k - i ] + 1 ; } } cout << result ; } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 4 } ; int K = 5 ; maxPairs ( arr , K ) ; }","['void maxPairs ( vector < int > nums , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   #include <string.h>   using namespace std ; void maxPairs ( vector < int > nums , int k ) {"
246,Print indices of array elements whose removal makes the sum of odd and even | C ++ program to implement the above approach ; Function to find indices of array elements whose removal makes the sum of odd and even indexed array elements equal ; Stores size of array ; Store prefix sum of odd index array elements ; Store prefix sum of even index array elements ; Update even [ 0 ] ; Traverse the given array ; Update odd [ i ] ; Update even [ i ] ; If the current index is an even number ; Update even [ i ] ; If the current index is an odd number ; Update odd [ i ] ; Check if at least one index found or not that satisfies the condition ; Store odd indices sum by removing 0 - th index ; Store even indices sum by removing 0 - th index ; If p and q are equal ; Traverse the array arr [ ] ; If i is an even number ; Update p by removing the i - th element ; Update q by removing the i - th element ; Update q by removing the i - th element ; Update p by removing the i - th element ; If odd index values sum is equal to even index values sum ; Set the find variable ; Print the current index ; If no index found ; Print not possible ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeIndicesToMakeSumEqual ( vector < int > & arr ) { int N = arr . size ( ) ; vector < int > odd ( N , 0 ) ; vector < int > even ( N , 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = 0 ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { cout << ""0 ▁ "" ; find = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = 1 ; cout << i << "" ▁ "" ; } } if ( ! find ) { cout << -1 ; } } int main ( ) { vector < int > arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; return 0 ; }",Print indices of array elements whose removal makes the sum of odd and even.,"#include <bits/stdc++.h>   using namespace std ; void removeIndicesToMakeSumEqual ( vector < int > & arr ) { int N = arr . size ( ) ; vector < int > odd ( N , 0 ) ; vector < int > even ( N , 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = 0 ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { cout << ""0 ▁ "" ; find = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = 1 ; cout << i << "" ▁ "" ; } } if ( ! find ) { cout << -1 ; } } int main ( ) { vector < int > arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; return 0 ; }","['void removeIndicesToMakeSumEqual ( vector < int > & arr ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void removeIndicesToMakeSumEqual ( vector < int > & arr ) {
248,Count subarrays having an equal count of 0 s and 1 s segregated | C ++ program for the above approach ; Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together ; Stores the count of subarrays ; If current element is different from the next array element ; Increment count ; Count the frequency of 1 s and 0 s ; Increment count ; Print the final count ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } cout << ans << "" STRNEWLINE "" ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }",Count subarrays having an equal count of 0 s and 1 s segregated.,"#include <bits/stdc++.h>   using namespace std ; void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } cout << ans << "" STRNEWLINE "" ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }","['void countSubarrays ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void countSubarrays ( int A [ ] , int N ) {"
250,Reduce string by removing outermost parenthesis from each primitive substring | C ++ program to implement the above approach ; Function to remove the outermost parentheses of every primitive substring from the given string ; Stores the resultant string ; Stores the count of opened parentheses ; Traverse the string ; If opening parenthesis is encountered and their count exceeds 0 ; Include the character ; If closing parenthesis is encountered and their count is less than count of opening parentheses ; Include the character ; Return the resultant string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOuterParentheses ( string S ) { string res ; int count = 0 ; for ( char c : S ) { if ( c == ' ( ' && count ++ > 0 ) res += c ; if ( c == ' ) ' && count -- > 1 ) res += c ; } return res ; } int main ( ) { string S = "" ( ( ) ( ) ) ( ( ) ) ( ) "" ; cout << removeOuterParentheses ( S ) ; }",Reduce string by removing outermost parenthesis from each primitive substring.,"#include <bits/stdc++.h>   using namespace std ; string removeOuterParentheses ( string S ) { string res ; int count = 0 ; for ( char c : S ) { if ( c == ' ( ' && count ++ > 0 ) res += c ; if ( c == ' ) ' && count -- > 1 ) res += c ; } return res ; } int main ( ) { string S = "" ( ( ) ( ) ) ( ( ) ) ( ) "" ; cout << removeOuterParentheses ( S ) ; }","['string removeOuterParentheses ( string S ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; string removeOuterParentheses ( string S ) {
251,Length of longest subarray with increasing contiguous elements | C ++ implementation for the above approach ; Function to find the longest subarray with increasing contiguous elements ; Stores the length of required longest subarray ; Stores the length of length of longest such subarray from ith index ; If consecutive elements are increasing and differ by 1 ; Otherwise ; Update the longest subarray obtained so far ; Return the length obtained ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = max ( maxi , cnt ) ; i = j ; } return maxi ; } int main ( ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; cout << maxiConsecutiveSubarray ( arr , N ) ; return 0 ; }",Length of longest subarray with increasing contiguous elements.,"#include <bits/stdc++.h>   using namespace std ; int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = max ( maxi , cnt ) ; i = j ; } return maxi ; } int main ( ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; cout << maxiConsecutiveSubarray ( arr , N ) ; return 0 ; }","['int maxiConsecutiveSubarray ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxiConsecutiveSubarray ( int arr [ ] , int N ) {"
254,Pair having all other given pairs lying between its minimum and maximum | C ++ program for the above approach ; Function to find the position of the pair that covers every pair in the array arr [ ] [ ] ; Stores the index of the resultant pair ; To count the occurences ; Iterate to check every pair ; Set count to 0 ; Condition to checked for overlapping of pairs ; If that pair can cover all other pairs then store its position ; If position not found ; Otherwise ; Driver Code ; Given array of pairs ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == -1 ) { cout << pos ; } else { cout << pos + 1 ; } } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }",Pair having all other given pairs lying between its minimum and maximum.,"#include <bits/stdc++.h>   using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == -1 ) { cout << pos ; } else { cout << pos + 1 ; } } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }","['void position ( int arr [ ] [ 2 ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) {"
255,"Pair having all other given pairs lying between its minimum and maximum | C ++ program for the above approach ; Function to find the position of the pair that covers every pair in the array arr [ ] [ ] ; Position to store the index ; Stores the maximum second value ; Stores the minimum first value ; Iterate over the array of pairs ; Update right maximum ; Update left minimum ; Iterate over the array of pairs ; If any pair exists with value { left , right } then store it ; Print the answer ; Driver Code ; Given array of pairs ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int right = INT_MIN ; int left = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] > right ) { right = arr [ i ] [ 1 ] ; } if ( arr [ i ] [ 0 ] < left ) { left = arr [ i ] [ 0 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] == left && arr [ i ] [ 1 ] == right ) { pos = i + 1 ; } } cout << pos << endl ; } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }",Pair having all other given pairs lying between its minimum and maximum.,"#include <bits/stdc++.h>   using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int right = INT_MIN ; int left = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] > right ) { right = arr [ i ] [ 1 ] ; } if ( arr [ i ] [ 0 ] < left ) { left = arr [ i ] [ 0 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] == left && arr [ i ] [ 1 ] == right ) { pos = i + 1 ; } } cout << pos << endl ; } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }","['void position ( int arr [ ] [ 2 ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) {"
256,Minimize count of given operations required to make two given strings permutations of each other | C ++ program to implement the above approach ; Function to minimize the count of operations to make str1 and str2 permutations of each other ; Store the frequency of each character of str1 ; Store the frequency of each character of str2 ; Traverse the freq1 [ ] and freq2 [ ] ; If frequency of character in str1 is greater than str2 ; Otherwise ; Store sum of freq1 [ ] ; Store sum of freq2 [ ] ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ; int freq1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int freq2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return max ( sum1 , sum2 ) ; } int main ( ) { string str1 = "" geeksforgeeks "" ; string str2 = "" geeksforcoder "" ; cout << ctMinEdits ( str1 , str2 ) ; }",Minimize count of given operations required to make two given strings permutations of each other.,"#include <bits/stdc++.h>   using namespace std ; int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ; int freq1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int freq2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return max ( sum1 , sum2 ) ; } int main ( ) { string str1 = "" geeksforgeeks "" ; string str2 = "" geeksforcoder "" ; cout << ctMinEdits ( str1 , str2 ) ; }","['int ctMinEdits ( string str1 , string str2 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int ctMinEdits ( string str1 , string str2 ) {"
257,"Count pairs ( i , j ) from arrays arr [ ] & brr [ ] such that arr [ i ] | C ++ program for the above approach ; Function to count the pairs such that given condition is satisfied ; Stores the sum of element at each corresponding index ; Find the sum of each index of both array ; Stores frequency of each element present in sumArr ; Initialize number of pairs ; Add possible vaid pairs ; Return Number of Pairs ; Driver Code ; Given array arr [ ] and brr [ ] ; Size of given array ; Function calling","#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int * a , int * b , int n ) { int C [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } map < int , int > freqCount ; for ( int i = 0 ; i < n ; i ++ ) { freqCount [ C [ i ] ] ++ ; } int NoOfPairs = 0 ; for ( auto x : freqCount ) { int y = x . second ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } cout << NoOfPairs ; } int main ( ) { int arr [ ] = { 1 , 4 , 20 , 3 , 10 , 5 } ; int brr [ ] = { 9 , 6 , 1 , 7 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; CountPairs ( arr , brr , N ) ; return 0 ; }","Count pairs ( i , j ) from arrays arr [ ] & brr [ ] such that arr [ i ].","#include <bits/stdc++.h>   using namespace std ; int CountPairs ( int * a , int * b , int n ) { int C [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } map < int , int > freqCount ; for ( int i = 0 ; i < n ; i ++ ) { freqCount [ C [ i ] ] ++ ; } int NoOfPairs = 0 ; for ( auto x : freqCount ) { int y = x . second ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } cout << NoOfPairs ; } int main ( ) { int arr [ ] = { 1 , 4 , 20 , 3 , 10 , 5 } ; int brr [ ] = { 9 , 6 , 1 , 7 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; CountPairs ( arr , brr , N ) ; return 0 ; }","['int CountPairs ( int * a , int * b , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int CountPairs ( int * a , int * b , int n ) {"
258,Change in Median of given array after deleting given elements | C ++ program for the above approach ; Function to find the median change after removing elements from arr2 [ ] ; To store the median ; If N is odd ; If N is even ; Find the current element in arr1 ; Erase the element ; Decrement N ; If N is odd ; If N is even ; Print the corresponding difference of median ; Driven Code ; Given arrays ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) { int N = arr1 . size ( ) ; vector < float > median ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } for ( auto & x : arr2 ) { auto it = find ( arr1 . begin ( ) , arr1 . end ( ) , x ) ; arr1 . erase ( it ) ; N -- ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { cout << median [ i + 1 ] - median [ i ] << ' ▁ ' ; } } int main ( ) { vector < int > arr1 = { 2 , 4 , 6 , 8 , 10 } ; vector < int > arr2 = { 4 , 6 } ; medianChange ( arr1 , arr2 ) ; return 0 ; }",Change in Median of given array after deleting given elements.,"#include <bits/stdc++.h>   using namespace std ; void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) { int N = arr1 . size ( ) ; vector < float > median ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } for ( auto & x : arr2 ) { auto it = find ( arr1 . begin ( ) , arr1 . end ( ) , x ) ; arr1 . erase ( it ) ; N -- ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { cout << median [ i + 1 ] - median [ i ] << ' ▁ ' ; } } int main ( ) { vector < int > arr1 = { 2 , 4 , 6 , 8 , 10 } ; vector < int > arr2 = { 4 , 6 } ; medianChange ( arr1 , arr2 ) ; return 0 ; }","['void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) {"
260,Count positions such that all elements before it are greater | C ++ Program to count positions such that all elements before it are greater ; Function to count positions such that all elements before it are greater ; Count is initially 1 for the first element ; Initial Minimum ; Traverse the array ; If current element is new minimum ; Update minimum ; Increment count ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; } int main ( ) { int a [ ] = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getPositionCount ( a , n ) ; return 0 ; }",Count positions such that all elements before it are greater.,"#include <bits/stdc++.h>   using namespace std ; int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; } int main ( ) { int a [ ] = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getPositionCount ( a , n ) ; return 0 ; }","['int getPositionCount ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int getPositionCount ( int a [ ] , int n ) {"
262,Count of triplets in an array that satisfy the given conditions | C ++ implementation of the approach ; All possible solutions of the equation 1 / a + 1 / b + 1 / c = 1 ; Function to find the triplets ; Storing indices of the elements ; Check if y can act as the middle element of triplet with the given solution of 1 / a + 1 / b + 1 / c = 1 ; Binary search to find the number of possible values of the first element ; Binary search to find the number of possible values of the third element ; Contribution to the answer would be the multiplication of the possible values for the first and the third element ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define MAX  100001 NEW_LINE #define ROW  10 NEW_LINE #define COl  3 NEW_LINE vector < int > indices [ MAX ] ; int test [ ROW ] [ COl ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ; int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push_back ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; ll z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != -1 && third != -1 ) { answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; } int main ( ) { int array [ ] = { 2 , 4 , 5 , 6 , 7 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << find_triplet ( array , n ) ; return 0 ; }",Count of triplets in an array that satisfy the given conditions.,"#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   #define MAX  100001   #define ROW  10   #define COl  3   vector < int > indices [ MAX ] ; int test [ ROW ] [ COl ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ; int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push_back ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; ll z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != -1 && third != -1 ) { answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; } int main ( ) { int array [ ] = { 2 , 4 , 5 , 6 , 7 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << find_triplet ( array , n ) ; return 0 ; }","['int find_triplet ( int array [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   #define MAX  100001   #define ROW  10   #define COl  3   vector < int > indices [ MAX ] ; int test [ ROW ] [ COl ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ; int find_triplet ( int array [ ] , int n ) {"
263,"Distinct adjacent elements in a binary array | C ++ implementation of the above approach ; if array has only one element , return 1 ; For first element compare with only next element ; For remaining elements compare with both prev and next elements ; For last element compare with only prev element ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinct ( int arr [ ] , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distinct ( arr , n ) ; return 0 ; }",Distinct adjacent elements in a binary array.,"#include <bits/stdc++.h>   using namespace std ; int distinct ( int arr [ ] , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distinct ( arr , n ) ; return 0 ; }","['int distinct ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int distinct ( int arr [ ] , int n ) {"
265,Find the Alpha Score of the Given Steps ( Using BST ) | C ++ program to implement the above approach ; Structure of a node ; Function to calculate and return the Alpha Score of the journey ; Traverse left subtree ; Calculate the alpha score of the current step ; Update alpha score of the journey ; Traverse right subtree ; Return ; Function to construct a BST from the sorted array arr [ ] ; Insert root ; Construct left subtree ; Construct right subtree ; Return root ; Driver Code ; Sort the array ; Construct BST from the sorted array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ; struct Node { Node * left , * right ; int data ; Node ( int x ) { data = x ; left = NULL ; right = NULL ; } } ; long getAlphaScore ( Node * node ) { if ( node -> left != NULL ) getAlphaScore ( node -> left ) ; sum = ( sum + node -> data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node -> right != NULL ) getAlphaScore ( node -> right ) ; return total_sum ; } Node * constructBST ( int arr [ ] , int start , int end , Node * root ) { if ( start > end ) return NULL ; int mid = ( start + end ) / 2 ; if ( root == NULL ) root = new Node ( arr [ mid ] ) ; root -> left = constructBST ( arr , start , mid - 1 , root -> left ) ; root -> right = constructBST ( arr , mid + 1 , end , root -> right ) ; return root ; } int main ( ) { int arr [ ] = { 10 , 11 , 12 } ; int length = 3 ; sort ( arr , arr + length ) ; Node * root = NULL ; root = constructBST ( arr , 0 , length - 1 , root ) ; cout << ( getAlphaScore ( root ) ) ; }",Find the Alpha Score of the Given Steps ( Using BST ).,"#include <bits/stdc++.h>   using namespace std ; static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ; struct Node { Node * left , * right ; int data ; Node ( int x ) { data = x ; left = NULL ; right = NULL ; } } ; long getAlphaScore ( Node * node ) { if ( node -> left != NULL ) getAlphaScore ( node -> left ) ; sum = ( sum + node -> data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node -> right != NULL ) getAlphaScore ( node -> right ) ; return total_sum ; } Node * constructBST ( int arr [ ] , int start , int end , Node * root ) { if ( start > end ) return NULL ; int mid = ( start + end ) / 2 ; if ( root == NULL ) root = new Node ( arr [ mid ] ) ; root -> left = constructBST ( arr , start , mid - 1 , root -> left ) ; root -> right = constructBST ( arr , mid + 1 , end , root -> right ) ; return root ; } int main ( ) { int arr [ ] = { 10 , 11 , 12 } ; int length = 3 ; sort ( arr , arr + length ) ; Node * root = NULL ; root = constructBST ( arr , 0 , length - 1 , root ) ; cout << ( getAlphaScore ( root ) ) ; }","['long getAlphaScore ( Node * node ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ; struct Node { Node * left , * right ; int data ; Node ( int x ) { data = x ; left = NULL ; right = NULL ; } } ; long getAlphaScore ( Node * node ) {"
267,Check if N rectangles of equal area can be formed from ( 4 * N ) integers | C ++ implementation of the approach ; Function to check whether we can make n rectangles of equal area ; Sort the array ; Find the area of any one rectangle ; Check whether we have two equal sides for each rectangle and that area of each rectangle formed is the same ; Update the answer to false if any condition fails ; If possible ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkRectangles ( int * arr , int n ) { bool ans = true ; sort ( arr , arr + 4 * n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if N rectangles of equal area can be formed from ( 4 * N ) integers.,"#include <bits/stdc++.h>   using namespace std ; bool checkRectangles ( int * arr , int n ) { bool ans = true ; sort ( arr , arr + 4 * n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool checkRectangles ( int * arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool checkRectangles ( int * arr , int n ) {"
268,Count of elements which are not at the correct position | C ++ implementation of the approach ; Function to return the count of elements which are not in the correct position when sorted ; To store a copy of the original array ; Copy the elements of the given array to the new array ; To store the required count ; Sort the original array ; If current element was not at the right position ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int copy_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntElements ( arr , n ) ; return 0 ; }",Count of elements which are not at the correct position.,"#include <bits/stdc++.h>   using namespace std ; int cntElements ( int arr [ ] , int n ) { int copy_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntElements ( arr , n ) ; return 0 ; }","['int cntElements ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int cntElements ( int arr [ ] , int n ) {"
269,Find k ordered pairs in array with minimum difference d | C ++ implementation of the approach ; Function to find the required pairs ; There has to be atleast 2 * k elements ; To store the pairs ; Sort the given array ; For every possible pair ; If the current pair is valid ; Insert it into the pair vector ; If k pairs are not possible ; Print the pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr [ ] , int n , int k , int d ) { if ( n < 2 * k ) { cout << -1 ; return ; } vector < pair < int , int > > pairs ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ n - k + i ] - arr [ i ] >= d ) { pair < int , int > p = make_pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . push_back ( p ) ; } } if ( pairs . size ( ) < k ) { cout << -1 ; return ; } for ( auto v : pairs ) { cout << "" ( "" << v . first << "" , ▁ "" << v . second << "" ) "" << endl ; } } int main ( ) { int arr [ ] = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; return 0 ; }",Find k ordered pairs in array with minimum difference d.,"#include <bits/stdc++.h>   using namespace std ; void findPairs ( int arr [ ] , int n , int k , int d ) { if ( n < 2 * k ) { cout << -1 ; return ; } vector < pair < int , int > > pairs ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ n - k + i ] - arr [ i ] >= d ) { pair < int , int > p = make_pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . push_back ( p ) ; } } if ( pairs . size ( ) < k ) { cout << -1 ; return ; } for ( auto v : pairs ) { cout << "" ( "" << v . first << "" , ▁ "" << v . second << "" ) "" << endl ; } } int main ( ) { int arr [ ] = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; return 0 ; }","['void findPairs ( int arr [ ] , int n , int k , int d ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findPairs ( int arr [ ] , int n , int k , int d ) {"
270,Count pairs with given sum | Set 2 | C ++ implementation of the approach ; Function to return the count of pairs from arr [ ] with the given sum ; To store the count of pairs ; Sort the given array ; Take two pointers ; If sum is greater ; If sum is lesser ; If sum is equal ; Find the frequency of arr [ i ] ; Find the frequency of arr [ j ] ; If arr [ i ] and arr [ j ] are same then remove the extra number counted ; Return the required answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j and arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i and arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , 5 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << pairs_count ( arr , n , sum ) ; return 0 ; }",Count pairs with given sum.,"#include <bits/stdc++.h>   using namespace std ; int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j and arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i and arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , 5 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << pairs_count ( arr , n , sum ) ; return 0 ; }","['int pairs_count ( int arr [ ] , int n , int sum ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int pairs_count ( int arr [ ] , int n , int sum ) {"
271,"Check if the string contains consecutive letters and each letter occurs exactly once | C ++ program to implement the above approach ; For all the characters of the string ; Find the ascii value of the character ; Check if if its a valid character , if not then return false ; Calculate sum of all the characters ascii values ; Find minimum ascii value from the string ; Find maximum ascii value from the string ; To get the previous element of the minimum ASCII value ; Take the expected sum from the above equation ; Check if the expected sum is equals to the calculated sum or not ; Driver code ; 1 st example ; 2 nd example","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str ) { int min = INT_MAX ; int max = - INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int ascii = str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; } int main ( ) { string str = "" dcef "" ; if ( check ( str ) ) cout << ( "" Yes "" ) ; else cout << ( "" No "" ) ; string str1 = "" xyza "" ; if ( check ( str1 ) ) cout << ( "" Yes "" else cout << ( "" No "" }",Check if the string contains consecutive letters and each letter occurs exactly once.,"#include <bits/stdc++.h>   using namespace std ; bool check ( string str ) { int min = INT_MAX ; int max = - INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int ascii = str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; } int main ( ) { string str = "" dcef "" ; if ( check ( str ) ) cout << ( "" Yes "" ) ; else cout << ( "" No "" ) ; string str1 = "" xyza "" ; if ( check ( str1 ) ) cout << ( "" Yes "" else cout << ( "" No "" }","['bool check ( string str ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; bool check ( string str ) {
272,"k | C ++ implementation of the above approach ; Function to find the sum of minimum of all subarrays ; Insert all the elements in a set ; Find the maximum and minimum element ; Traverse from the minimum to maximum element ; Check if "" i "" is missing ; Check if it is kth missing ; If no kth element is missing ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findKth ( int arr [ ] , int n , int k ) { unordered_set < int > missing ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) missing . insert ( arr [ i ] ) ; int maxm = * max_element ( arr , arr + n ) ; int minm = * min_element ( arr , arr + n ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( missing . find ( i ) == missing . end ( ) ) count ++ ; if ( count == k ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 2 , 10 , 9 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << findKth ( arr , n , k ) ; return 0 ; }",k.,"#include <bits/stdc++.h>   using namespace std ; int findKth ( int arr [ ] , int n , int k ) { unordered_set < int > missing ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) missing . insert ( arr [ i ] ) ; int maxm = * max_element ( arr , arr + n ) ; int minm = * min_element ( arr , arr + n ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( missing . find ( i ) == missing . end ( ) ) count ++ ; if ( count == k ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 2 , 10 , 9 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << findKth ( arr , n , k ) ; return 0 ; }","['int findKth ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findKth ( int arr [ ] , int n , int k ) {"
274,Check if linked list is sorted ( Iterative and Recursive ) | C ++ program to recursively check Linked List is sorted in descending order or not ; Linked list node ; function to Check Linked List is sorted in descending order or not ; Base cases ; Check first two nodes and recursively check remaining . ; Driver program to test above,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return true ; return ( head -> data > head -> next -> data && isSortedDesc ( head -> next ) ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Check if linked list is sorted ( Iterative and Recursive ).,"#include <bits/stdc++.h>   using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return true ; return ( head -> data > head -> next -> data && isSortedDesc ( head -> next ) ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }","['bool isSortedDesc ( struct Node * head ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) {
275,Rearrange an array to minimize sum of product of consecutive pair elements | C ++ program to sort an array such that sum of product of alternate element is minimum . ; create evenArr [ ] and oddArr [ ] ; sort main array in ascending order ; Put elements in oddArr [ ] and evenArr [ ] as per desired value . ; sort evenArr [ ] in descending order ; merge both sub - array and calculate minimum sum of product of alternate elements ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) oddArr . push_back ( arr [ i ] ) ; else evenArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) , greater < int > ( ) ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Minimum ▁ required ▁ sum ▁ = ▁ "" << minSum ( arr , n ) ; cout << "" Sorted array in required format : "" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Rearrange an array to minimize sum of product of consecutive pair elements.,"#include <bits/stdc++.h>   using namespace std ; int minSum ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) oddArr . push_back ( arr [ i ] ) ; else evenArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) , greater < int > ( ) ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Minimum ▁ required ▁ sum ▁ = ▁ "" << minSum ( arr , n ) ; cout << "" Sorted array in required format : "" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }","['int minSum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int minSum ( int arr [ ] , int n ) {"
276,Minimum time required to print given string from a circular container based on given conditions | C ++ implementation for the above approach ; Function to calculate minimum time to print all characters in the string ; Current element where the pointer is pointing ; Find index of that element ; Calculate absolute difference between pointer index and character index as clockwise distance ; Subtract clockwise time from 26 to get anti - clockwise time ; Add minimum of both times to the answer ; Add one unit time to print the character ; Print the final answer ; Driver code ; Given string word ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minTime ( string word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = word [ i ] - ' a ' ; int a = abs ( curr - k ) ; int b = 26 - abs ( curr - k ) ; ans += min ( a , b ) ; ans ++ ; curr = word [ i ] - ' a ' ; } cout << ans ; } int main ( ) { string str = "" zjpc "" ; minTime ( str ) ; return 0 ; }",Minimum time required to print given string from a circular container based on given conditions.,"#include <bits/stdc++.h>   using namespace std ; void minTime ( string word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = word [ i ] - ' a ' ; int a = abs ( curr - k ) ; int b = 26 - abs ( curr - k ) ; ans += min ( a , b ) ; ans ++ ; curr = word [ i ] - ' a ' ; } cout << ans ; } int main ( ) { string str = "" zjpc "" ; minTime ( str ) ; return 0 ; }","['void minTime ( string word ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void minTime ( string word ) {
278,Maximum number of diamonds that can be gained in K minutes | C ++ program for the above approach ; Function to find the maximum number of diamonds that can be gained in exactly K minutes ; Stores all the array elements ; Push all the elements to the priority queue ; Stores the required result ; Loop while the queue is not empty and K is positive ; Store the top element from the pq ; Pop it from the pq ; Add it to the answer ; Divide it by 2 and push it back to the pq ; Print the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDiamonds ( int A [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } int ans = 0 ; while ( ! pq . empty ( ) && K -- ) { int top = pq . top ( ) ; pq . pop ( ) ; ans += top ; top = top / 2 ; pq . push ( top ) ; } cout << ans ; } int main ( ) { int A [ ] = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maxDiamonds ( A , N , K ) ; return 0 ; }",Maximum number of diamonds that can be gained in K minutes.,"#include <bits/stdc++.h>   using namespace std ; void maxDiamonds ( int A [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } int ans = 0 ; while ( ! pq . empty ( ) && K -- ) { int top = pq . top ( ) ; pq . pop ( ) ; ans += top ; top = top / 2 ; pq . push ( top ) ; } cout << ans ; } int main ( ) { int A [ ] = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maxDiamonds ( A , N , K ) ; return 0 ; }","['void maxDiamonds ( int A [ ] , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void maxDiamonds ( int A [ ] , int N , int K ) {"
279,Minimize cost of increments or decrements such that same indexed elements become multiple of each other | C ++ program for the above approach ; Function to find the minimum cost to make A [ i ] multiple of B [ i ] or vice - versa for every array element ; Stores the minimum cost ; Traverse the array ; Case 1 : Update A [ i ] ; Case 2 : Update B [ i ] ; Add the minimum of the above two cases ; Return the resultant cost ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = min ( mod_B , B [ i ] - mod_B ) ; totalCost += min ( totalCost_A , totalCost_B ) ; } return totalCost ; } int main ( ) { int A [ ] = { 3 , 6 , 3 } ; int B [ ] = { 4 , 8 , 13 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MinimumCost ( A , B , N ) ; return 0 ; }",Minimize cost of increments or decrements such that same indexed elements become multiple of each other.,"#include <bits/stdc++.h>   using namespace std ; int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = min ( mod_B , B [ i ] - mod_B ) ; totalCost += min ( totalCost_A , totalCost_B ) ; } return totalCost ; } int main ( ) { int A [ ] = { 3 , 6 , 3 } ; int B [ ] = { 4 , 8 , 13 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MinimumCost ( A , B , N ) ; return 0 ; }","['int MinimumCost ( int A [ ] , int B [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int MinimumCost ( int A [ ] , int B [ ] , int N ) {"
281,"Rearrange array to maximize sum of GCD of array elements with their respective indices | C ++ program to implement the above approach ; Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array ; Sort the array in ascending order ; Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements ; Generate all possible permutations of the array ; Stores sum of GCD ( arr [ i ] , i ) ; Traverse the array ; Update sum ; Update res ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = max ( res , sum ) ; } while ( next_permutation ( arr , arr + N ) ) ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }",Rearrange array to maximize sum of GCD of array elements with their respective indices.,"#include <bits/stdc++.h>   using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = max ( res , sum ) ; } while ( next_permutation ( arr , arr + N ) ) ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }","['int findMaxValByRearrArr ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) {"
284,"Count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element | C ++ program for the above approach ; Function to count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element ; Stores xor of odd and even indexed elements from the end ; Stores xor of odd and even indexed elements from the start ; Stores the required count ; Traverse the array in reverse ; If i is odd ; If i is even ; Traverse the array ; If i is odd ; If i is even ; Removing arr [ i ] , post_even stores XOR of odd indexed elements ; Removing arr [ i ] , post_odd stores XOR of even indexed elements ; Check if they are equal ; If i is odd , xor it with curr_odd ; If i is even , xor it with curr_even ; Finally print res ; Drivers Code ; Given array ; Given size ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Remove_one_element ( arr , N ) ; return 0 ; }",Count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element.,"#include <bits/stdc++.h>   using namespace std ; void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Remove_one_element ( arr , N ) ; return 0 ; }","['void Remove_one_element ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void Remove_one_element ( int arr [ ] , int n ) {"
285,Count ways to make sum of odd and even indexed elements equal by removing an array element | C ++ program to implement the above approach ; Function to count array indices whose removal makes sum of odd and even indexed elements equal ; If size of the array is 1 ; If size of the array is 2 ; Stores sum of even - indexed elements of the given array ; Stores sum of odd - indexed elements of the given array ; Traverse the array ; If i is an even number ; Update sumEven ; If i is an odd number ; Update sumOdd ; Stores sum of even - indexed array elements till i - th index ; Stores sum of odd - indexed array elements till i - th index ; Stores count of indices whose removal makes sum of odd and even indexed elements equal ; Stores sum of even - indexed elements after removing the i - th element ; Stores sum of odd - indexed elements after removing the i - th element ; Traverse the array ; If i is an odd number ; Update currOdd ; Update newEvenSum ; Update newOddSum ; If i is an even number ; Update currEven ; Update newOddSum ; Update newEvenSum ; If newEvenSum is equal to newOddSum ; Increase the count ; If sum of even - indexed and odd - indexed elements is equal by removing the first element ; Increase the count ; If length of the array is an odd number ; If sum of even - indexed and odd - indexed elements is equal by removing the last element ; Increase the count ; If length of the array is an even number ; If sum of even - indexed and odd - indexed elements is equal by removing the last element ; Increase the count ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntIndexesToMakeBalance ( int arr [ ] , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntIndexesToMakeBalance ( arr , n ) ; return 0 ; }",Count ways to make sum of odd and even indexed elements equal by removing an array element.,"#include <bits/stdc++.h>   using namespace std ; int cntIndexesToMakeBalance ( int arr [ ] , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntIndexesToMakeBalance ( arr , n ) ; return 0 ; }","['int cntIndexesToMakeBalance ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int cntIndexesToMakeBalance ( int arr [ ] , int n ) {"
287,Queries to check if count of increasing and decreasing subarrays is same in given range | C ++ program for the above approach ; Function to check if given range have equal number of increasing as well as decreasing subarrays ; Traverse each query ; For 0 - based indexing ; Condition for same count of increasing & decreasing subarray ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- , R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { cout << "" Yes STRNEWLINE "" ; } else { cout << "" No STRNEWLINE "" ; } } } int main ( ) { int arr [ ] = { 11 , 13 , 12 , 14 } ; int Q [ ] [ 2 ] = { { 1 , 4 } , { 2 , 4 } } ; int q = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; checkCount ( arr , Q , q ) ; return 0 ; }",Queries to check if count of increasing and decreasing subarrays is same in given range.,"#include <bits/stdc++.h>   using namespace std ; void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- , R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { cout << "" Yes STRNEWLINE "" ; } else { cout << "" No STRNEWLINE "" ; } } } int main ( ) { int arr [ ] = { 11 , 13 , 12 , 14 } ; int Q [ ] [ 2 ] = { { 1 , 4 } , { 2 , 4 } } ; int q = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; checkCount ( arr , Q , q ) ; return 0 ; }","['void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) {"
288,Mean of array generated by products of all pairs of the given array | C ++ program for the above approach ; Function to find the mean of pair product array of arr [ ] ; Store product of pairs ; Generate all unordered pairs ; Store product of pairs ; Size of pairArray ; Store sum of pairArray ; Stores the mean of pairArray [ ] ; Find mean of pairArray [ ] ; Return the resultant mean ; Driver Code ; Given array arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { vector < int > pairArray ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . push_back ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }",Mean of array generated by products of all pairs of the given array.,"#include <bits/stdc++.h>   using namespace std ; float pairProductMean ( int arr [ ] , int N ) { vector < int > pairArray ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . push_back ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }","['float pairProductMean ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; float pairProductMean ( int arr [ ] , int N ) {"
289,Find the player who is the last to remove any character from the beginning of a Binary String | C ++ program for the above approach ; Function to find the player who loses the game ; Moves for the first player ; Moves for the second player ; Iterate over array of strings ; Check if the first and last character are the same ; Check if string start and end with character '0' ; If first player have less moves ; Driver Code ; Given array of strings ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPlayer ( string str [ ] , int n ) { int move_first = 0 ; int move_sec = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . length ( ) - 1 ] ) { if ( str [ i ] [ 0 ] == 48 ) move_first ++ ; else move_sec ++ ; } } if ( move_first <= move_sec ) { cout << "" Player ▁ 2 ▁ wins "" ; } else { cout << "" Player ▁ 1 ▁ wins "" ; } } int main ( ) { string str [ ] = { ""010"" , ""101"" } ; int N = sizeof ( str ) / sizeof ( str [ 0 ] ) ; findPlayer ( str , N ) ; return 0 ; }",Find the player who is the last to remove any character from the beginning of a Binary String.,"#include <bits/stdc++.h>   using namespace std ; void findPlayer ( string str [ ] , int n ) { int move_first = 0 ; int move_sec = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . length ( ) - 1 ] ) { if ( str [ i ] [ 0 ] == 48 ) move_first ++ ; else move_sec ++ ; } } if ( move_first <= move_sec ) { cout << "" Player ▁ 2 ▁ wins "" ; } else { cout << "" Player ▁ 1 ▁ wins "" ; } } int main ( ) { string str [ ] = { ""010"" , ""101"" } ; int N = sizeof ( str ) / sizeof ( str [ 0 ] ) ; findPlayer ( str , N ) ; return 0 ; }","['void findPlayer ( string str [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findPlayer ( string str [ ] , int n ) {"
290,Smallest number exceeding N whose Kth bit is set | C ++ program for the above approach ; Function to find the number greater than n whose Kth bit is set ; Iterate from N + 1 ; Check if Kth bit is set or not ; Increment M for next number ; Return the minimum value ; Driver Code ; Given N and K ; Function Call,"#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; int find_next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1ll << k ) ) break ; M ++ ; } return M ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }",Smallest number exceeding N whose Kth bit is set.,"#include "" bits / stdc + + . h ""   using namespace std ; int find_next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1ll << k ) ) break ; M ++ ; } return M ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }","['int find_next ( int n , int k ) {', 'int main ( ) {']","#include "" bits / stdc + + . h ""   using namespace std ; int find_next ( int n , int k ) {"
291,Smallest number exceeding N whose Kth bit is set | C ++ program for the above approach ; Function to find the number greater than n whose Kth bit is set ; Stores the resultant number ; If Kth bit is not set ; cur will be the sum of all powers of 2 < k ; If the current bit is set ; Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set ; If the kth bit is set ; First unset bit position ; sum of bits that are set ; Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set ; If Kth bit became unset then set it again ; Return the resultant number ; Driver Code ; Print ans,"#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; int find_next ( int n , int k ) { int ans = 0 ; if ( ( n & ( 1ll << k ) ) == 0 ) { int cur = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( n & ( 1ll << i ) ) cur += 1ll << i ; } ans = n - cur + ( 1ll << k ) ; } else { int first_unset_bit = -1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( n & ( 1ll << i ) ) == 0 ) { first_unset_bit = i ; break ; } else cur += ( 1ll << i ) ; } ans = n - cur + ( 1ll << first_unset_bit ) ; if ( ( ans & ( 1ll << k ) ) == 0 ) ans += ( 1ll << k ) ; } return ans ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }",Smallest number exceeding N whose Kth bit is set.,"#include "" bits / stdc + + . h ""   using namespace std ; int find_next ( int n , int k ) { int ans = 0 ; if ( ( n & ( 1ll << k ) ) == 0 ) { int cur = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( n & ( 1ll << i ) ) cur += 1ll << i ; } ans = n - cur + ( 1ll << k ) ; } else { int first_unset_bit = -1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( n & ( 1ll << i ) ) == 0 ) { first_unset_bit = i ; break ; } else cur += ( 1ll << i ) ; } ans = n - cur + ( 1ll << first_unset_bit ) ; if ( ( ans & ( 1ll << k ) ) == 0 ) ans += ( 1ll << k ) ; } return ans ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }","['int find_next ( int n , int k ) {', 'int main ( ) {']","#include "" bits / stdc + + . h ""   using namespace std ; int find_next ( int n , int k ) {"
292,Lexicographically largest possible String after removal of K characters | C ++ Program to implement the above approach ; final result string ; If the current char exceeds the character at the top of the stack ; Remove from the end of the string ; Decrease k for the removal ; Insert current character ; Perform remaining K deletions from the end of the string ; Return the string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestString ( string num , int k ) { string ans = "" "" ; for ( auto i : num ) { while ( ans . length ( ) && ans . back ( ) < i && k > 0 ) { ans . pop_back ( ) ; k -- ; } ans . push_back ( i ) ; } while ( ans . length ( ) and k -- ) { ans . pop_back ( ) ; } return ans ; } int main ( ) { string str = "" zyxedcba "" ; int k = 1 ; cout << largestString ( str , k ) << endl ; }",Lexicographically largest possible String after removal of K characters.,"#include <bits/stdc++.h>   using namespace std ; string largestString ( string num , int k ) { string ans = "" "" ; for ( auto i : num ) { while ( ans . length ( ) && ans . back ( ) < i && k > 0 ) { ans . pop_back ( ) ; k -- ; } ans . push_back ( i ) ; } while ( ans . length ( ) and k -- ) { ans . pop_back ( ) ; } return ans ; } int main ( ) { string str = "" zyxedcba "" ; int k = 1 ; cout << largestString ( str , k ) << endl ; }","['string largestString ( string num , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; string largestString ( string num , int k ) {"
293,Maximum length of subarray consisting of same type of element on both halves of sub | C ++ program for the above approach ; Function that finds the maximum length of the sub - array that contains equal element on both halves of sub - array ; To store continuous occurence of the element ; To store continuous forward occurence ; To store continuous backward occurence ; To store the maximum length ; Find maximum length ; Print the result ; Driver Code ; Given array ; Size of the array ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLengthSubArray ( int A [ ] , int N ) { int forward [ N ] , backward [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxLengthSubArray ( arr , N ) ; return 0 ; }",Maximum length of subarray consisting of same type of element on both halves of sub.,"#include <bits/stdc++.h>   using namespace std ; void maxLengthSubArray ( int A [ ] , int N ) { int forward [ N ] , backward [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxLengthSubArray ( arr , N ) ; return 0 ; }","['void maxLengthSubArray ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void maxLengthSubArray ( int A [ ] , int N ) {"
294,Smallest N digit number divisible by all possible prime digits | C ++ implementation of the above approach ; Function to find the minimum number of n digits divisible by all prime digits ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; } int main ( ) { int n = 5 ; minNum ( n ) ; return 0 ; }",Smallest N digit number divisible by all possible prime digits.,"#include <bits/stdc++.h>   using namespace std ; void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; } int main ( ) { int n = 5 ; minNum ( n ) ; return 0 ; }","['void minNum ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void minNum ( int n ) {
296,"Largest number made up of X and Y with count of X divisible by Y and of Y by X | C ++ program to implement the above approach ; Function to generate and return the largest number ; Store the smaller in Y ; Store the larger in X ; Stores respective counts ; If N is divisible by Y ; Append X , N times to the answer ; Reduce N to zero ; Reduce N by X ; Append Y , X times to the answer ; If number can be formed ; Otherwise ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestNumber ( int n , int X , int Y ) { int maxm = max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) cout << X ; while ( Ys -- > 0 ) cout << Y ; } else cout << "" - 1"" ; } int main ( ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; return 0 ; }",Largest number made up of X and Y with count of X divisible by Y and of Y by X.,"#include <bits/stdc++.h>   using namespace std ; void largestNumber ( int n , int X , int Y ) { int maxm = max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) cout << X ; while ( Ys -- > 0 ) cout << Y ; } else cout << "" - 1"" ; } int main ( ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; return 0 ; }","['void largestNumber ( int n , int X , int Y ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void largestNumber ( int n , int X , int Y ) {"
297,Minimum flips required to generate continuous substrings of 0 â €™ s and 1 â €™ s | C ++ implementation of the above approach ; Traverse input string and store the count of 0 ; Traverse the input string again to find minimum number of flips ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChanges ( string str , int N ) { int res ; int count0 = 0 , count1 = 0 ; for ( char x : str ) { count0 += ( x == '0' ) ; } res = count0 ; for ( char x : str ) { count0 -= ( x == '0' ) ; count1 += ( x == '1' ) ; res = min ( res , count1 + count0 ) ; } return res ; } int main ( ) { int N = 9 ; string str = ""000101001"" ; cout << minChanges ( str , N ) ; return 0 ; }",Minimum flips required to generate continuous substrings of 0 â €™ s and 1 â €™ s.,"#include <bits/stdc++.h>   using namespace std ; int minChanges ( string str , int N ) { int res ; int count0 = 0 , count1 = 0 ; for ( char x : str ) { count0 += ( x == '0' ) ; } res = count0 ; for ( char x : str ) { count0 -= ( x == '0' ) ; count1 += ( x == '1' ) ; res = min ( res , count1 + count0 ) ; } return res ; } int main ( ) { int N = 9 ; string str = ""000101001"" ; cout << minChanges ( str , N ) ; return 0 ; }","['int minChanges ( string str , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int minChanges ( string str , int N ) {"
298,Missing occurrences of a number in an array such that maximum absolute difference of adjacent elements is minimum | C ++ implementation of the missing number such that maximum absolute difference between adjacent element is minimum ; Function to find the missing number such that maximum absolute difference is minimum ; Loop to find the maximum and minimum adjacent element to missing number ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingnumber ( int n , int arr [ ] ) { int mn = INT_MAX , mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == -1 && arr [ i - 1 ] != -1 ) { mn = min ( mn , arr [ i - 1 ] ) ; mx = max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { mn = min ( mn , arr [ i + 1 ] ) ; mx = max ( mx , arr [ i + 1 ] ) ; } } long long int res = ( mx + mn ) / 2 ; return res ; } int main ( ) { int n = 5 ; int arr [ 5 ] = { -1 , 10 , -1 , 12 , -1 } ; int ans = 0 ; int res = missingnumber ( n , arr ) ; cout << res ; return 0 ; }",Missing occurrences of a number in an array such that maximum absolute difference of adjacent elements is minimum.,"#include <bits/stdc++.h>   using namespace std ; int missingnumber ( int n , int arr [ ] ) { int mn = INT_MAX , mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == -1 && arr [ i - 1 ] != -1 ) { mn = min ( mn , arr [ i - 1 ] ) ; mx = max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { mn = min ( mn , arr [ i + 1 ] ) ; mx = max ( mx , arr [ i + 1 ] ) ; } } long long int res = ( mx + mn ) / 2 ; return res ; } int main ( ) { int n = 5 ; int arr [ 5 ] = { -1 , 10 , -1 , 12 , -1 } ; int ans = 0 ; int res = missingnumber ( n , arr ) ; cout << res ; return 0 ; }","['int missingnumber ( int n , int arr [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int missingnumber ( int n , int arr [ ] ) {"
301,Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers | C ++ program for above approach ; Function to calculate the probability for the given sum to be equal to sum in N throws of dice ; Base cases ; Driver Code ; Calculate probability of all sums from a to b ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }",Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers.,"#include <bits/stdc++.h>   using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }","['float find ( int N , int sum ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int sum ) {"
302,Minimum steps to reduce N to 0 by given operations | C ++ program for the above approach ; Function to find the minimum number to steps to reduce N to 0 ; Dictionary for storing the precomputed sum ; Bases Cases ; Check if n is not in dp then only call the function so as to reduce no of recursive calls ; Return the answer ; Driver Code ; Given number N ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { map < int , int > dp ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; if ( ( dp . find ( n ) == dp . end ( ) ) ) dp [ n ] = 1 + min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ; return dp [ n ] ; } int main ( ) { int N = 6 ; cout << count ( N ) ; }",Minimum steps to reduce N to 0 by given operations.,"#include <bits/stdc++.h>   using namespace std ; int count ( int n ) { map < int , int > dp ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; if ( ( dp . find ( n ) == dp . end ( ) ) ) dp [ n ] = 1 + min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ; return dp [ n ] ; } int main ( ) { int N = 6 ; cout << count ( N ) ; }","['int count ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int count ( int n ) {
303,Minimum count of increment of K size subarrays required to form a given Array | C ++ implementation to find the minimum number of operations required to change an array of all zeros such that every element is greater than the given array ; Function to find the minimum number of operations required to change all the array of zeros such that every element is greater than the given array ; Declaring the difference array of size N ; Number of operations ; First update the D [ i ] value with the previous value ; The index i has to be incremented ; We have to perform ( b [ i ] - d [ i ] ) operations more ; Increment the range i to i + k by need ; Check if i + k is valid index ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_minimum_operations ( int n , int b [ ] , int k ) { int d [ n + 1 ] = { 0 } ; int operations = 0 , need ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } cout << operations << endl ; } int main ( ) { int n = 5 ; int b [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ; find_minimum_operations ( n , b , k ) ; return 0 ; }",Minimum count of increment of K size subarrays required to form a given Array.,"#include <bits/stdc++.h>   using namespace std ; int find_minimum_operations ( int n , int b [ ] , int k ) { int d [ n + 1 ] = { 0 } ; int operations = 0 , need ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } cout << operations << endl ; } int main ( ) { int n = 5 ; int b [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ; find_minimum_operations ( n , b , k ) ; return 0 ; }","['int find_minimum_operations ( int n , int b [ ] , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int find_minimum_operations ( int n , int b [ ] , int k ) {"
304,"Number of ways of cutting a Matrix such that atleast one cell is filled in each part | CPP implementation to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell ; Function to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell ; Loop to find prefix sum of the given matrix ; dp ( r , c , 1 ) = 1 if preSum [ r ] else 0 ; Loop to iterate over the dp table of the given matrix ; Check if can cut horizontally at r1 , at least one apple in matrix ( r , c ) -> r1 , C - 1 ; Check if we can cut vertically at c1 , at least one apple in matrix ( r , c ) -> R - 1 , c1 ; Driver code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int ways ( vector < vector < int > > & arr , int K ) { int R = arr . size ( ) ; int C = arr [ 0 ] . size ( ) ; int preSum [ R ] [ C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } int dp [ K + 1 ] [ R ] [ C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; } int main ( ) { vector < vector < int > > arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ; cout << ways ( arr , k ) << endl ; return 0 ; }",Number of ways of cutting a Matrix such that atleast one cell is filled in each part.,"#include <bits/stdc++.h>   using namespace std ; int ways ( vector < vector < int > > & arr , int K ) { int R = arr . size ( ) ; int C = arr [ 0 ] . size ( ) ; int preSum [ R ] [ C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } int dp [ K + 1 ] [ R ] [ C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; } int main ( ) { vector < vector < int > > arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ; cout << ways ( arr , k ) << endl ; return 0 ; }","['int ways ( vector < vector < int > > & arr , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int ways ( vector < vector < int > > & arr , int K ) {"
306,Number of ways to write N as a sum of K non | C ++ program for the above approach ; Function to count the number of ways to write N as sum of k non - negative integers ; Initialise dp [ ] [ ] array ; Only 1 way to choose the value with sum K ; Initialise sum ; Count the ways from previous states ; Update the sum ; Return the final count of ways ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }",Number of ways to write N as a sum of K non.,"#include <bits/stdc++.h>   using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }","['int countWays ( int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int countWays ( int n , int m ) {"
307,"Number of ways to write N as a sum of K non | C ++ program for the above approach ; Function to count the number of ways to write N as sum of k non - negative integers ; Initialise dp [ ] [ ] array ; Fill the dp [ ] [ ] with sum = m ; Iterate the dp [ ] [ ] to fill the dp [ ] [ ] array ; Condition for first column ; Else fill the dp [ ] [ ] with sum till ( i , j ) ; If reach the end , then return the value ; Update at current index ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }",Number of ways to write N as a sum of K non.,"#include <bits/stdc++.h>   using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }","['int countWays ( int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int countWays ( int n , int m ) {"
311,"Count ways to reach the nth stair using step 1 , 2 or 3 | C ++ Program to find n - th stair using step size 1 or 2 or 3. ; Returns count of ways to reach n - th stair using 1 or 2 or 3 steps . ; Driver code",#include <iostream> NEW_LINE using namespace std ; class GFG { public : int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } } ; int main ( ) { GFG g ; int n = 4 ; cout << g . findStep ( n ) ; return 0 ; },"Count ways to reach the nth stair using step 1 , 2 or 3.",#include <iostream>   using namespace std ; class GFG { public : int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } } ; int main ( ) { GFG g ; int n = 4 ; cout << g . findStep ( n ) ; return 0 ; },"['int findStep ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; class GFG { public : int findStep ( int n ) {
313,"Partition problem | DP | A Dynamic Programming based C ++ program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; Initialize the part array as 0 ; Fill the partition table in bottom up manner ; the element to be included in the sum cannot be greater than the sum ; j -- ) { check if sum - arr [ i ] could be formed from a subset using elements before index i ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }",Partition problem.,"#include <bits/stdc++.h>   using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }","['bool findPartiion ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool findPartiion ( int arr [ ] , int n ) {"
314,Binomial Coefficient | DP | C ++ program for the above approach ; Function to find binomial coefficient ; Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007 ; for 1 / ( r ! ) part ; for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << r << "" ) ▁ is ▁ "" << binomialCoeff ( n , r ) << endl ; return 0 ; }",Binomial Coefficient.,"#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << r << "" ) ▁ is ▁ "" << binomialCoeff ( n , r ) << endl ; return 0 ; }","['int binomialCoeff ( int n , int r ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int binomialCoeff ( int n , int r ) {"
316,Find the element in the matrix generated by given rules | C ++ implementation of the approach ; Function to return the element in the rth row and cth column from the required matrix ; Condition for lower half of matrix ; Condition if element is in first row ; Starting element of AP in row r ; Common difference of AP in row r ; Position of element to find in AP in row r ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; } int main ( ) { int N = 4 , R = 3 , C = 4 ; cout << getElement ( N , R , C ) ; return 0 ; }",Find the element in the matrix generated by given rules.,"#include <bits/stdc++.h>   using namespace std ; int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; } int main ( ) { int N = 4 , R = 3 , C = 4 ; cout << getElement ( N , R , C ) ; return 0 ; }","['int getElement ( int N , int r , int c ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int getElement ( int N , int r , int c ) {"
317,"Find smallest number formed by inserting given digit | C ++ implementation of above approach ; Function to insert X in N and return the minimum value string ; Variable to store length of string N ; Variable to denote the position where X must be added ; If the given string N represent a negative value ; X must be place at the last index where is greater than N [ i ] ; For positive numbers , X must be placed at the last index where it is smaller than N [ i ] ; Insert X at that position ; Return the string ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; string MinValue ( string N , int X ) { int len = N . size ( ) ; int position = len + 1 ; if ( N [ 0 ] == ' - ' ) { for ( int i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] - '0' ) < X ) { position = i ; } } } else { for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] - '0' ) > X ) { position = i ; } } } N . insert ( N . begin ( ) + position , X + '0' ) ; return N ; } int main ( ) { string N = ""89"" ; int X = 1 ; cout << MinValue ( N , X ) << "" STRNEWLINE "" ; }",Find smallest number formed by inserting given digit.,"#include <bits/stdc++.h>   using namespace std ; string MinValue ( string N , int X ) { int len = N . size ( ) ; int position = len + 1 ; if ( N [ 0 ] == ' - ' ) { for ( int i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] - '0' ) < X ) { position = i ; } } } else { for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] - '0' ) > X ) { position = i ; } } } N . insert ( N . begin ( ) + position , X + '0' ) ; return N ; } int main ( ) { string N = ""89"" ; int X = 1 ; cout << MinValue ( N , X ) << "" STRNEWLINE "" ; }","['string MinValue ( string N , int X ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; string MinValue ( string N , int X ) {"
318,"Check if Decimal representation of given Binary String is divisible by K or not | C ++ program for above approach ; Function to check the binary number is divisible by K ; Array poweroftwo will store pow ( 2 , i ) % k ; Initializing the first element in Array ; Storing every pow ( 2 , i ) % k value in the array ; To store the remaining ; Iterating till N ; If current bit is 1 ; Updating rem ; If completely divisible ; If not Completely divisible ; Driver Code ; Given Input ; length of string s ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; string divisibleByk ( string s , int n , int k ) { int poweroftwo [ n ] ; poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; } int rem = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ n - i - 1 ] == '1' ) { rem += ( poweroftwo [ i ] ) ; rem %= k ; } } if ( rem == 0 ) { return "" Yes "" ; } else return "" No "" ; } int main ( ) { string s = ""1010001"" ; int k = 9 ; int n = s . length ( ) ; cout << divisibleByk ( s , n , k ) ; return 0 ; }",Check if Decimal representation of given Binary String is divisible by K or not.,"#include <bits/stdc++.h>   using namespace std ; string divisibleByk ( string s , int n , int k ) { int poweroftwo [ n ] ; poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; } int rem = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ n - i - 1 ] == '1' ) { rem += ( poweroftwo [ i ] ) ; rem %= k ; } } if ( rem == 0 ) { return "" Yes "" ; } else return "" No "" ; } int main ( ) { string s = ""1010001"" ; int k = 9 ; int n = s . length ( ) ; cout << divisibleByk ( s , n , k ) ; return 0 ; }","['string divisibleByk ( string s , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; string divisibleByk ( string s , int n , int k ) {"
319,Split a Binary String such that count of 0 s and 1 s in left and right substrings is maximum | C ++ program to implement the above approach ; Function to find the maximum sum of count of 0 s in the left substring and count of 1 s in the right substring by splitting the string ; Stores count of 1 s the in binary string ; Traverse the binary string ; If current character is '1' ; Update cntOne ; Stores count of 0 s ; Stores count of 1 s ; Stores maximum sum of count of 0 s and 1 s by splitting the string ; Traverse the binary string ; If current character is '0' ; Update zero ; If current character is '1' ; Update one ; Update res ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumbySplittingstring ( string str , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) { cntOne ++ ; } } int zero = 0 ; int one = 0 ; int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { one ++ ; } res = max ( res , zero + cntOne - one ) ; } return res ; } int main ( ) { string str = ""00111"" ; int N = str . length ( ) ; cout << maxSumbySplittingstring ( str , N ) ; return 0 ; }",Split a Binary String such that count of 0 s and 1 s in left and right substrings is maximum.,"#include <bits/stdc++.h>   using namespace std ; int maxSumbySplittingstring ( string str , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) { cntOne ++ ; } } int zero = 0 ; int one = 0 ; int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { one ++ ; } res = max ( res , zero + cntOne - one ) ; } return res ; } int main ( ) { string str = ""00111"" ; int N = str . length ( ) ; cout << maxSumbySplittingstring ( str , N ) ; return 0 ; }","['int maxSumbySplittingstring ( string str , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxSumbySplittingstring ( string str , int N ) {"
323,Minimum cost to remove the spaces between characters of a String by rearranging the characters | C ++ program to gather characters of a string in minimum cost ; Function to calculate the minimum cost ; Stores the minimum cost ; Stores the count of characters found ; Stores the count of blank spaces found ; Stores the count of total characters ; If the count of characters is equal to 1 ; Iterate over the string ; Consider the previous character together with current character ; If not together already ; Add the cost to group them together ; Increase count of characters found ; Otherwise ; Increase count of spaces found ; Return the total cost obtained ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S ) if ( c == ' ▁ ' ) count ++ ; int n = S . size ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; } int main ( ) { string S = "" ▁ @ TABSYMBOL $ "" ; cout << min_cost ( S ) ; return 0 ; }",Minimum cost to remove the spaces between characters of a String by rearranging the characters.,"#include <bits/stdc++.h>   using namespace std ; int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S ) if ( c == ' ▁ ' ) count ++ ; int n = S . size ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; } int main ( ) { string S = "" ▁ @ TABSYMBOL $ "" ; cout << min_cost ( S ) ; return 0 ; }","['int min_cost ( string S ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int min_cost ( string S ) {
325,Generate a string whose all K | C ++ program to generate a string whose substrings of length K concatenates to form given strings ; Function to return the required required string ; Iterate the given string ; Append the first character of every substring of length K ; Consider all characters from the last substring ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void decode_String ( string str , int K ) { string ans = "" "" ; for ( int i = 0 ; i < str . size ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . size ( ) - ( K - 1 ) ; i < str . size ( ) ; i ++ ) ans += str [ i ] ; cout << ans << endl ; } int main ( ) { int K = 3 ; string str = "" abcbcscsesesesd "" ; decode_String ( str , K ) ; }",Generate a string whose all K.,"#include <bits/stdc++.h>   using namespace std ; void decode_String ( string str , int K ) { string ans = "" "" ; for ( int i = 0 ; i < str . size ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . size ( ) - ( K - 1 ) ; i < str . size ( ) ; i ++ ) ans += str [ i ] ; cout << ans << endl ; } int main ( ) { int K = 3 ; string str = "" abcbcscsesesesd "" ; decode_String ( str , K ) ; }","['void decode_String ( string str , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void decode_String ( string str , int K ) {"
327,Decode the string encoded with the given algorithm | C ++ implementation of the approach ; Function to decode and print the original string ; To store the decoded string ; Getting the mid element ; Storing the first element of the string at the median position ; If the length is even then store the second element also ; k represents the number of characters that are already stored in the c [ ] ; If string length is odd ; If it is even ; Print the decoded string ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void decodeStr ( string str , int len ) { char c [ len ] = "" "" ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) cout << c [ i ] ; } int main ( ) { string str = "" ofrsgkeeeekgs "" ; int len = str . length ( ) ; decodeStr ( str , len ) ; return 0 ; }",Decode the string encoded with the given algorithm.,"#include <bits/stdc++.h>   using namespace std ; void decodeStr ( string str , int len ) { char c [ len ] = "" "" ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) cout << c [ i ] ; } int main ( ) { string str = "" ofrsgkeeeekgs "" ; int len = str . length ( ) ; decodeStr ( str , len ) ; return 0 ; }","['void decodeStr ( string str , int len ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void decodeStr ( string str , int len ) {"
328,Count of distinct characters in a substring by given range for Q queries | C ++ Program for Naive Approach ; counter to count distinct char ; Initializing frequency array to count characters as the appear in substring S [ L : R ] ; Iterating over S [ L ] to S [ R ] ; incrementing the count of s [ i ] character in frequency array ; if frequency of any character is > 0 then increment the counter ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCount ( string s , int L , int R ) { int distinct = 0 ; int frequency [ 26 ] = { } ; for ( int i = L ; i <= R ; i ++ ) { frequency [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] > 0 ) distinct ++ ; } cout << distinct << endl ; } int main ( ) { string s = "" geeksforgeeksisacomputerscienceportal "" ; int queries = 3 ; int Q [ queries ] [ 2 ] = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; return 0 ; }",Count of distinct characters in a substring by given range for Q queries.,"#include <bits/stdc++.h>   using namespace std ; void findCount ( string s , int L , int R ) { int distinct = 0 ; int frequency [ 26 ] = { } ; for ( int i = L ; i <= R ; i ++ ) { frequency [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] > 0 ) distinct ++ ; } cout << distinct << endl ; } int main ( ) { string s = "" geeksforgeeksisacomputerscienceportal "" ; int queries = 3 ; int Q [ queries ] [ 2 ] = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; return 0 ; }","['void findCount ( string s , int L , int R ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findCount ( string s , int L , int R ) {"
329,String obtained by reversing and complementing a Binary string K times | C ++ program to perform K operations upon the string and find the modified string ; Function to perform K operations upon the string and find modified string ; Number of reverse operations ; Number of complement operations ; If rev is odd parity ; If complement is odd parity ; Complementing each position ; Return the modified string ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string ReverseComplement ( string s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 ) reverse ( s . begin ( ) , s . end ( ) ) ; if ( complement % 2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return s ; } int main ( ) { string str = ""10011"" ; int k = 5 ; int n = str . size ( ) ; cout << ReverseComplement ( str , n , k ) ; return 0 ; }",String obtained by reversing and complementing a Binary string K times.,"#include <bits/stdc++.h>   using namespace std ; string ReverseComplement ( string s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 ) reverse ( s . begin ( ) , s . end ( ) ) ; if ( complement % 2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return s ; } int main ( ) { string str = ""10011"" ; int k = 5 ; int n = str . size ( ) ; cout << ReverseComplement ( str , n , k ) ; return 0 ; }","['string ReverseComplement ( string s , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; string ReverseComplement ( string s , int n , int k ) {"
330,Check if any permutation of string is a K times repeated string | C ++ implementation to check that the permutation of the given string is K times repeated string ; Function to check that permutation of the given string is a K times repeating String ; if length of string is not divisible by K ; Frequency Array ; Initially frequency of each character is 0 ; Computing the frequency of each character in the string ; Loop to check that frequency of every character of the string is divisible by K ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool repeatingString ( string s , int n , int k ) { if ( n % k != 0 ) { return false ; } int frequency [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } int main ( ) { string s = "" abcdcba "" ; int n = s . size ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }",Check if any permutation of string is a K times repeated string.,"#include <bits/stdc++.h>   using namespace std ; bool repeatingString ( string s , int n , int k ) { if ( n % k != 0 ) { return false ; } int frequency [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } int main ( ) { string s = "" abcdcba "" ; int n = s . size ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }","['bool repeatingString ( string s , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool repeatingString ( string s , int n , int k ) {"
331,"Find the last two missing digits of the given phone number | C ++ implementation of the approach ; Function to find the last two digits of the number and print the complete number ; Sum of the first eight digits of the number ; if sum < 10 , then the two digits are '0' and the value of sum ; if sum > 10 , then the two digits are the value of sum ; Driver code","#include <iostream> NEW_LINE using namespace std ; void findPhoneNumber ( int n ) { int temp = n ; int sum ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) cout << n << ""0"" << sum ; else cout << n << sum ; } int main ( ) { long int n = 98765432 ; findPhoneNumber ( n ) ; return 0 ; }",Find the last two missing digits of the given phone number.,"#include <iostream>   using namespace std ; void findPhoneNumber ( int n ) { int temp = n ; int sum ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) cout << n << ""0"" << sum ; else cout << n << sum ; } int main ( ) { long int n = 98765432 ; findPhoneNumber ( n ) ; return 0 ; }","['void findPhoneNumber ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; void findPhoneNumber ( int n ) {
332,Number of ways to split a binary number such that every part is divisible by 2 | C ++ implementation of the approach ; Function to return the required count ; If the splitting is not possible ; To store the count of zeroes ; Counting the number of zeroes ; Return the final answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_zero - 1 ) ; } int main ( ) { string s = ""10010"" ; cout << cntSplits ( s ) ; return 0 ; }",Number of ways to split a binary number such that every part is divisible by 2.,"#include <bits/stdc++.h>   using namespace std ; #define maxN  20   #define maxM  64   int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_zero - 1 ) ; } int main ( ) { string s = ""10010"" ; cout << cntSplits ( s ) ; return 0 ; }","['int cntSplits ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define maxN  20   #define maxM  64   int cntSplits ( string s ) {
333,Count number of substrings of a string consisting of same characters | C ++ implementation of the above approach ; Function to return the number of substrings of same characters ; Size of the string ; Initialize count to 1 ; Initialize left to 0 and right to 1 to traverse the string ; Checking if consecutive characters are same and increment the count ; When we encounter a different characters ; Increment the result ; To repeat the whole process set left equals right and count variable to 1 ; Store the final value of result ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( string s ) { if ( s . empty ( ) ) return 0 ; int n = s . size ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; } int main ( ) { string s = "" bbbcbb "" ; findNumbers ( s ) ; }",Count number of substrings of a string consisting of same characters.,"#include <bits/stdc++.h>   using namespace std ; void findNumbers ( string s ) { if ( s . empty ( ) ) return 0 ; int n = s . size ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; } int main ( ) { string s = "" bbbcbb "" ; findNumbers ( s ) ; }","['void findNumbers ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void findNumbers ( string s ) {
335,"Convert a String to an Integer using Recursion | C ++ implementation of the approach ; Recursive function to convert string to integer ; If the number represented as a string contains only a single digit then returns its value ; Recursive call for the sub - string starting at the second character ; First digit of the number ; First digit multiplied by the appropriate power of 10 and then add the recursive result For example , xy = ( ( x * 10 ) + y ) ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int stringToInt ( string str ) { if ( str . length ( ) == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . substr ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * pow ( 10 , str . length ( ) - 1 ) + y ; return int ( x ) ; } int main ( ) { string str = ""1235"" ; cout << ( stringToInt ( str ) ) << endl ; }",Convert a String to an Integer using Recursion.,"#include <bits/stdc++.h>   using namespace std ; int stringToInt ( string str ) { if ( str . length ( ) == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . substr ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * pow ( 10 , str . length ( ) - 1 ) + y ; return int ( x ) ; } int main ( ) { string str = ""1235"" ; cout << ( stringToInt ( str ) ) << endl ; }","['int stringToInt ( string str ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int stringToInt ( string str ) {
336,"Longest subsequence with at least one character appearing in every string | C ++ implementation of the approach ; Function to return the length of the longest sub - sequence with at least one common character in every string ; count [ 0 ] will store the number of strings which contain ' a ' , count [ 1 ] will store the number of strings which contain ' b ' and so on . . ; For every string ; Hash array to set which character is present in the current string ; If current character appears in the string then update its count ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE int largestSubSeq ( string arr [ ] , int n ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool hash [ MAX ] = { 0 } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str [ j ] - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return * ( max_element ( count , count + MAX ) ) ; } int main ( ) { string arr [ ] = { "" ab "" , "" bc "" , "" de "" } ; int n = sizeof ( arr ) / sizeof ( string ) ; cout << largestSubSeq ( arr , n ) ; return 0 ; }",Longest subsequence with at least one character appearing in every string.,"#include <bits/stdc++.h>   using namespace std ; #define MAX  26   int largestSubSeq ( string arr [ ] , int n ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool hash [ MAX ] = { 0 } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str [ j ] - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return * ( max_element ( count , count + MAX ) ) ; } int main ( ) { string arr [ ] = { "" ab "" , "" bc "" , "" de "" } ; int n = sizeof ( arr ) / sizeof ( string ) ; cout << largestSubSeq ( arr , n ) ; return 0 ; }","['int largestSubSeq ( string arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define MAX  26   int largestSubSeq ( string arr [ ] , int n ) {"
338,Minimize the length of string by removing occurrence of only one character | C ++ program to minimize the length of string by removing occurrence of only one character ; Function to find the minimum length ; Count the frequency of each alphabet ; Find the alphabets with maximum frequency ; Subtract the frequency of character from length of string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } int main ( ) { string str = "" afddewqd "" ; cout << minimumLength ( str ) ; return 0 ; }",Minimize the length of string by removing occurrence of only one character.,"#include <bits/stdc++.h>   using namespace std ; int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } int main ( ) { string str = "" afddewqd "" ; cout << minimumLength ( str ) ; return 0 ; }","['int minimumLength ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int minimumLength ( string s ) {
339,Remove all characters other than alphabets from string | CPP program to remove all the characters other then alphabets ; function to remove characters and print new string ; Finding the character whose ASCII value fall under this range ; erase function to erase the character ; driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s . erase ( i , 1 ) ; i -- ; } } cout << s ; } int main ( ) { string s = "" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? "" ; removeSpecialCharacter ( s ) ; return 0 ; }",Remove all characters other than alphabets from string.,"#include <bits/stdc++.h>   using namespace std ; void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s . erase ( i , 1 ) ; i -- ; } } cout << s ; } int main ( ) { string s = "" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? "" ; removeSpecialCharacter ( s ) ; return 0 ; }","['void removeSpecialCharacter ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void removeSpecialCharacter ( string s ) {
340,Remove all characters other than alphabets from string | CPP program to remove all the characters other then alphabets ; function to remove characters and print new string ; Store only valid characters ; driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } cout << s . substr ( 0 , j ) ; } int main ( ) { string s = "" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? "" ; removeSpecialCharacter ( s ) ; return 0 ; }",Remove all characters other than alphabets from string.,"#include <bits/stdc++.h>   using namespace std ; void removeSpecialCharacter ( string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } cout << s . substr ( 0 , j ) ; } int main ( ) { string s = "" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? "" ; removeSpecialCharacter ( s ) ; return 0 ; }","['void removeSpecialCharacter ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void removeSpecialCharacter ( string s ) {
341,Find repeated character present first in a string | C ++ program to find the first character that is repeated ; this is O ( N ^ 2 ) method ; Driver code,"#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; } int main ( ) { char str [ ] = "" geeksforgeeks "" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == -1 ) cout << "" Not ▁ found "" ; else cout << str [ pos ] ; return 0 ; }",Find repeated character present first in a string.,"#include <bits/stdc++.h>   #include <string.h>   using namespace std ; int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; } int main ( ) { char str [ ] = "" geeksforgeeks "" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == -1 ) cout << "" Not ▁ found "" ; else cout << str [ pos ] ; return 0 ; }","['int findRepeatFirstN2 ( char * s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   #include <string.h>   using namespace std ; int findRepeatFirstN2 ( char * s ) {
342,Print characters and their frequencies in order of occurrence | C ++ implementation to print the characters and frequencies in order of its occurrence ; Store all characters and their frequencies in dictionary ; Print characters and their frequencies in same order of their appearance ; Print only if this character is not printed before ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void prCharWithFreq ( string s ) { unordered_map < char , int > d ; for ( char i : s ) { d [ i ] ++ ; } for ( char i : s ) { if ( d [ i ] != 0 ) { cout << i << d [ i ] << "" ▁ "" ; d [ i ] = 0 ; } } } int main ( ) { string s = "" geeksforgeeks "" ; prCharWithFreq ( s ) ; }",Print characters and their frequencies in order of occurrence.,"#include <bits/stdc++.h>   using namespace std ; void prCharWithFreq ( string s ) { unordered_map < char , int > d ; for ( char i : s ) { d [ i ] ++ ; } for ( char i : s ) { if ( d [ i ] != 0 ) { cout << i << d [ i ] << "" ▁ "" ; d [ i ] = 0 ; } } } int main ( ) { string s = "" geeksforgeeks "" ; prCharWithFreq ( s ) ; }","['void prCharWithFreq ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void prCharWithFreq ( string s ) {
343,"Count number of strings ( made of R , G and B ) using given combination | C ++ program to count number of possible strings with n characters . ; Function to calculate number of strings ; Store factorial of numbers up to n for further computation ; Find the remaining values to be added ; Make all possible combinations of R , B and G for the remaining value ; Compute permutation of each combination one by one and add them . ; Return total no . of strings / permutation ; Drivers code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; } int main ( ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; cout << possibleStrings ( n , r , b , g ) ; return 0 ; }","Count number of strings ( made of R , G and B ) using given combination.","#include <bits/stdc++.h>   using namespace std ; int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; } int main ( ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; cout << possibleStrings ( n , r , b , g ) ; return 0 ; }","['int possibleStrings ( int n , int r , int b , int g ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int possibleStrings ( int n , int r , int b , int g ) {"
344,Remove minimum number of characters so that two strings become anagram | C ++ program to find minimum number of characters to be removed to make two strings anagram . ; function to calculate minimum numbers of characters to be removed to make two strings anagram ; make hash array for both string and calculate frequency of each character ; count frequency of each character in first string ; count frequency of each character in second string ; traverse count arrays to find number of characters to be removed ; Driver program to run the case,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \0' ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } int main ( ) { string str1 = "" bcadeh "" , str2 = "" hea "" ; cout << remAnagram ( str1 , str2 ) ; return 0 ; }",Remove minimum number of characters so that two strings become anagram.,"#include <bits/stdc++.h>   using namespace std ; const int CHARS = 26 ; int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \0' ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } int main ( ) { string str1 = "" bcadeh "" , str2 = "" hea "" ; cout << remAnagram ( str1 , str2 ) ; return 0 ; }","['int remAnagram ( string str1 , string str2 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; const int CHARS = 26 ; int remAnagram ( string str1 , string str2 ) {"
345,"Check if a string has all characters with same frequency with one variation allowed | C ++ program to check if a string can be made valid by removing at most 1 character . ; Assuming only lower case characters ; To check a string S can be converted to a valid string by removing less than or equal to one character . ; freq [ ] : stores the frequency of each character of a string ; Find first character with non - zero frequency ; Find a character with frequency different from freq1 . ; If we find a third non - zero frequency or count of both frequencies become more than 1 , then return false ; else If we find a third non - zero freq ; If counts of both frequencies is more than 1 ; Return true if we reach here ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; bool isValidString ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; return false ; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; } int main ( ) { char str [ ] = "" abcbc "" ; if ( isValidString ( str ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }",Check if a string has all characters with same frequency with one variation allowed.,"#include <bits/stdc++.h>   using namespace std ; const int CHARS = 26 ; bool isValidString ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; return false ; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; } int main ( ) { char str [ ] = "" abcbc "" ; if ( isValidString ( str ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }","['bool isValidString ( string str ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; const int CHARS = 26 ; bool isValidString ( string str ) {
346,Check if a string has all characters with same frequency with one variation allowed | C ++ program to check if a string can be made valid by removing at most 1 character using hashmap . ; To check a string S can be converted to a variation string ; Run loop form 0 to length of string ; declaration of variables ; if first is true than countOfVal1 increase ; if second is true than countOfVal2 increase ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkForVariation ( string str ) { if ( str . empty ( ) || str . length ( ) != 0 ) { return true ; } map < char , int > mapp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mapp [ str [ i ] ] ++ ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; map < char , int > :: iterator itr ; for ( itr = mapp . begin ( ) ; itr != mapp . end ( ) ; ++ itr ) { int i = itr -> first ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } } int main ( ) { if ( checkForVariation ( "" abcbcvf "" ) ) cout << "" true "" << endl ; else cout << "" false "" << endl ; return 0 ; }",Check if a string has all characters with same frequency with one variation allowed.,"#include <bits/stdc++.h>   using namespace std ; bool checkForVariation ( string str ) { if ( str . empty ( ) || str . length ( ) != 0 ) { return true ; } map < char , int > mapp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mapp [ str [ i ] ] ++ ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; map < char , int > :: iterator itr ; for ( itr = mapp . begin ( ) ; itr != mapp . end ( ) ; ++ itr ) { int i = itr -> first ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } } int main ( ) { if ( checkForVariation ( "" abcbcvf "" ) ) cout << "" true "" << endl ; else cout << "" false "" << endl ; return 0 ; }","['bool checkForVariation ( string str ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; bool checkForVariation ( string str ) {
347,"Pairs of complete strings in two sets of strings | C ++ implementation for find pairs of complete strings . ; Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ] ; Consider all pairs of both strings ; Create a concatenation of current pair ; Compute frequencies of all characters in the concatenated string . ; If frequency of any character is not greater than 0 , then this pair is not complete . ; Driver code","#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { string concat = set1 [ i ] + set2 [ j ] ; int frequency [ 26 ] = { 0 } ; for ( int k = 0 ; k < concat . length ( ) ; k ++ ) frequency [ concat [ k ] - ' a ' ] ++ ; int i ; for ( i = 0 ; i < 26 ; i ++ ) if ( frequency [ i ] < 1 ) break ; if ( i == 26 ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { "" abcdefgh "" , "" geeksforgeeks "" , "" lmnopqrst "" , "" abc "" } ; string set2 [ ] = { "" ijklmnopqrstuvwxyz "" , "" abcdefghijklmnopqrstuvwxyz "" , "" defghijklmnopqrstuvwxyz "" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }",Pairs of complete strings in two sets of strings.,"#include <iostream>   using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { string concat = set1 [ i ] + set2 [ j ] ; int frequency [ 26 ] = { 0 } ; for ( int k = 0 ; k < concat . length ( ) ; k ++ ) frequency [ concat [ k ] - ' a ' ] ++ ; int i ; for ( i = 0 ; i < 26 ; i ++ ) if ( frequency [ i ] < 1 ) break ; if ( i == 26 ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { "" abcdefgh "" , "" geeksforgeeks "" , "" lmnopqrst "" , "" abc "" } ; string set2 [ ] = { "" ijklmnopqrstuvwxyz "" , "" abcdefghijklmnopqrstuvwxyz "" , "" defghijklmnopqrstuvwxyz "" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }","['int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) {"
348,"Pairs of complete strings in two sets of strings | C ++ program to find count of complete pairs ; Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ] ; con_s1 [ i ] is going to store an integer whose set bits represent presence / absence of characters in string set1 [ i ] . Similarly con_s2 [ i ] is going to store an integer whose set bits represent presence / absence of characters in string set2 [ i ] ; Process all strings in set1 [ ] ; initializing all bits to 0 ; Setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer . ; Process all strings in set2 [ ] ; initializing all bits to 0 ; setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer . ; assigning a variable whose all 26 ( 0. . 25 ) bits are set to 1 ; Now consider every pair of integer in con_s1 [ ] and con_s2 [ ] and check if the pair is complete . ; if all bits are set , the strings are complete ! ; Driver code","#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; int con_s1 [ n ] , con_s2 [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - ' a ' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - ' a ' ) ) ; } } long long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { "" abcdefgh "" , "" geeksforgeeks "" , "" lmnopqrst "" , "" abc "" } ; string set2 [ ] = { "" ijklmnopqrstuvwxyz "" , "" abcdefghijklmnopqrstuvwxyz "" , "" defghijklmnopqrstuvwxyz "" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }",Pairs of complete strings in two sets of strings.,"#include <iostream>   using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; int con_s1 [ n ] , con_s2 [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - ' a ' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - ' a ' ) ) ; } } long long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { "" abcdefgh "" , "" geeksforgeeks "" , "" lmnopqrst "" , "" abc "" } ; string set2 [ ] = { "" ijklmnopqrstuvwxyz "" , "" abcdefghijklmnopqrstuvwxyz "" , "" defghijklmnopqrstuvwxyz "" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }","['int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) {"
352,Reverse words in a given string | C ++ code to reverse a string ; Reverse the string ; Check if number of words is even ; Find the middle word ; Starting from the middle start swapping words at jth position and l - 1 - j position ; Check if number of words is odd ; Find the middle word ; Starting from the middle start swapping the words at jth position and l - 1 - j position ; Return the reversed sentence ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string RevString ( string s [ ] , int l ) { if ( l % 2 == 0 ) { int j = l / 2 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } else { int j = ( l / 2 ) + 1 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } string S = s [ 0 ] ; for ( int i = 1 ; i < 9 ; i ++ ) { S = S + "" ▁ "" + s [ i ] ; } return S ; } int main ( ) { string s = "" getting ▁ good ▁ at ▁ coding ▁ "" "" needs ▁ a ▁ lot ▁ of ▁ practice "" ; string words [ ] = { "" getting "" , "" good "" , "" at "" , "" coding "" , "" needs "" , "" a "" , "" lot "" , "" of "" , "" practice "" } ; cout << RevString ( words , 9 ) << endl ; return 0 ; }",Reverse words in a given string.,"#include <bits/stdc++.h>   using namespace std ; string RevString ( string s [ ] , int l ) { if ( l % 2 == 0 ) { int j = l / 2 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } else { int j = ( l / 2 ) + 1 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } string S = s [ 0 ] ; for ( int i = 1 ; i < 9 ; i ++ ) { S = S + "" ▁ "" + s [ i ] ; } return S ; } int main ( ) { string s = "" getting ▁ good ▁ at ▁ coding ▁ "" "" needs ▁ a ▁ lot ▁ of ▁ practice "" ; string words [ ] = { "" getting "" , "" good "" , "" at "" , "" coding "" , "" needs "" , "" a "" , "" lot "" , "" of "" , "" practice "" } ; cout << RevString ( words , 9 ) << endl ; return 0 ; }","['string RevString ( string s [ ] , int l ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; string RevString ( string s [ ] , int l ) {"
355,Maximum number of region in which N non | C ++ program to implement the above problem ; Function to find the maximum number of regions on a plane ; print the maximum number of regions ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; } int main ( ) { int n = 10 ; maxRegions ( n ) ; return 0 ; },Maximum number of region in which N non.,#include <bits/stdc++.h>   using namespace std ; void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; } int main ( ) { int n = 10 ; maxRegions ( n ) ; return 0 ; },"['void maxRegions ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void maxRegions ( int n ) {
356,Check whether jigsaw puzzle solveable or not | C ++ program for the above approach ; Function to check if the jigsaw Puzzle is solveable or not ; Base Case ; By placing the blank tabs as a chain ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << "" YES "" ; else if ( m == 2 and n == 2 ) cout << "" YES "" ; else cout << "" NO "" ; } int main ( ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; }",Check whether jigsaw puzzle solveable or not.,"#include <bits/stdc++.h>   using namespace std ; void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << "" YES "" ; else if ( m == 2 and n == 2 ) cout << "" YES "" ; else cout << "" NO "" ; } int main ( ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; }","['void checkSolveable ( int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void checkSolveable ( int n , int m ) {"
359,Largest odd divisor Game to check which player wins | C ++ implementation to find the Largest Odd Divisor Game to check which player wins ; Function to find the Largest Odd Divisor Game to check which player wins ; Check if n == 1 then player 2 will win ; Check if n == 2 or n is odd ; While n is greater than k and divisible by 2 keep incrementing tha val ; Loop to find greatest odd divisor ; Check if n is a power of 2 ; Check if cnt is not one then player 1 wins ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) cout << "" No "" << endl ; else if ( ( n & 1 ) or n == 2 ) cout << "" Yes "" << endl ; else { int tmp = n ; int val = 1 ; while ( tmp > k and tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) cout << "" No "" << endl ; else if ( n / tmp == 2 and cnt == 1 ) cout << "" No "" << endl ; else cout << "" Yes "" << endl ; } } int main ( ) { long long n = 1 , k = 1 ; findWinner ( n , k ) ; return 0 ; }",Largest odd divisor Game to check which player wins.,"#include <bits/stdc++.h>   using namespace std ; void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) cout << "" No "" << endl ; else if ( ( n & 1 ) or n == 2 ) cout << "" Yes "" << endl ; else { int tmp = n ; int val = 1 ; while ( tmp > k and tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) cout << "" No "" << endl ; else if ( n / tmp == 2 and cnt == 1 ) cout << "" No "" << endl ; else cout << "" Yes "" << endl ; } } int main ( ) { long long n = 1 , k = 1 ; findWinner ( n , k ) ; return 0 ; }","['void findWinner ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void findWinner ( int n , int k ) {"
360,Find all numbers up to N which are both Pentagonal and Hexagonal | C ++ Program of the above approach ; Function to print numbers upto N which are both pentagonal as well as hexagonal numbers ; Calculate i - th pentagonal number ; Check if the pentagonal number pn is hexagonal or not ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void pen_hex ( long long n ) { long long pn = 1 ; for ( long long int i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; long double seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == long ( seqNum ) ) cout << pn << "" , ▁ "" ; } } int main ( ) { long long int N = 1000000 ; pen_hex ( N ) ; return 0 ; }",Find all numbers up to N which are both Pentagonal and Hexagonal.,"#include <bits/stdc++.h>   using namespace std ; void pen_hex ( long long n ) { long long pn = 1 ; for ( long long int i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; long double seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == long ( seqNum ) ) cout << pn << "" , ▁ "" ; } } int main ( ) { long long int N = 1000000 ; pen_hex ( N ) ; return 0 ; }","['void pen_hex ( long long n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void pen_hex ( long long n ) {
361,Check if row | C ++ implementation to check if row - major order traversal of matrix is palindrome or not ; Function to check if row - major order traversal of the matrix is is palindrome ; Loop to check if the matrix is matrix is palindrome or not ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } int main ( ) { int n = 3 , m = 3 ; int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { cout << "" YES "" << endl ; } else { cout << "" NO "" << endl ; } }",Check if row.,"#include <bits/stdc++.h>   using namespace std ; bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } int main ( ) { int n = 3 , m = 3 ; int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { cout << "" YES "" << endl ; } else { cout << "" NO "" << endl ; } }","['bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) {"
364,"Count numbers from range whose prime factors are only 2 and 3 using Arrays | Set 2 | C ++ program to count the elements in the range [ L , R ] whose prime factors are only 2 and 3. ; Function which will calculate the elements in the given range ; Store the current power of 2 ; Store the current power of 3 ; power23 [ ] will store pairwise product of elements of power2 and power3 that are <= r ; Insert in power23 ] [ ] only if mul <= r ; Store the required answer ; Print the result ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void calc_ans ( ll l , ll r ) { vector < ll > power2 , power3 ; ll mul2 = 1 ; while ( mul2 <= r ) { power2 . push_back ( mul2 ) ; mul2 *= 2 ; } ll mul3 = 1 ; while ( mul3 <= r ) { power3 . push_back ( mul3 ) ; mul3 *= 3 ; } vector < ll > power23 ; for ( int x = 0 ; x < power2 . size ( ) ; x ++ ) { for ( int y = 0 ; y < power3 . size ( ) ; y ++ ) { ll mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ; if ( mul <= r ) power23 . push_back ( mul ) ; } } ll ans = 0 ; for ( ll x : power23 ) { if ( x >= l && x <= r ) ans ++ ; } cout << ans << endl ; } int main ( ) { ll l = 1 , r = 10 ; calc_ans ( l , r ) ; return 0 ; }",Count numbers from range whose prime factors are only 2 and 3 using Arrays.,"#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   void calc_ans ( ll l , ll r ) { vector < ll > power2 , power3 ; ll mul2 = 1 ; while ( mul2 <= r ) { power2 . push_back ( mul2 ) ; mul2 *= 2 ; } ll mul3 = 1 ; while ( mul3 <= r ) { power3 . push_back ( mul3 ) ; mul3 *= 3 ; } vector < ll > power23 ; for ( int x = 0 ; x < power2 . size ( ) ; x ++ ) { for ( int y = 0 ; y < power3 . size ( ) ; y ++ ) { ll mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ; if ( mul <= r ) power23 . push_back ( mul ) ; } } ll ans = 0 ; for ( ll x : power23 ) { if ( x >= l && x <= r ) ans ++ ; } cout << ans << endl ; } int main ( ) { ll l = 1 , r = 10 ; calc_ans ( l , r ) ; return 0 ; }","['void calc_ans ( ll l , ll r ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define ll  long long int   void calc_ans ( ll l , ll r ) {"
366,Find most significant bit of a number X in base Y | C ++ Program to find the first digit of X in base Y ; Function to find the first digit of X in base Y ; calculating number of digits of x in base y ; finding first digit of x in base y ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void first_digit ( int x , int y ) { int length = log ( x ) / log ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; } int main ( ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; return 0 ; }",Find most significant bit of a number X in base Y.,"#include <bits/stdc++.h>   using namespace std ; void first_digit ( int x , int y ) { int length = log ( x ) / log ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; } int main ( ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; return 0 ; }","['void first_digit ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void first_digit ( int x , int y ) {"
367,Curzon Numbers | C ++ implementation of the approach ; Function to check if a number is a Curzon number or not ; Find 2 ^ N + 1 ; Find 2 * N + 1 ; Check for divisibility ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkIfCurzonNumber ( int N ) { long int powerTerm , productTerm ; powerTerm = pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; } int main ( ) { long int N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; return 0 ; }",Curzon Numbers.,"#include <bits/stdc++.h>   using namespace std ; void checkIfCurzonNumber ( int N ) { long int powerTerm , productTerm ; powerTerm = pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; } int main ( ) { long int N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; return 0 ; }","['void checkIfCurzonNumber ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void checkIfCurzonNumber ( int N ) {
368,Minimum count of numbers required ending with 7 to sum as a given number | C ++ implementation of the approach ; Function to return the count of minimum numbers ending with 7 required such that the sum of these numbers is n ; hasharr [ i ] will store the minimum numbers ending with 7 so that it sums to number ending with digit i ; Its always possible to write numbers > 69 to write as numbers ending with 7 ; If the number is atleast equal to the sum of minimum numbers ending with 7 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TEN = 10 ; int minCount ( int n ) { int hasharr [ TEN ] = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % TEN ] ; else { if ( n >= hasharr [ n % TEN ] * 7 ) return ( hasharr [ n % TEN ] ) ; else return -1 ; } } int main ( ) { int n = 38 ; cout << minCount ( n ) ; return 0 ; }",Minimum count of numbers required ending with 7 to sum as a given number.,"#include <bits/stdc++.h>   using namespace std ; const int TEN = 10 ; int minCount ( int n ) { int hasharr [ TEN ] = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % TEN ] ; else { if ( n >= hasharr [ n % TEN ] * 7 ) return ( hasharr [ n % TEN ] ) ; else return -1 ; } } int main ( ) { int n = 38 ; cout << minCount ( n ) ; return 0 ; }","['int minCount ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; const int TEN = 10 ; int minCount ( int n ) {
369,Program to print modified Binary triangle pattern | C ++ implementation to print the modified binary triangle pattern ; Function to print the modified binary pattern ; Loop to traverse the rows ; Loop to traverse the numbers in each row ; Check if j is 1 or i In either case print 1 ; Else print 0 ; Change the cursor to next line after each row ; Driver Code ; Function Call,#include <bits/stdc++.h> NEW_LINE using namespace std ; void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) cout << 1 ; else cout << 0 ; } cout << endl ; } } int main ( ) { int n = 7 ; modifiedBinaryPattern ( n ) ; },Program to print modified Binary triangle pattern.,#include <bits/stdc++.h>   using namespace std ; void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) cout << 1 ; else cout << 0 ; } cout << endl ; } } int main ( ) { int n = 7 ; modifiedBinaryPattern ( n ) ; },"['void modifiedBinaryPattern ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void modifiedBinaryPattern ( int n ) {
370,Find the real and imaginary part of a Complex number | C ++ program to find the real and imaginary parts of a Complex Number ; Function to find real and imaginary parts of a complex number ; string length stored in variable l ; variable for the index of the separator ; Storing the index of ' + ' ; else storing the index of ' - ' ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRealAndImag ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - i - 2 ) ; cout << "" Real ▁ part : ▁ "" << real << "" STRNEWLINE "" ; cout << "" Imaginary ▁ part : ▁ "" << imaginary << "" STRNEWLINE "" ; } int main ( ) { string s = ""3 + 4i "" ; findRealAndImag ( s ) ; return 0 ; }",Find the real and imaginary part of a Complex number.,"#include <bits/stdc++.h>   using namespace std ; void findRealAndImag ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - i - 2 ) ; cout << "" Real ▁ part : ▁ "" << real << "" STRNEWLINE "" ; cout << "" Imaginary ▁ part : ▁ "" << imaginary << "" STRNEWLINE "" ; } int main ( ) { string s = ""3 + 4i "" ; findRealAndImag ( s ) ; return 0 ; }","['void findRealAndImag ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void findRealAndImag ( string s ) {
373,Delete all odd frequency elements from an Array | C ++ program to removes all odd frequency elements from an Array ; Function that removes the elements which have odd frequencies in the array ; Create a map to store the frequency of each element ; Remove the elements which have odd frequencies ; If the element has odd frequency then skip ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void remove ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( m [ arr [ i ] ] & 1 ) ) continue ; cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { int arr [ ] = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; remove ( arr , n ) ; return 0 ; }",Delete all odd frequency elements from an Array.,"#include <bits/stdc++.h>   using namespace std ; void remove ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( m [ arr [ i ] ] & 1 ) ) continue ; cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { int arr [ ] = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; remove ( arr , n ) ; return 0 ; }","['void remove ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void remove ( int arr [ ] , int n ) {"
374,Maximize the first element of the array such that average remains constant | C ++ implementation of to maximize the first element of the array such that average of the array remains constant ; Maximum value of the first array element that can be attained ; Variable to store the sum ; Loop to find the sum of array ; Desired maximum value ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getmax ( arr , arr_size , x ) ; return 0 ; }",Maximize the first element of the array such that average remains constant.,"#include <bits/stdc++.h>   using namespace std ; void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getmax ( arr , arr_size , x ) ; return 0 ; }","['void getmax ( int arr [ ] , int n , int x ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void getmax ( int arr [ ] , int n , int x ) {"
375,"Minimum length of the shortest path of a triangle | C ++ program to illustrate the above problem ; function to get the minimum length of the shorter side of the triangle ; traversing through each points on the plane ; if sum of a points is greater than the previous one , the maximum gets replaced ; print the length ; Driver code ; initialize the number of points ; points on the plane","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << "" Length ▁ - > ▁ "" << answer << endl ; cout << "" Path ▁ - > ▁ "" << "" ( ▁ 1 , ▁ "" << answer << "" ▁ ) "" << "" and ▁ ( ▁ "" << answer << "" , ▁ 1 ▁ ) "" ; } int main ( ) { int n = 4 ; int x [ n ] = { 1 , 4 , 2 , 1 } ; int y [ n ] = { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; return 0 ; }",Minimum length of the shortest path of a triangle.,"#include <bits/stdc++.h>   using namespace std ; #define ll  long long   void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << "" Length ▁ - > ▁ "" << answer << endl ; cout << "" Path ▁ - > ▁ "" << "" ( ▁ 1 , ▁ "" << answer << "" ▁ ) "" << "" and ▁ ( ▁ "" << answer << "" , ▁ 1 ▁ ) "" ; } int main ( ) { int n = 4 ; int x [ n ] = { 1 , 4 , 2 , 1 } ; int y [ n ] = { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; return 0 ; }","['void shortestLength ( int n , int x [ ] , int y [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define ll  long long   void shortestLength ( int n , int x [ ] , int y [ ] ) {"
376,Intersecting rectangle when bottom | CPP program to find intersection rectangle of given two rectangles . ; function to find intersection rectangle of given two rectangles . ; gives bottom - left point of intersection rectangle ; gives top - right point of intersection rectangle ; no intersection ; gives top - left point of intersection rectangle ; gives bottom - right point of intersection rectangle ; Driver code ; bottom - left and top - right corners of first rectangle ; bottom - left and top - right corners of first rectangle ; function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << "" No ▁ intersection "" ; return ; } cout << "" ( "" << x5 << "" , ▁ "" << y5 << "" ) ▁ "" ; cout << "" ( "" << x6 << "" , ▁ "" << y6 << "" ) ▁ "" ; int x7 = x5 ; int y7 = y6 ; cout << "" ( "" << x7 << "" , ▁ "" << y7 << "" ) ▁ "" ; int x8 = x6 ; int y8 = y5 ; cout << "" ( "" << x8 << "" , ▁ "" << y8 << "" ) ▁ "" ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; return 0 ; }",Intersecting rectangle when bottom.,"#include <bits/stdc++.h>   using namespace std ; void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << "" No ▁ intersection "" ; return ; } cout << "" ( "" << x5 << "" , ▁ "" << y5 << "" ) ▁ "" ; cout << "" ( "" << x6 << "" , ▁ "" << y6 << "" ) ▁ "" ; int x7 = x5 ; int y7 = y6 ; cout << "" ( "" << x7 << "" , ▁ "" << y7 << "" ) ▁ "" ; int x8 = x6 ; int y8 = y5 ; cout << "" ( "" << x8 << "" , ▁ "" << y8 << "" ) ▁ "" ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; return 0 ; }","['void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) {"
378,Minimize cost to modify the Array such that even indices have even elements and vice versa | C ++ program for the above approach ; Function to find the minimum cost to modify the array according to the given criteria ; Count of wrong positioned odd and even elements ; Odd Count ; Even Count ; Swapping Cost ; Decrementing cost after swapping ; Only decrementing cost ; Return the minimum cost of the two cases ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } int cost1 = X * min ( odd_count , even_count ) ; int cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return min ( cost1 + cost2 , cost3 ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumCost ( arr , N , X , Y ) ; return 0 ; }",Minimize cost to modify the Array such that even indices have even elements and vice versa.,"#include <bits/stdc++.h>   using namespace std ; int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } int cost1 = X * min ( odd_count , even_count ) ; int cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return min ( cost1 + cost2 , cost3 ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumCost ( arr , N , X , Y ) ; return 0 ; }","['int minimumCost ( int arr [ ] , int N , int X , int Y ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int minimumCost ( int arr [ ] , int N , int X , int Y ) {"
379,Minimum product of maximum and minimum element over all possible subarrays | C ++ program for the above approach ; Function to find the minimum product of the minimum and maximum among all the possible subarrays ; Stores resultant minimum product ; Traverse the given array arr [ ] ; Min of product of all two pair of consecutive elements ; Return the resultant value ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinMax ( vector < int > & a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . size ( ) ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; } int main ( ) { vector < int > arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; cout << findMinMax ( arr ) ; return 0 ; }",Minimum product of maximum and minimum element over all possible subarrays.,"#include <bits/stdc++.h>   using namespace std ; int findMinMax ( vector < int > & a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . size ( ) ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; } int main ( ) { vector < int > arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; cout << findMinMax ( arr ) ; return 0 ; }","['int findMinMax ( vector < int > & a ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int findMinMax ( vector < int > & a ) {
381,Find Nth item distributed from infinite items of infinite types based on given conditions | C ++ program for the above approach ; Function to find the type of the item given out according to the given rules ; Stores the count of item given out at each step ; Iterate over the days from 1 ; Iterate over type of item on that day ; Count of items given out should exceed n ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; },Find Nth item distributed from infinite items of infinite types based on given conditions.,#include <bits/stdc++.h>   using namespace std ; int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; },"['int itemType ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int itemType ( int n ) {
382,Find the sum of all array elements that are equidistant from two consecutive powers of 2 | C ++ program for the above approach ; Function to print the sum of array elements that are equidistant from two consecutive powers of 2 ; Stores the resultant sum of the array elements ; Traverse the array arr [ ] ; Stores the power of 2 of the number arr [ i ] ; Stores the number which is power of 2 and lesser than or equal to arr [ i ] ; Stores the number which is power of 2 and greater than or equal to arr [ i ] ; If arr [ i ] - LesserValue is the same as LargerValue - arr [ i ] ; Increment res by arr [ i ] ; Return the resultant sum res ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindSum ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = log2 ( arr [ i ] ) ; int LesserValue = pow ( 2 , power ) ; int LargerValue = pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; } int main ( ) { int arr [ ] = { 10 , 24 , 17 , 3 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << FindSum ( arr , N ) ; return 0 ; }",Find the sum of all array elements that are equidistant from two consecutive powers of 2.,"#include <bits/stdc++.h>   using namespace std ; int FindSum ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = log2 ( arr [ i ] ) ; int LesserValue = pow ( 2 , power ) ; int LargerValue = pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; } int main ( ) { int arr [ ] = { 10 , 24 , 17 , 3 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << FindSum ( arr , N ) ; return 0 ; }","['int FindSum ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int FindSum ( int arr [ ] , int N ) {"
383,"Find the person who will finish last | C ++ program for the above approach ; Function to find the person who will finish last ; To keep track of rows and columns having 1 ; Available rows and columns ; Minimum number of choices we have ; If number of choices are odd ; P1 will finish last ; Otherwise , P2 will finish last ; Given matrix","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLast ( int mat [ ] [ 3 ] ) { int m = 3 ; int n = 3 ; set < int > rows ; set < int > cols ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . insert ( i ) ; cols . insert ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = min ( avRows , avCols ) ; if ( choices & 1 ) cout << "" P1"" ; else cout << "" P2"" ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; }",Find the person who will finish last.,"#include <bits/stdc++.h>   using namespace std ; void findLast ( int mat [ ] [ 3 ] ) { int m = 3 ; int n = 3 ; set < int > rows ; set < int > cols ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . insert ( i ) ; cols . insert ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = min ( avRows , avCols ) ; if ( choices & 1 ) cout << "" P1"" ; else cout << "" P2"" ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; }","['void findLast ( int mat [ ] [ 3 ] ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void findLast ( int mat [ ] [ 3 ] ) {
384,"Sum of decimals that are binary representations of first N natural numbers | C ++ program for the above approach ; Function to find the sum of first N natural numbers represented in binary representation ; Stores the resultant sum ; Iterate until the value of N is greater than 0 ; If N is less than 2 ; Store the MSB position of N ; Iterate in the range [ 1 , x ] and add the contribution of the numbers from 1 to ( 2 ^ x - 1 ) ; Update the value of the cur and add ; Add the cur to ans ; Store the remaining numbers ; Add the contribution by MSB by the remaining numbers ; The next iteration will be repeated for 2 ^ x - 1 ; Print the result ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1e9 + 7 ; void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( 1 ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = log2 ( n ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } cout << ans ; } int main ( ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; return 0 ; }",Sum of decimals that are binary representations of first N natural numbers.,"#include <bits/stdc++.h>   using namespace std ; const int MOD = 1e9 + 7 ; void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( 1 ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = log2 ( n ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } cout << ans ; } int main ( ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; return 0 ; }","['void sumOfBinaryNumbers ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; const int MOD = 1e9 + 7 ; void sumOfBinaryNumbers ( int n ) {
385,Nearest Fibonacci Number to N | C ++ program for the above approach ; Function to find the Fibonacci number which is nearest to N ; Base Case ; Initialize the first & second terms of the Fibonacci series ; Store the third term ; Iterate until the third term is less than or equal to num ; Update the first ; Update the second ; Update the third ; Store the Fibonacci number having smaller difference with N ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestFibonacci ( int num ) { if ( num == 0 ) { cout << 0 ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( abs ( third - num ) >= abs ( second - num ) ) ? second : third ; cout << ans ; } int main ( ) { int N = 17 ; nearestFibonacci ( N ) ; return 0 ; }",Nearest Fibonacci Number to N.,"#include <bits/stdc++.h>   using namespace std ; void nearestFibonacci ( int num ) { if ( num == 0 ) { cout << 0 ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( abs ( third - num ) >= abs ( second - num ) ) ? second : third ; cout << ans ; } int main ( ) { int N = 17 ; nearestFibonacci ( N ) ; return 0 ; }","['void nearestFibonacci ( int num ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void nearestFibonacci ( int num ) {
387,Count pairs of equal elements possible by excluding each array element once | C ++ program for the above approach ; Function to count the number of required pairs for every array element ; Initialize a map ; Update the frequency of every element ; Stores the count of pairs ; Traverse the map ; Count the number of ways to select pairs consisting of equal elements only ; Traverse the array ; Print the count for every array element ; Driver code ; Given array ; Size of the array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEqualElementPairs ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; } int total = 0 ; for ( auto i : mp ) { total += ( i . second * ( i . second - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { cout << total - ( mp [ arr [ i ] ] - 1 ) << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEqualElementPairs ( arr , N ) ; }",Count pairs of equal elements possible by excluding each array element once.,"#include <bits/stdc++.h>   using namespace std ; void countEqualElementPairs ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; } int total = 0 ; for ( auto i : mp ) { total += ( i . second * ( i . second - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { cout << total - ( mp [ arr [ i ] ] - 1 ) << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEqualElementPairs ( arr , N ) ; }","['void countEqualElementPairs ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void countEqualElementPairs ( int arr [ ] , int N ) {"
388,Count of Octal numbers upto N digits | C ++ program to find the count of natural octal numbers upto N digits ; Function to return the count of natural octal numbers upto N digits ; Loop to iterate from 1 to N and calculating number of octal numbers for every ' i ' th digit . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; } int main ( ) { int N = 4 ; cout << count ( N ) ; return 0 ; }",Count of Octal numbers upto N digits.,"#include <bits/stdc++.h>   using namespace std ; int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; } int main ( ) { int N = 4 ; cout << count ( N ) ; return 0 ; }","['int count ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int count ( int N ) {
390,Remove minimum numbers from the array to get minimum OR value | C ++ implementation of the approach ; Function to return the minimum deletions to get minimum OR ; To store the minimum element ; Find the minimum element from the array ; To store the frequency of the minimum element ; Find the frequency of the minimum element ; Return the final answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDel ( int * arr , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinDel ( arr , n ) ; return 0 ; }",Remove minimum numbers from the array to get minimum OR value.,"#include <bits/stdc++.h>   using namespace std ; int findMinDel ( int * arr , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinDel ( arr , n ) ; return 0 ; }","['int findMinDel ( int * arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMinDel ( int * arr , int n ) {"
391,Number of subarrays with GCD equal to 1 | C ++ implementation of the approach ; Function to return the required count ; To store the final answer ; To store the GCD starting from index ' i ' ; Loop to find the gcd of each subarray from arr [ i ] to arr [ i ... n - 1 ] ; Increment the count if curr_gcd = 1 ; Return the final answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubArr ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubArr ( arr , n ) ; return 0 ; }",Number of subarrays with GCD equal to 1.,"#include <bits/stdc++.h>   using namespace std ; int cntSubArr ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubArr ( arr , n ) ; return 0 ; }","['int cntSubArr ( int * arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int cntSubArr ( int * arr , int n ) {"
392,Program to print prime numbers from 1 to N . | C ++ program to display first N Prime numbers ; Function to print first N prime numbers ; Declare the variables ; Print display message ; Traverse each number from 1 to N with the help of for loop ; Skip 0 and 1 as they are neither prime nor composite ; flag variable to tell if i is prime or not ; flag = 1 means i is prime and flag = 0 means i is not prime ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_primes_till_N ( int N ) { int i , j , flag ; cout << "" Prime numbers between 1 and "" << N < < "" ▁ are : STRNEWLINE "" ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << "" ▁ "" ; } } int main ( ) { int N = 100 ; print_primes_till_N ( N ) ; return 0 ; }",Program to print prime numbers from 1 to N ..,"#include <bits/stdc++.h>   using namespace std ; void print_primes_till_N ( int N ) { int i , j , flag ; cout << "" Prime numbers between 1 and "" << N < < "" ▁ are : STRNEWLINE "" ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << "" ▁ "" ; } } int main ( ) { int N = 100 ; print_primes_till_N ( N ) ; return 0 ; }","['void print_primes_till_N ( int N ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void print_primes_till_N ( int N ) {
393,Maximize the expression ( A AND X ) * ( B AND X ) | Bit Manipulation | C ++ implementation of the approach ; Function to find X according to the given conditions ; int can have 32 bits ; Temporary ith bit ; Compute ith bit of X according to given conditions Expression below is the direct conclusion from the illustration we had taken earlier ; Add the ith bit of X to X ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  32 NEW_LINE int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; } int main ( ) { int A = 11 , B = 13 ; cout << findX ( A , B ) ; return 0 ; }",Maximize the expression ( A AND X ) * ( B AND X ).,"#include <bits/stdc++.h>   using namespace std ; #define MAX  32   int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; } int main ( ) { int A = 11 , B = 13 ; cout << findX ( A , B ) ; return 0 ; }","['int findX ( int A , int B ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; #define MAX  32   int findX ( int A , int B ) {"
394,Number of subsets whose mean is maximum | C ++ implementation of the approach ; Function to return the count of subsets with the maximum mean ; Maximum value from the array ; To store the number of times maximum element appears in the array ; Return the count of valid subsets ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubSets ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubSets ( arr , n ) ; return 0 ; }",Number of subsets whose mean is maximum.,"#include <bits/stdc++.h>   using namespace std ; int cntSubSets ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubSets ( arr , n ) ; return 0 ; }","['int cntSubSets ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int cntSubSets ( int arr [ ] , int n ) {"
396,Maximum count of common divisors of A and B such that all are co | C ++ implementation of the approach ; Function to return the count of common factors of a and b such that all the elements are co - prime to one another ; GCD of a and b ; Include 1 initially ; Find all the prime factors of the gcd ; If gcd is prime ; Return the required answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCommonFactors ( int a , int b ) { int gcd = __gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd /= i ; } } if ( gcd != 1 ) ans ++ ; return ans ; } int main ( ) { int a = 12 , b = 18 ; cout << maxCommonFactors ( a , b ) ; return 0 ; }",Maximum count of common divisors of A and B such that all are co.,"#include <bits/stdc++.h>   using namespace std ; int maxCommonFactors ( int a , int b ) { int gcd = __gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd /= i ; } } if ( gcd != 1 ) ans ++ ; return ans ; } int main ( ) { int a = 12 , b = 18 ; cout << maxCommonFactors ( a , b ) ; return 0 ; }","['int maxCommonFactors ( int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int maxCommonFactors ( int a , int b ) {"
397,"Find the day number in the current year for the given date | C ++ implementation of the approach ; Function to return the day number of the year for the given date ; Extract the year , month and the day from the date string ; If current year is a leap year and the date given is after the 28 th of February then it must include the 29 th February ; Add the days in the previous months ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 ) ) ; int month = stoi ( date . substr ( 5 , 2 ) ) ; int day = stoi ( date . substr ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; } int main ( ) { string date = ""2019-01-09"" ; cout << dayOfYear ( date ) ; return 0 ; }",Find the day number in the current year for the given date.,"#include <bits/stdc++.h>   using namespace std ; int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 ) ) ; int month = stoi ( date . substr ( 5 , 2 ) ) ; int day = stoi ( date . substr ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; } int main ( ) { string date = ""2019-01-09"" ; cout << dayOfYear ( date ) ; return 0 ; }","['int dayOfYear ( string date ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int dayOfYear ( string date ) {"
398,Find the number of cells in the table contains X | CPP program to find number of cells in the table contains X ; Function to find number of cells in the table contains X ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; } int main ( ) { int n = 6 , x = 12 ; cout << Cells ( n , x ) ; return 0 ; }",Find the number of cells in the table contains X.,"#include <bits/stdc++.h>   using namespace std ; int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; } int main ( ) { int n = 6 , x = 12 ; cout << Cells ( n , x ) ; return 0 ; }","['int Cells ( int n , int x ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int Cells ( int n , int x ) {"
399,Smallest power of 4 greater than or equal to N | C ++ implementation of above approach ; Function to return the smallest power of 4 greater than or equal to n ; If n is itself is a power of 4 then return n ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextPowerOfFour ( int n ) { int x = floor ( sqrt ( sqrt ( n ) ) ) ; if ( pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return pow ( x , 4 ) ; } } int main ( ) { int n = 122 ; cout << nextPowerOfFour ( n ) ; return 0 ; }",Smallest power of 4 greater than or equal to N.,"#include <bits/stdc++.h>   using namespace std ; int nextPowerOfFour ( int n ) { int x = floor ( sqrt ( sqrt ( n ) ) ) ; if ( pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return pow ( x , 4 ) ; } } int main ( ) { int n = 122 ; cout << nextPowerOfFour ( n ) ; return 0 ; }","['int nextPowerOfFour ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int nextPowerOfFour ( int n ) {
400,"Minimum operations required to convert X to Y by multiplying X with the given co | C ++ implementation of the approach ; Function to return the minimum operations required ; Not possible ; To store the greatest power of p that divides d ; While divible by p ; To store the greatest power of q that divides d ; While divible by q ; If d > 1 ; Since , d = p ^ a * q ^ b ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) return -1 ; int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a ++ ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b ++ ; } if ( d != 1 ) return -1 ; return ( a + b ) ; } int main ( ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; cout << minOperations ( x , y , p , q ) ; return 0 ; }",Minimum operations required to convert X to Y by multiplying X with the given co.,"#include <bits/stdc++.h>   using namespace std ; int minOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) return -1 ; int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a ++ ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b ++ ; } if ( d != 1 ) return -1 ; return ( a + b ) ; } int main ( ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; cout << minOperations ( x , y , p , q ) ; return 0 ; }","['int minOperations ( int x , int y , int p , int q ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int minOperations ( int x , int y , int p , int q ) {"
402,"Find the number which when added to the given ratio a : b , the ratio changes to c : d | C ++ implementation of the approach ; Function to return the required number X ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; } int main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; cout << getX ( a , b , c , d ) ; return 0 ; }","Find the number which when added to the given ratio a : b , the ratio changes to c : d.","#include <bits/stdc++.h>   using namespace std ; int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; } int main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; cout << getX ( a , b , c , d ) ; return 0 ; }","['int getX ( int a , int b , int c , int d ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int getX ( int a , int b , int c , int d ) {"
404,Program to find the number of men initially | C ++ implementation of above approach . ; Function to return the number of men initially ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; } int main ( ) { int D = 5 , m = 4 , d = 4 ; cout << numberOfMen ( D , m , d ) ; return 0 ; }",Program to find the number of men initially.,"#include <bits/stdc++.h>   using namespace std ; int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; } int main ( ) { int D = 5 , m = 4 , d = 4 ; cout << numberOfMen ( D , m , d ) ; return 0 ; }","['int numberOfMen ( int D , int m , int d ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int numberOfMen ( int D , int m , int d ) {"
405,Area of triangle formed by the axes of co | C ++ program area of triangle formed by the axes of co - ordinates and a given straight line ; Function to find area ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double area ( double a , double b , double c ) { double d = fabs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; } int main ( ) { double a = -2 , b = 4 , c = 3 ; cout << area ( a , b , c ) ; return 0 ; }",Area of triangle formed by the axes of co.,"#include <bits/stdc++.h>   using namespace std ; double area ( double a , double b , double c ) { double d = fabs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; } int main ( ) { double a = -2 , b = 4 , c = 3 ; cout << area ( a , b , c ) ; return 0 ; }","['double area ( double a , double b , double c ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; double area ( double a , double b , double c ) {"
408,Third last digit in 5 ^ N for given N | C ++ implementation of the above approach ; Function to find the element ; if n < 3 ; If n is even return 6 If n is odd return 1 ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; } int main ( ) { int n = 7 ; cout << findThirdDigit ( n ) ; return 0 ; },Third last digit in 5 ^ N for given N.,#include <bits/stdc++.h>   using namespace std ; int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; } int main ( ) { int n = 7 ; cout << findThirdDigit ( n ) ; return 0 ; },"['int findThirdDigit ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int findThirdDigit ( int n ) {
409,Probability of A winning the match when individual probabilities of hitting the target given | C ++ implementation of the approach ; Function to return the probability of A winning ; p and q store the values of fractions a / b and c / d ; To store the winning probability of A ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } int main ( ) { int a = 1 , b = 2 , c = 10 , d = 11 ; cout << getProbability ( a , b , c , d ) ; return 0 ; }",Probability of A winning the match when individual probabilities of hitting the target given.,"#include <bits/stdc++.h>   using namespace std ; double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } int main ( ) { int a = 1 , b = 2 , c = 10 , d = 11 ; cout << getProbability ( a , b , c , d ) ; return 0 ; }","['double getProbability ( int a , int b , int c , int d ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; double getProbability ( int a , int b , int c , int d ) {"
411,Reduce the array to a single element with the given operation | C ++ implementation of the approach ; Function to return the final element ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; } int main ( ) { int N = 12 ; cout << getFinalElement ( N ) ; return 0 ; },Reduce the array to a single element with the given operation.,#include <bits/stdc++.h>   using namespace std ; long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; } int main ( ) { int N = 12 ; cout << getFinalElement ( N ) ; return 0 ; },"['long getFinalElement ( long n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; long getFinalElement ( long n ) {
415,Sum of Fibonacci Numbers with alternate negatives | C ++ Program to find alternate sum of Fibonacci numbers ; Computes value of first fibonacci numbers and stores their alternate sum ; Initialize result ; Add remaining terms ; For even terms ; For odd terms ; Return the alternating sum ; Driver program to test above function ; Get n ; Find the alternating sum,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; } int main ( ) { int n = 8 ; cout << "" Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ "" << n << "" ▁ terms : ▁ "" << calculateAlternateSum ( n ) << endl ; return 0 ; }",Sum of Fibonacci Numbers with alternate negatives.,"#include <bits/stdc++.h>   using namespace std ; int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; } int main ( ) { int n = 8 ; cout << "" Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ "" << n << "" ▁ terms : ▁ "" << calculateAlternateSum ( n ) << endl ; return 0 ; }","['int calculateAlternateSum ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int calculateAlternateSum ( int n ) {
416,Find nth Term of the Series 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | CPP Program to find Nth term ; Function that will return nth term ; Driver Code ; Get n ; Get the value ; Get n ; Get the value,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; } int main ( void ) { int n = 9 ; cout << getValue ( n ) << endl ; n = 1025 ; cout << getValue ( n ) << endl ; }",Find nth Term of the Series 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ....,"#include <bits/stdc++.h>   using namespace std ; int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; } int main ( void ) { int n = 9 ; cout << getValue ( n ) << endl ; n = 1025 ; cout << getValue ( n ) << endl ; }","['int getValue ( int n ) {', 'int main ( void ) {']",#include <bits/stdc++.h>   using namespace std ; int getValue ( int n ) {
418,Number of values of b such that a = b + ( a ^ b ) | C ++ program to find the number of values of b such that a = b + ( a ^ b ) ; function to return the number of solutions ; check for every possible value ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; },Number of values of b such that a = b + ( a ^ b ).,#include <bits/stdc++.h>   using namespace std ; int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; },"['int countSolutions ( int a ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int countSolutions ( int a ) {
419,Number of values of b such that a = b + ( a ^ b ) | C ++ program to find the number of values of b such that a = b + ( a ^ b ) ; function to return the number of solutions ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = __builtin_popcount ( a ) ; count = pow ( 2 , count ) ; return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; }",Number of values of b such that a = b + ( a ^ b ).,"#include <bits/stdc++.h>   using namespace std ; int countSolutions ( int a ) { int count = __builtin_popcount ( a ) ; count = pow ( 2 , count ) ; return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; }","['int countSolutions ( int a ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int countSolutions ( int a ) {
420,Sum of Area of all possible square inside a rectangle | CPP program to calculate the sum of area of all possible squares that comes inside the rectangle ; Function to calculate the sum of area of all possible squares that comes inside the rectangle ; Square with max size possible ; calculate total square of a given size ; calculate area of squares of a particular size ; total area ; increment size ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } int main ( ) { int l = 4 , b = 3 ; cout << calculateAreaSum ( l , b ) ; return 0 ; }",Sum of Area of all possible square inside a rectangle.,"#include <bits/stdc++.h>   using namespace std ; int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } int main ( ) { int l = 4 , b = 3 ; cout << calculateAreaSum ( l , b ) ; return 0 ; }","['int calculateAreaSum ( int l , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int calculateAreaSum ( int l , int b ) {"
421,Hyperfactorial of a number | / C ++ program to find the hyperfactorial of a number ; function to calculate the value of hyperfactorial ; initialise the val to 1 ; returns the hyperfactorial of a number ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; }",Hyperfactorial of a number.,"#include <bits/stdc++.h>   using namespace std ; #define ll  long long   ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; }","['ll boost_hyperfactorial ( ll num ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define ll  long long   ll boost_hyperfactorial ( ll num ) {
422,Hyperfactorial of a number | C ++ program to find the hyperfactorial of a number using boost libraries ; function to calculate the value of hyperfactorial ; initialise the val to 1 ; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . . ; returns the hyperfactorial of a number ; Driver code,#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace boost :: multiprecision ; using namespace std ; int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; },Hyperfactorial of a number.,#include <bits/stdc++.h>   #include <boost/multiprecision/cpp_int.hpp>   using namespace boost :: multiprecision ; using namespace std ; int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; },"['int1024_t boost_hyperfactorial ( int num ) {', 'int main ( ) {']",#include <bits/stdc++.h>   #include <boost/multiprecision/cpp_int.hpp>   using namespace boost :: multiprecision ; using namespace std ; int1024_t boost_hyperfactorial ( int num ) {
423,Subtract 1 without arithmetic operators | C ++ code to subtract one from a given number ; Flip all the set bits until we find a 1 ; Flip the rightmost 1 bit ; Driver code,#include <iostream> NEW_LINE using namespace std ; int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << subtractOne ( 13 ) << endl ; return 0 ; },Subtract 1 without arithmetic operators.,#include <iostream>   using namespace std ; int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << subtractOne ( 13 ) << endl ; return 0 ; },"['int subtractOne ( int x ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int subtractOne ( int x ) {
424,Find the mean vector of a Matrix | C ++ program to find mean vector of given matrix ; Function to find mean vector ; loop to traverse each column ; to calculate mean of each row ; to store sum of elements of a column ; Drivers code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define rows  3 NEW_LINE #define cols  3 NEW_LINE void meanVector ( int mat [ rows ] [ cols ] ) { cout << "" [ ▁ "" ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << "" ▁ "" ; } cout << "" ] "" ; } int main ( ) { int mat [ rows ] [ cols ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; return 0 ; }",Find the mean vector of a Matrix.,"#include <bits/stdc++.h>   using namespace std ; #define rows  3   #define cols  3   void meanVector ( int mat [ rows ] [ cols ] ) { cout << "" [ ▁ "" ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << "" ▁ "" ; } cout << "" ] "" ; } int main ( ) { int mat [ rows ] [ cols ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; return 0 ; }","['void meanVector ( int mat [ rows ] [ cols ] ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define rows  3   #define cols  3   void meanVector ( int mat [ rows ] [ cols ] ) {
425,"Hoax Number | CPP code to check if a number is a hoax number or not . ; Function to find distinct prime factors of given number n ; n is odd at this point , since it is no longer divisible by 2. So we can test only for the odd numbers , whether they are factors of n ; Check if i is prime factor ; This condition is to handle the case when n is a prime number greater than 2 ; Function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained ; Distinct prime factors of n are being stored in vector pf ; If n is a prime number , it cannot be a hoax number ; Finding sum of digits of distinct prime factors of the number n ; Finding sum of digits in current prime factor pf [ i ] . ; Finding sum of digits of number n ; Comparing the two calculated sums ; Driver Method","#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primeFactors ( int n ) { vector < int > res ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . push_back ( 2 ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . push_back ( i ) ; } } if ( n > 2 ) res . push_back ( n ) ; return res ; } bool isHoax ( int n ) { vector < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; } int main ( ) { int n = 84 ; if ( isHoax ( n ) ) cout << "" A ▁ Hoax ▁ Number STRNEWLINE "" ; else cout << "" Not ▁ a ▁ Hoax ▁ Number STRNEWLINE "" ; return 0 ; }",Hoax Number.,"#include <bits/stdc++.h>   using namespace std ; vector < int > primeFactors ( int n ) { vector < int > res ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . push_back ( 2 ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . push_back ( i ) ; } } if ( n > 2 ) res . push_back ( n ) ; return res ; } bool isHoax ( int n ) { vector < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; } int main ( ) { int n = 84 ; if ( isHoax ( n ) ) cout << "" A ▁ Hoax ▁ Number STRNEWLINE "" ; else cout << "" Not ▁ a ▁ Hoax ▁ Number STRNEWLINE "" ; return 0 ; }","['bool isHoax ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; vector < int > primeFactors ( int n ) { vector < int > res ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . push_back ( 2 ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . push_back ( i ) ; } } if ( n > 2 ) res . push_back ( n ) ; return res ; } bool isHoax ( int n ) {
426,Primality Test | Set 5 ( Using Lucas | C ++ program to find out Lucas - Lehmer series . ; Function to find out first n terms ( considering 4 as 0 th term ) of Lucas - Lehmer series . ; the 0 th term of the series is 4. ; create an array to store the terms . ; compute each term and add it to the array . ; print out the terms one by one . ; Driver program,"#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void LucasLehmer ( int n ) { unsigned long long current_val = 4 ; vector < unsigned long long > series ; series . push_back ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . push_back ( current_val ) ; } for ( int i = 0 ; i <= n ; i ++ ) cout << "" Term ▁ "" << i << "" : ▁ "" << series [ i ] << endl ; } int main ( ) { int n = 5 ; LucasLehmer ( n ) ; return 0 ; }",Primality Test.,"#include <iostream>   #include <vector>   using namespace std ; void LucasLehmer ( int n ) { unsigned long long current_val = 4 ; vector < unsigned long long > series ; series . push_back ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . push_back ( current_val ) ; } for ( int i = 0 ; i <= n ; i ++ ) cout << "" Term ▁ "" << i << "" : ▁ "" << series [ i ] << endl ; } int main ( ) { int n = 5 ; LucasLehmer ( n ) ; return 0 ; }","['void LucasLehmer ( int n ) {', 'int main ( ) {']",#include <iostream>   #include <vector>   using namespace std ; void LucasLehmer ( int n ) {
428,Convert to number with digits as 3 and 8 only | CPP to find min operations required to convert into charming number ; function for minimum operation ; remainder and operations count ; count digits not equal to 3 or 8 ; driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; } int main ( ) { long long int num = 234198 ; cout << "" Minimum ▁ Operations ▁ = "" << minOp ( num ) ; return 0 ; }",Convert to number with digits as 3 and 8 only.,"#include <bits/stdc++.h>   using namespace std ; int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; } int main ( ) { long long int num = 234198 ; cout << "" Minimum ▁ Operations ▁ = "" << minOp ( num ) ; return 0 ; }","['int minOp ( long long int num ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int minOp ( long long int num ) {
432,Sum of the multiples of two numbers below N | C ++ program to find the sum of all the integers below N which are multiples of either A or B ; Function to return the sum of all the integers below N which are multiples of either A or B ; If i is a multiple of a or b ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } int main ( ) { int n = 10 , a = 3 , b = 5 ; cout << findSum ( n , a , b ) ; return 0 ; }",Sum of the multiples of two numbers below N.,"#include <iostream>   using namespace std ; int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } int main ( ) { int n = 10 , a = 3 , b = 5 ; cout << findSum ( n , a , b ) ; return 0 ; }","['int findSum ( int n , int a , int b ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; int findSum ( int n , int a , int b ) {"
433,Subtract 1 without arithmetic operators | Driver program to test above functions,"#include <stdio.h> NEW_LINE int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } int main ( ) { printf ( "" % d "" , subtractOne ( 13 ) ) ; return 0 ; }",Subtract 1 without arithmetic operators.,"#include <stdio.h>   int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } int main ( ) { printf ( "" % d "" , subtractOne ( 13 ) ) ; return 0 ; }","['int subtractOne ( int x ) {', 'int main ( ) {']",#include <stdio.h>   int subtractOne ( int x ) {
434,Pell Number | Pell Number Series using Recursion in C ++ ; calculate nth pell number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } int main ( ) { int n = 4 ; cout << "" ▁ "" << pell ( n ) ; return 0 ; }",Pell Number.,"#include <bits/stdc++.h>   using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } int main ( ) { int n = 4 ; cout << "" ▁ "" << pell ( n ) ; return 0 ; }","['int pell ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int pell ( int n ) {
435,Finding LCM of more than two ( or array ) numbers without using GCD | C ++ program to find LCM of array without using GCD . ; Returns LCM of arr [ 0. . n - 1 ] ; Find the maximum value in arr [ ] ; Initialize result ; Find all factors that are present in two or more array elements . int x = 2 ; Current factor . ; To store indexes of all array elements that are divisible by x . ; If there are 2 or more array elements that are divisible by x . ; Reduce all array elements divisible by x . ; Then multiply all reduced array elements ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long int LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; unsigned long long int res = 1 ; while ( x <= max_num ) { vector < int > indexes ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push_back ( j ) ; if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( int i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LCM ( arr , n ) << "" STRNEWLINE "" ; return 0 ; }",Finding LCM of more than two ( or array ) numbers without using GCD.,"#include <bits/stdc++.h>   using namespace std ; unsigned long long int LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; unsigned long long int res = 1 ; while ( x <= max_num ) { vector < int > indexes ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push_back ( j ) ; if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( int i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LCM ( arr , n ) << "" STRNEWLINE "" ; return 0 ; }","['int LCM ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; unsigned long long int LCM ( int arr [ ] , int n ) {"
436,Find politeness of a number | CPP program for the above approach ; Function to find politeness ; sqrt ( 2 * n ) as max length will be when the sum starts from 1 which follows the equation n ^ 2 - n - ( 2 * sum ) = 0 ; Driver program to test above function,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; } int main ( ) { int n = 90 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; n = 15 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; return 0 ; }",Find politeness of a number.,"#include <iostream>   #include <math.h>   using namespace std ; int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; } int main ( ) { int n = 90 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; n = 15 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; return 0 ; }","['int politness ( int n ) {', 'int main ( ) {']",#include <iostream>   #include <math.h>   using namespace std ; int politness ( int n ) {
438,"k | Program to print kth prime factor ; A function to generate prime factors of a given number n and return k - th prime factor ; Find the number of 2 's that divide k ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , store i and divide n ; This condition is to handle the case where n is a prime number greater than 2 ; Driver Program","# include <bits/stdc++.h> NEW_LINE using namespace std ; int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return -1 ; } int main ( ) { int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; return 0 ; }",k.,"# include <bits/stdc++.h>   using namespace std ; int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return -1 ; } int main ( ) { int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; return 0 ; }","['int kPrimeFactor ( int n , int k ) {', 'int main ( ) {']","# include <bits/stdc++.h>   using namespace std ; int kPrimeFactor ( int n , int k ) {"
440,"Find sum of divisors of all the divisors of a natural number | C ++ program to find sum of divisors of all the divisors of a natural number . ; Returns sum of divisors of all the divisors of n ; Calculating powers of prime factors and storing them in a map mp [ ] . ; If n is a prime number ; For each prime factor , calculating ( p ^ ( a + 1 ) - 1 ) / ( p - 1 ) and adding it to answer . ; Driven Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDivisorsOfDivisors ( int n ) { map < int , int > mp ; for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count ) mp [ j ] = count ; } if ( n != 1 ) mp [ n ] = 1 ; int ans = 1 ; for ( auto it : mp ) { int pw = 1 ; int sum = 0 ; for ( int i = it . second + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw *= it . first ; } ans *= sum ; } return ans ; } int main ( ) { int n = 10 ; cout << sumDivisorsOfDivisors ( n ) ; return 0 ; }",Find sum of divisors of all the divisors of a natural number.,"#include <bits/stdc++.h>   using namespace std ; int sumDivisorsOfDivisors ( int n ) { map < int , int > mp ; for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count ) mp [ j ] = count ; } if ( n != 1 ) mp [ n ] = 1 ; int ans = 1 ; for ( auto it : mp ) { int pw = 1 ; int sum = 0 ; for ( int i = it . second + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw *= it . first ; } ans *= sum ; } return ans ; } int main ( ) { int n = 10 ; cout << sumDivisorsOfDivisors ( n ) ; return 0 ; }","['int sumDivisorsOfDivisors ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int sumDivisorsOfDivisors ( int n ) {
441,Nearest prime less than given number n | C ++ program for the above approach ; Function to return nearest prime number ; All prime numbers are odd except two ; It will only be executed when n is 3 ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int prime ( int n ) { if ( n & 1 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > sqrt ( i ) ) return i ; } return 2 ; } int main ( ) { int n = 17 ; cout << prime ( n ) ; return 0 ; }",Nearest prime less than given number n.,"#include <bits/stdc++.h>   using namespace std ; int prime ( int n ) { if ( n & 1 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > sqrt ( i ) ) return i ; } return 2 ; } int main ( ) { int n = 17 ; cout << prime ( n ) ; return 0 ; }","['int prime ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int prime ( int n ) {
442,"Find Recurring Sequence in a Fraction | C ++ program to find repeating sequence in a fraction ; This function returns repeating sequence of a fraction . If repeating sequence doesn 't exits, then returns empty string ; Create a map to store already seen remainders remainder is used as key and its position in result is stored as value . Note that we need position for cases like 1 / 6. In this case , the recurring sequence doesn 't start from first  remainder. ; Find first remainder ; Keep finding remainder until either remainder becomes 0 or repeats ; Store this remainder ; Multiply remainder with 10 ; Append rem / denr to result ; Update remainder ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; string fractionToDecimal ( int numr , int denr ) { map < int , int > mp ; mp . clear ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denr ; res += to_string ( res_part ) ; rem = rem % denr ; } return ( rem == 0 ) ? "" "" : res . substr ( mp [ rem ] ) ; } int main ( ) { int numr = 50 , denr = 22 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == "" "" ) cout << "" No ▁ recurring ▁ sequence "" ; else cout << "" Recurring ▁ sequence ▁ is ▁ "" << res ; return 0 ; }",Find Recurring Sequence in a Fraction.,"#include <bits/stdc++.h>   using namespace std ; string fractionToDecimal ( int numr , int denr ) { map < int , int > mp ; mp . clear ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denr ; res += to_string ( res_part ) ; rem = rem % denr ; } return ( rem == 0 ) ? "" "" : res . substr ( mp [ rem ] ) ; } int main ( ) { int numr = 50 , denr = 22 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == "" "" ) cout << "" No ▁ recurring ▁ sequence "" ; else cout << "" Recurring ▁ sequence ▁ is ▁ "" << res ; return 0 ; }","['string fractionToDecimal ( int numr , int denr ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; string fractionToDecimal ( int numr , int denr ) {"
444,Euler 's criterion (Check if square root under modulo p exists) | A Simple C ++ program to check if square root of a number under modulo p exists or not ; Returns true if square root of n under modulo p exists ; One by one check all numbers from 2 to p - 1 ; Driver program to test,"#include <iostream> NEW_LINE using namespace std ; bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } int main ( ) { int p = 7 ; int n = 2 ; squareRootExists ( n , p ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Euler 's criterion (Check if square root under modulo p exists).,"#include <iostream>   using namespace std ; bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } int main ( ) { int p = 7 ; int n = 2 ; squareRootExists ( n , p ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }","['bool squareRootExists ( int n , int p ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; bool squareRootExists ( int n , int p ) {"
445,"Legendre 's formula (Given p and n, find the largest x such that p^x divides n!) | C ++ program to find largest x such that p * x divides n ! ; Returns largest power of p that divides n ! ; Initialize result ; Calculate x = n / p + n / ( p ^ 2 ) + n / ( p ^ 3 ) + ... . ; Driver code","#include <iostream> NEW_LINE using namespace std ; int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; } int main ( ) { int n = 10 , p = 3 ; cout << "" The ▁ largest ▁ power ▁ of ▁ "" << p << "" ▁ that ▁ divides ▁ "" << n << "" ! ▁ is ▁ "" << largestPower ( n , p ) << endl ; return 0 ; }","Legendre 's formula (Given p and n, find the largest x such that p^x divides n!).","#include <iostream>   using namespace std ; int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; } int main ( ) { int n = 10 , p = 3 ; cout << "" The ▁ largest ▁ power ▁ of ▁ "" << p << "" ▁ that ▁ divides ▁ "" << n << "" ! ▁ is ▁ "" << largestPower ( n , p ) << endl ; return 0 ; }","['int largestPower ( int n , int p ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; int largestPower ( int n , int p ) {"
446,Program for factorial of a number | C ++ program to find factorial of given number ; single line to find factorial ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << "" Factorial ▁ of ▁ "" << num << "" ▁ is ▁ "" << factorial ( num ) ; return 0 ; }",Program for factorial of a number.,"#include <iostream>   using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << "" Factorial ▁ of ▁ "" << num << "" ▁ is ▁ "" << factorial ( num ) ; return 0 ; }","['int factorial ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int factorial ( int n ) {
449,"Sum of Bitwise AND of each array element with the elements of another array | C ++ program for the above approach ; Function to compute the AND sum for each element of an array ; Declaring an array of size 32 for storing the count of each bit ; Traverse the array arr2 [ ] and store the count of a bit in frequency array ; Current bit position ; While num is greater than 0 ; Checks if ith bit is set or not ; Increment the count of bit by one ; Increment the bit position by one ; Right shift the num by one ; Traverse in the arr2 [ ] ; Store the ith bit value ; Total required sum ; Traverse in the range [ 0 , 31 ] ; Checks if current bit is set ; Increment the bitwise sum by frequency [ bit_position ] * value_at_that_bit ; ; Right shift num by one ; Left shift vale_at_that_bit by one ; Print the sum obtained for ith number in arr1 [ ] ; Driver Code ; Given arr1 [ ] ; Given arr2 [ ] ; Size of arr1 [ ] ; Size of arr2 [ ] ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_AND_sum << ' ▁ ' ; } return ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; return 0 ; }",Sum of Bitwise AND of each array element with the elements of another array.,"#include <bits/stdc++.h>   using namespace std ; void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_AND_sum << ' ▁ ' ; } return ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; return 0 ; }","['void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) {"
450,"Turn off the rightmost set bit | Set 2 | C ++ program to unset the rightmost set bit ; Unsets the rightmost set bit of n and returns the result ; Checking whether bit position is set or not ; If bit position is found set , we flip this bit by xoring given number and number with bit position set ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1ll << bit ) ; break ; } } cout << "" The ▁ number ▁ after ▁ unsetting ▁ the "" ; cout << "" ▁ rightmost ▁ set ▁ bit ▁ "" << n ; } int main ( ) { int N = 12 ; FlipBits ( N ) ; return 0 ; }",Turn off the rightmost set bit.,"#include <bits/stdc++.h>   using namespace std ; void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1ll << bit ) ; break ; } } cout << "" The ▁ number ▁ after ▁ unsetting ▁ the "" ; cout << "" ▁ rightmost ▁ set ▁ bit ▁ "" << n ; } int main ( ) { int N = 12 ; FlipBits ( N ) ; return 0 ; }","['void FlipBits ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void FlipBits ( int n ) {
451,"Bitwise AND of all the odd numbers from 1 to N | C ++ implementation of the approach ; Function to return the bitwise AND of all the odd integers from the range [ 1 , n ] ; Initialize result to 1 ; Starting from 3 , bitwise AND all the odd integers less than or equal to n ; Driver code",#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; },Bitwise AND of all the odd numbers from 1 to N.,#include <iostream>   using namespace std ; int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; },"['int bitwiseAndOdd ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int bitwiseAndOdd ( int n ) {
452,"Bitwise AND of all the odd numbers from 1 to N | C ++ implementation of the approach ; Function to return the bitwise AND of all the odd integers from the range [ 1 , n ] ; Driver code",#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { return 1 ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; },Bitwise AND of all the odd numbers from 1 to N.,#include <iostream>   using namespace std ; int bitwiseAndOdd ( int n ) { return 1 ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; },"['int bitwiseAndOdd ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int bitwiseAndOdd ( int n ) {
453,Reverse actual bits of the given number | C ++ implementation to reverse bits of a number ; function to reverse bits of a number ; traversing bits of ' n ' from the right ; bitwise left shift ' rev ' by 1 ; if current bit is '1' ; bitwise right shift ' n ' by 1 ; required number ; Driver program to test above,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int reverseBits ( unsigned int n ) { unsigned int rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( n & 1 == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } int main ( ) { unsigned int n = 11 ; cout << reverseBits ( n ) ; return 0 ; },Reverse actual bits of the given number.,#include <bits/stdc++.h>   using namespace std ; unsigned int reverseBits ( unsigned int n ) { unsigned int rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( n & 1 == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } int main ( ) { unsigned int n = 11 ; cout << reverseBits ( n ) ; return 0 ; },"['int reverseBits ( unsigned int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; unsigned int reverseBits ( unsigned int n ) {
454,"Ways to split array into two groups of same XOR value | CPP Program to count number of ways to split array into two groups such that each group has equal XOR value ; Return the count number of ways to split array into two groups such that each group has equal XOR value . ; We can split only if XOR is 0. Since XOR of all is 0 , we can consider all subsets as one group . ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countgroup ( a , n ) << endl ; return 0 ; }",Ways to split array into two groups of same XOR value.,"#include <bits/stdc++.h>   using namespace std ; int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countgroup ( a , n ) << endl ; return 0 ; }","['int countgroup ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int countgroup ( int a [ ] , int n ) {"
455,Extract ' k ' bits from a given position in a number . | C ++ program to extract k bits from a given position . ; Function to extract k bits from p position and returns the extracted value as integer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } int main ( ) { int number = 171 , k = 5 , p = 2 ; cout << "" The ▁ extracted ▁ number ▁ is ▁ "" << bitExtracted ( number , k , p ) ; return 0 ; }",Extract ' k ' bits from a given position in a number ..,"#include <bits/stdc++.h>   using namespace std ; int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } int main ( ) { int number = 171 , k = 5 , p = 2 ; cout << "" The ▁ extracted ▁ number ▁ is ▁ "" << bitExtracted ( number , k , p ) ; return 0 ; }","['int bitExtracted ( int number , int k , int p ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int bitExtracted ( int number , int k , int p ) {"
456,Maximize a given unsigned number number by swapping bits at it 's extreme positions. | C ++ program to find maximum number by swapping extreme bits . ; Traverse bits from both extremes ; Obtaining i - th and j - th bits ; Swapping the bits if lesser significant is greater than higher significant bit and accordingly modifying the number ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ull  unsigned long long int NEW_LINE ull findMax ( ull num ) { ull num_copy = num ; int j = sizeof ( unsigned long long int ) * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; } int main ( ) { ull num = 4 ; cout << findMax ( num ) ; return 0 ; },Maximize a given unsigned number number by swapping bits at it 's extreme positions..,#include <bits/stdc++.h>   using namespace std ; #define ull  unsigned long long int   ull findMax ( ull num ) { ull num_copy = num ; int j = sizeof ( unsigned long long int ) * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; } int main ( ) { ull num = 4 ; cout << findMax ( num ) ; return 0 ; },"['ull findMax ( ull num ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; #define ull  unsigned long long int   ull findMax ( ull num ) {
457,"Efficiently check whether n is a multiple of 4 or not | C ++ implementation to efficiently check whether n is a multiple of 4 or not ; function to check whether ' n ' is a multiple of 4 or not ; if true , then ' n ' is a multiple of 4 ; else ' n ' is not a multiple of 4 ; Driver program to test above","#include <bits/stdc++.h> NEW_LINE using namespace std ; string isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return "" Yes "" ; return "" No "" ; } int main ( ) { int n = 16 ; cout << isAMultipleOf4 ( n ) ; return 0 ; }",Efficiently check whether n is a multiple of 4 or not.,"#include <bits/stdc++.h>   using namespace std ; string isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return "" Yes "" ; return "" No "" ; } int main ( ) { int n = 16 ; cout << isAMultipleOf4 ( n ) ; return 0 ; }","['string isAMultipleOf4 ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; string isAMultipleOf4 ( int n ) {
458,"Calculate square of a number without using * , / and pow ( ) | Simple solution to calculate square without using * and pow ( ) ; handle negative input ; Initialize result ; Add n to res n - 1 times ; Driver code","#include <iostream> NEW_LINE using namespace std ; int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; } int main ( ) { for ( int n = 1 ; n <= 5 ; n ++ ) cout << "" n ▁ = ▁ "" << n << "" , ▁ n ^ 2 ▁ = ▁ "" << square ( n ) << endl ; return 0 ; }","Calculate square of a number without using * , / and pow ( ).","#include <iostream>   using namespace std ; int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; } int main ( ) { for ( int n = 1 ; n <= 5 ; n ++ ) cout << "" n ▁ = ▁ "" << n << "" , ▁ n ^ 2 ▁ = ▁ "" << square ( n ) << endl ; return 0 ; }","['int square ( int n ) {', 'int main ( ) {']",#include <iostream>   using namespace std ; int square ( int n ) {
459,Find a point that lies inside exactly K given squares | C ++ implementation of the approach ; Driver Program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int PointInKSquares ( int n , int a [ ] , int k ) { sort ( a , a + n ) ; return a [ n - k ] ; } int main ( ) { int k = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = PointInKSquares ( n , a , k ) ; cout << "" ( "" << x << "" , ▁ "" << x << "" ) "" ; }",Find a point that lies inside exactly K given squares.,"#include <bits/stdc++.h>   using namespace std ; int PointInKSquares ( int n , int a [ ] , int k ) { sort ( a , a + n ) ; return a [ n - k ] ; } int main ( ) { int k = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = PointInKSquares ( n , a , k ) ; cout << "" ( "" << x << "" , ▁ "" << x << "" ) "" ; }","['int PointInKSquares ( int n , int a [ ] , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int PointInKSquares ( int n , int a [ ] , int k ) {"
460,Number of n digit stepping numbers | Space optimized solution | CPP program to calculate the number of n digit stepping numbers . ; function that calculates the answer ; dp [ j ] stores count of i digit stepping numbers ending with digit j . ; To store result of length i - 1 before updating dp [ j ] for length i . ; if n is 1 then answer will be 10. ; Initialize values for count of digits equal to 1. ; Compute values for count of digits more than 1. ; If ending digit is 0 ; If ending digit is 9 ; For other digits . ; stores the final answer ; driver program to test the above function,#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( int n ) { int dp [ 10 ] ; int prev [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } int main ( ) { int n = 2 ; cout << answer ( n ) ; return 0 ; },Number of n digit stepping numbers.,#include <bits/stdc++.h>   using namespace std ; long long answer ( int n ) { int dp [ 10 ] ; int prev [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } int main ( ) { int n = 2 ; cout << answer ( n ) ; return 0 ; },"['long answer ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; long long answer ( int n ) {
464,Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices | c ++ program to Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices ; function to find total number of ways ; No of odd indices in n - digit number ; No of even indices in n - digit number ; No of ways of arranging prime number digits in odd indices ; No of ways of arranging odd number digits in even indices ; returning the total number of ways ; drive code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = pow ( 4 , odd_indices ) ; int arr_even = pow ( 5 , even_indices ) ; return arr_odd * arr_even ; } int main ( ) { int n = 4 ; cout << find_Numb_ways ( n ) << endl ; return 0 ; }",Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices.,"#include <bits/stdc++.h>   using namespace std ; int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = pow ( 4 , odd_indices ) ; int arr_even = pow ( 5 , even_indices ) ; return arr_odd * arr_even ; } int main ( ) { int n = 4 ; cout << find_Numb_ways ( n ) << endl ; return 0 ; }","['int find_Numb_ways ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int find_Numb_ways ( int n ) {
465,Check if a given array is sorted in Spiral manner or not | C ++ program to implement the above approach ; Function to check if the array is spirally sorted or not ; Stores start index of the array ; Stores end index of an array ; If arr [ start ] greater than arr [ end ] ; Update start ; If arr [ end ] greater than arr [ start ] ; Update end ; Driver Code ; Function Call,"#include <iostream> NEW_LINE using namespace std ; bool isSpiralSorted ( int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; } int main ( ) { int arr [ ] = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSpiralSorted ( arr , N ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }",Check if a given array is sorted in Spiral manner or not.,"#include <iostream>   using namespace std ; bool isSpiralSorted ( int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; } int main ( ) { int arr [ ] = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSpiralSorted ( arr , N ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }","['bool isSpiralSorted ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; bool isSpiralSorted ( int arr [ ] , int n ) {"
466,Print all strings from given array that can be typed using keys from a single row of a QWERTY keyboard | C ++ program to implement the above approach ; Function to print all strings that can be typed using keys of a single row in a QWERTY Keyboard ; Stores row number of all possible character of the strings ; Traverse the array ; If current string is not an empty string ; Sets true / false if a string can be typed using keys of a single row or not ; Stores row number of the first character of current string ; Stores length of word ; Traverse current string ; If current character can 't be  typed using keys of rowNum only ; Update flag ; If current string can be typed using keys from rowNum only ; Print the string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWordsSameRow ( vector < string > & arr ) { unordered_map < char , int > mp { { ' q ' , 1 } , { ' w ' , 1 } , { ' e ' , 1 } , { ' r ' , 1 } , { ' t ' , 1 } , { ' y ' , 1 } , { ' u ' , 1 } , { ' o ' , 1 } , { ' p ' , 1 } , { ' i ' , 1 } , { ' a ' , 2 } , { ' s ' , 2 } , { ' d ' , 2 } , { ' f ' , 2 } , { ' g ' , 2 } , { ' h ' , 2 } , { ' j ' , 2 } , { ' k ' , 2 } , { ' l ' , 2 } , { ' z ' , 3 } , { ' x ' , 3 } , { ' c ' , 3 } , { ' v ' , 3 } , { ' b ' , 3 } , { ' n ' , 3 } , { ' m ' , 3 } } ; for ( auto word : arr ) { if ( ! word . empty ( ) ) { bool flag = true ; int rowNum = mp [ tolower ( word [ 0 ] ) ] ; int M = word . length ( ) ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ tolower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { cout << word << "" ▁ "" ; } } } } int main ( ) { vector < string > words = { "" Yeti "" , "" Had "" , "" GFG "" , "" comment "" } ; findWordsSameRow ( words ) ; }",Print all strings from given array that can be typed using keys from a single row of a QWERTY keyboard.,"#include <bits/stdc++.h>   using namespace std ; void findWordsSameRow ( vector < string > & arr ) { unordered_map < char , int > mp { { ' q ' , 1 } , { ' w ' , 1 } , { ' e ' , 1 } , { ' r ' , 1 } , { ' t ' , 1 } , { ' y ' , 1 } , { ' u ' , 1 } , { ' o ' , 1 } , { ' p ' , 1 } , { ' i ' , 1 } , { ' a ' , 2 } , { ' s ' , 2 } , { ' d ' , 2 } , { ' f ' , 2 } , { ' g ' , 2 } , { ' h ' , 2 } , { ' j ' , 2 } , { ' k ' , 2 } , { ' l ' , 2 } , { ' z ' , 3 } , { ' x ' , 3 } , { ' c ' , 3 } , { ' v ' , 3 } , { ' b ' , 3 } , { ' n ' , 3 } , { ' m ' , 3 } } ; for ( auto word : arr ) { if ( ! word . empty ( ) ) { bool flag = true ; int rowNum = mp [ tolower ( word [ 0 ] ) ] ; int M = word . length ( ) ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ tolower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { cout << word << "" ▁ "" ; } } } } int main ( ) { vector < string > words = { "" Yeti "" , "" Had "" , "" GFG "" , "" comment "" } ; findWordsSameRow ( words ) ; }","['void findWordsSameRow ( vector < string > & arr ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; void findWordsSameRow ( vector < string > & arr ) {
467,Count quadruples of given type from given array | C ++ program of the above approach ; Function to find the count of the subsequence of given type ; Stores the count of quadruples ; Generate all possible combinations of quadruples ; Check if 1 st element is equal to 3 rd element ; Check if 2 nd element is equal to 4 th element ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; const int maxN = 2002 ; int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequece ( a , 7 ) ; return 0 ; }",Count quadruples of given type from given array.,"#include <iostream>   using namespace std ; const int maxN = 2002 ; int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequece ( a , 7 ) ; return 0 ; }","['int countSubsequece ( int a [ ] , int n ) {', 'int main ( ) {']","#include <iostream>   using namespace std ; const int maxN = 2002 ; int countSubsequece ( int a [ ] , int n ) {"
468,Smallest character in a string having minimum sum of distances between consecutive repetitions | C ++ program for the above approach ; Function to find the character repeats with minimum distance ; Stores the first and last index ; Initialize with - 1 ; Get the values of last and first occurence ; Update the first index ; Update the last index ; Initialize min ; Get the minimum ; Values must not be same ; Update the minimum distance ; return ans ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; char minDistChar ( string s ) { int n = s . length ( ) ; int * first = new int [ 26 ] ; int * last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == -1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = INT_MAX ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = i + ' a ' ; } } return ans ; } int main ( ) { string str = "" geeksforgeeks "" ; cout << minDistChar ( str ) ; return 0 ; }",Smallest character in a string having minimum sum of distances between consecutive repetitions.,"#include <bits/stdc++.h>   using namespace std ; char minDistChar ( string s ) { int n = s . length ( ) ; int * first = new int [ 26 ] ; int * last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == -1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = INT_MAX ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = i + ' a ' ; } } return ans ; } int main ( ) { string str = "" geeksforgeeks "" ; cout << minDistChar ( str ) ; return 0 ; }","['char minDistChar ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; char minDistChar ( string s ) {
469,"Minimum steps required to reach the end of a matrix | Set 2 | C ++ implementation of the approach ; Function to return the minimum steps required to reach the end of the matrix ; Array to determine whether a cell has been visited before ; Queue for bfs ; Initializing queue ; To store the depth of search ; BFS algorithm ; Current queue size ; Top - most element of queue ; To store index of cell for simplicity ; Base case ; If we reach ( n - 1 , n - 1 ) ; Marking the cell visited ; Pushing the adjacent cells in the queue that can be visited from the current cell ; Driver code","#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int minSteps ( int arr [ ] [ n ] ) { bool v [ n ] [ n ] = { 0 } ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { pair < int , int > y = q . front ( ) ; int i = y . first , j = y . second ; q . pop ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( { i + arr [ i ] [ j ] , j } ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( { i , j + arr [ i ] [ j ] } ) ; } depth ++ ; } return -1 ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << minSteps ( arr ) ; return 0 ; }",Minimum steps required to reach the end of a matrix.,"#include <bits/stdc++.h>   #define n  3   using namespace std ; int minSteps ( int arr [ ] [ n ] ) { bool v [ n ] [ n ] = { 0 } ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { pair < int , int > y = q . front ( ) ; int i = y . first , j = y . second ; q . pop ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( { i + arr [ i ] [ j ] , j } ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( { i , j + arr [ i ] [ j ] } ) ; } depth ++ ; } return -1 ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << minSteps ( arr ) ; return 0 ; }","['int minSteps ( int arr [ ] [ n ] ) {', 'int main ( ) {']",#include <bits/stdc++.h>   #define n  3   using namespace std ; int minSteps ( int arr [ ] [ n ] ) {
470,Largest gap in an array | A C ++ program to find largest gap between two elements in an array . ; function to solve the given problem ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , -4 , -10 , 22 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Largest ▁ gap ▁ is ▁ : ▁ "" << solve ( arr , size ) ; return 0 ; }",Largest gap in an array.,"#include <bits/stdc++.h>   using namespace std ; int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , -4 , -10 , 22 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Largest ▁ gap ▁ is ▁ : ▁ "" << solve ( arr , size ) ; return 0 ; }","['int solve ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int solve ( int a [ ] , int n ) {"
471,Largest gap in an array | A C ++ program to find largest gap between two elements in an array . ; function to solve the given problem ; finding maximum and minimum of an array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -10 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Largest ▁ gap ▁ is ▁ : ▁ "" << solve ( arr , size ) ; return 0 ; }",Largest gap in an array.,"#include <bits/stdc++.h>   using namespace std ; int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -10 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Largest ▁ gap ▁ is ▁ : ▁ "" << solve ( arr , size ) ; return 0 ; }","['int solve ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int solve ( int a [ ] , int n ) {"
472,Print reverse string after removing vowels | CPP Program for removing characters from reversed string where vowels are present in original string ; Function for replacing the string ; initialize a string of length n ; Traverse through all characters of string ; assign the value to string r from last index of string s ; if s [ i ] is a consonant then print r [ i ] ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void replaceOriginal ( string s , int n ) { string r ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { cout << r [ i ] ; } } cout << endl ; } int main ( ) { string s = "" geeksforgeeks "" ; int n = s . length ( ) ; replaceOriginal ( s , n ) ; return 0 ; }",Print reverse string after removing vowels.,"#include <bits/stdc++.h>   using namespace std ; void replaceOriginal ( string s , int n ) { string r ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { cout << r [ i ] ; } } cout << endl ; } int main ( ) { string s = "" geeksforgeeks "" ; int n = s . length ( ) ; replaceOriginal ( s , n ) ; return 0 ; }","['void replaceOriginal ( string s , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void replaceOriginal ( string s , int n ) {"
473,"Check if a string can be made equal to another string by swapping or replacement of characters | C ++ program for the above approach ; Function to find if given strings are same or not ; Base Condition ; Stores frequency of characters of the string str1 and str2 ; Traverse strings str1 & str2 and store frequencies in a [ ] and b [ ] ; Check if both strings have same characters or not ; If a character is present in one string and is not in another string , return false ; Sort the array a [ ] and b [ ] ; Check arrays a and b contain the same frequency or not ; If the frequencies are not the same after sorting ; At this point , str1 can be converted to str2 ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sameStrings ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N != M ) { return false ; } int a [ 256 ] = { 0 } , b [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { a [ str1 [ i ] - ' a ' ] ++ ; b [ str2 [ i ] - ' a ' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } sort ( a , a + 256 ) ; sort ( b , b + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( a [ i ] != b [ i ] ) return false ; } return true ; } int main ( ) { string S1 = "" cabbba "" , S2 = "" abbccc "" ; if ( sameStrings ( S1 , S2 ) ) cout << "" YES "" << endl ; else cout << "" ▁ NO "" << endl ; return 0 ; }",Check if a string can be made equal to another string by swapping or replacement of characters.,"#include <bits/stdc++.h>   using namespace std ; bool sameStrings ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N != M ) { return false ; } int a [ 256 ] = { 0 } , b [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { a [ str1 [ i ] - ' a ' ] ++ ; b [ str2 [ i ] - ' a ' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } sort ( a , a + 256 ) ; sort ( b , b + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( a [ i ] != b [ i ] ) return false ; } return true ; } int main ( ) { string S1 = "" cabbba "" , S2 = "" abbccc "" ; if ( sameStrings ( S1 , S2 ) ) cout << "" YES "" << endl ; else cout << "" ▁ NO "" << endl ; return 0 ; }","['bool sameStrings ( string str1 , string str2 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; bool sameStrings ( string str1 , string str2 ) {"
474,"Reduce given three Numbers by decrementing in Pairs | C ++ program for the above approach ; Function to find the minimum number operations ; Insert the three numbers in array ; Sort the array ; Case 2 ; Case 1 ; Driver Code ; Given A , B , C ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } int main ( ) { int A = 8 , B = 1 , C = 5 ; cout << solution ( A , B , C ) ; return 0 ; }",Reduce given three Numbers by decrementing in Pairs.,"#include <bits/stdc++.h>   using namespace std ; int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } int main ( ) { int A = 8 , B = 1 , C = 5 ; cout << solution ( A , B , C ) ; return 0 ; }","['int solution ( int A , int B , int C ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int solution ( int A , int B , int C ) {"
475,"Search an element in a sorted and rotated array with duplicates | C ++ implementation of the approach ; Function to return the index of the key in arr [ l . . h ] if the key is present otherwise return - 1 ; The tricky case , just update left and right ; If arr [ l ... mid ] is sorted ; As this subarray is sorted , we can quickly check if key lies in any of the halves ; If key does not lie in the first half subarray then divide the other half into two subarrays such that we can quickly check if key lies in the other half ; If arr [ l . . mid ] first subarray is not sorted then arr [ mid ... h ] must be sorted subarray ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) ; } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int key = 3 ; cout << search ( arr , 0 , n - 1 , key ) ; return 0 ; }",Search an element in a sorted and rotated array with duplicates.,"#include <bits/stdc++.h>   using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) ; } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int key = 3 ; cout << search ( arr , 0 , n - 1 , key ) ; return 0 ; }","['int search ( int arr [ ] , int l , int h , int key ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int search ( int arr [ ] , int l , int h , int key ) {"
477,Check if the string contains consecutive letters and each letter occurs exactly once | C ++ program to implement the above approach ; Function to check if the condition holds ; Get the length of the string ; sort the given string ; Iterate for every index and check for the condition ; If are not consecutive ; Driver code ; 1 st example ; 2 nd example,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; } int main ( ) { string str = "" dcef "" ; if ( check ( str ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; str = "" xyza "" ; if ( check ( str ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; return 0 ; }",Check if the string contains consecutive letters and each letter occurs exactly once.,"#include <bits/stdc++.h>   using namespace std ; bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; } int main ( ) { string str = "" dcef "" ; if ( check ( str ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; str = "" xyza "" ; if ( check ( str ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; return 0 ; }","['bool check ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; bool check ( string s ) {
478,Smallest subset with sum greater than all other elements | CPP program to find minimum number of elements such that their sum is greater than sum of remaining elements of the array . ; function to find minimum elements needed . ; calculating HALF of array sum ; sort the array in descending order . ; current sum greater than sum ; Driver function,"#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minElements ( arr , n ) << endl ; return 0 ; }",Smallest subset with sum greater than all other elements.,"#include <bits/stdc++.h>   #include <string.h>   using namespace std ; int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minElements ( arr , n ) << endl ; return 0 ; }","['int minElements ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h>   #include <string.h>   using namespace std ; int minElements ( int arr [ ] , int n ) {"
479,"Minimum increment and decrement by K of each pair elements required to make all array elements equal | C ++ program for the above approach ; Function to check if its possible to make all array elements equal or not ; Stores the sum of the array ; Traverse the array ; If sum is divisible by N ; Otherwise , not possible to make all array elements equal ; Driver Code ; Given array ; Size of the array","#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrayElementEqual ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum % N == 0 ) { cout << "" Yes "" ; } else { cout << "" No "" << endl ; } } int main ( ) { int arr [ ] = { 1 , 5 , 6 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; arrayElementEqual ( arr , N ) ; }",Minimum increment and decrement by K of each pair elements required to make all array elements equal.,"#include <bits/stdc++.h>   using namespace std ; void arrayElementEqual ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum % N == 0 ) { cout << "" Yes "" ; } else { cout << "" No "" << endl ; } } int main ( ) { int arr [ ] = { 1 , 5 , 6 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; arrayElementEqual ( arr , N ) ; }","['void arrayElementEqual ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void arrayElementEqual ( int arr [ ] , int N ) {"
480,"Rearrange array to maximize sum of GCD of array elements with their respective indices | C ++ program to implement the above approach ; Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array ; Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements ; Update res ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }",Rearrange array to maximize sum of GCD of array elements with their respective indices.,"#include <bits/stdc++.h>   using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }","['int findMaxValByRearrArr ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) {"
481,"Polygon with maximum sides that can be inscribed in an N | C ++ program for the above approach ; Function to find the maximum sided polygon that can be inscribed ; Base Case ; Return n / 2 if n is even Otherwise , return - 1 ; Driver Code ; Given N ; Function Call",#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumSides ( int n ) { if ( n < 4 ) return -1 ; return n % 2 == 0 ? n / 2 : -1 ; } int main ( ) { int N = 8 ; cout << MaximumSides ( N ) ; return 0 ; },Polygon with maximum sides that can be inscribed in an N.,#include <bits/stdc++.h>   using namespace std ; int MaximumSides ( int n ) { if ( n < 4 ) return -1 ; return n % 2 == 0 ? n / 2 : -1 ; } int main ( ) { int N = 8 ; cout << MaximumSides ( N ) ; return 0 ; },"['int MaximumSides ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int MaximumSides ( int n ) {
482,Mean of array generated by products of all pairs of the given array | C ++ program for the above approach ; Function to find the mean of pair product array of arr [ ] ; Initializing suffix sum array ; Build suffix sum array ; Size of pairProductArray ; Stores sum of pairProductArray ; Store the mean ; Find mean of pairProductArray ; Return the resultant mean ; Driver Code ; Given array arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }",Mean of array generated by products of all pairs of the given array.,"#include <bits/stdc++.h>   using namespace std ; float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }","['float pairProductMean ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; float pairProductMean ( int arr [ ] , int N ) {"
485,Count of substrings formed using a given set of characters only | C ++ program for the above approach ; Function to find the number of substrings that can be formed using given characters ; Boolean array for storing the available characters ; Mark indices of all available characters as 1 ; Initialize lastPos as - 1 ; Initialize ans with the total no of possible substrings ; Traverse the string from left to right ; If the current character is not present in B ; Subtract the total possible substrings ; Update the value of lastpos to current index ; Print the final answer ; Driver Code ; Given String ; Given character array ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberofsubstrings ( string str , int k , char charArray [ ] ) { int N = str . length ( ) ; bool available [ 26 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; } int lastPos = -1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - ' a ' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } cout << ans << endl ; } int main ( ) { string str = "" abcb "" ; int k = 2 ; char charArray [ k ] = { ' a ' , ' b ' } ; numberofsubstrings ( str , k , charArray ) ; return 0 ; }",Count of substrings formed using a given set of characters only.,"#include <bits/stdc++.h>   using namespace std ; void numberofsubstrings ( string str , int k , char charArray [ ] ) { int N = str . length ( ) ; bool available [ 26 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; } int lastPos = -1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - ' a ' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } cout << ans << endl ; } int main ( ) { string str = "" abcb "" ; int k = 2 ; char charArray [ k ] = { ' a ' , ' b ' } ; numberofsubstrings ( str , k , charArray ) ; return 0 ; }","['void numberofsubstrings ( string str , int k , char charArray [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void numberofsubstrings ( string str , int k , char charArray [ ] ) {"
486,Minimum cost to reach a point N from 0 with two different operations allowed | CPP implementation of above approach ; Function to return minimum cost to reach destination ; Initialize cost to 0 ; going backwards until we reach initial position ; if 2 * X jump is better than X + 1 ; if X + 1 jump is better ; return cost ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } int main ( ) { int N = 9 , P = 5 , Q = 1 ; cout << minCost ( N , P , Q ) ; return 0 ; }",Minimum cost to reach a point N from 0 with two different operations allowed.,"#include <bits/stdc++.h>   using namespace std ; int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } int main ( ) { int N = 9 , P = 5 , Q = 1 ; cout << minCost ( N , P , Q ) ; return 0 ; }","['int minCost ( int N , int P , int Q ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int minCost ( int N , int P , int Q ) {"
487,"Number of ways to reach at starting node after travelling through exactly K edges in a complete graph | C ++ program for the above approach ; Function to find number of ways to reach from node 1 to 1 again , after moving exactly K edges ; Initialize a dp [ ] array , where dp [ i ] stores number of ways to reach at a i node ; Initialize the dp array with 0 ; Base Case ; Iterate for the number of edges moved ; Sum will store number of ways to reach all the nodes ; Iterate for every possible state for the current step ; Update the value of the dp array after travelling each edge ; Print dp [ 0 ] as the answer ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberOfWays ( int n , int k ) { int dp [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { int numWays = 0 ; for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } } cout << dp [ 0 ] << endl ; } int main ( ) { int N = 5 , K = 3 ; numberOfWays ( N , K ) ; return 0 ; }",Number of ways to reach at starting node after travelling through exactly K edges in a complete graph.,"#include <bits/stdc++.h>   using namespace std ; void numberOfWays ( int n , int k ) { int dp [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { int numWays = 0 ; for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } } cout << dp [ 0 ] << endl ; } int main ( ) { int N = 5 , K = 3 ; numberOfWays ( N , K ) ; return 0 ; }","['void numberOfWays ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; void numberOfWays ( int n , int k ) {"
488,"Count possible decoding of a given digit sequence with hidden characters | C ++ program for the above approach ; If s [ i ] = = ' * ' there can be 9 possible values of * ; If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 ) ; If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 ) ; If the previous digit is * then all 15 2 - digit characters can be formed ; If s [ i ] != ' * ' ; Adding first in second if s [ i - 1 ] = 1 ; Adding first in second if s [ i - 1 ] = = 2 and s [ i ] <= '6' ; If s [ i - 1 ] = = ' * ' the union of above 2 cases has to be done ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { long first = 1 , second = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { long temp = second ; if ( s [ i ] == ' * ' ) { second = 9 * second ; if ( s [ i - 1 ] == '1' ) second = ( second + 9 * first ) % M ; else if ( s [ i - 1 ] == '2' ) second = ( second + 6 * first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + 15 * first ) % M ; } else { second = s [ i ] != '0' ? second : 0 ; if ( s [ i - 1 ] == '1' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + ( s [ i ] <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; } int main ( ) { string s = "" * "" ; cout << waysOfDecoding ( s ) ; return 0 ; }",Count possible decoding of a given digit sequence with hidden characters.,"#include <bits/stdc++.h>   using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { long first = 1 , second = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { long temp = second ; if ( s [ i ] == ' * ' ) { second = 9 * second ; if ( s [ i - 1 ] == '1' ) second = ( second + 9 * first ) % M ; else if ( s [ i - 1 ] == '2' ) second = ( second + 6 * first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + 15 * first ) % M ; } else { second = s [ i ] != '0' ? second : 0 ; if ( s [ i - 1 ] == '1' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + ( s [ i ] <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; } int main ( ) { string s = "" * "" ; cout << waysOfDecoding ( s ) ; return 0 ; }","['int waysOfDecoding ( string s ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) {
489,Minimum cost of purchasing at least X chocolates | C ++ program for the above approach ; Function to calculate minimum cost of buying least X chocolates ; Base Case ; Include the i - th box ; Exclude the i - th box ; Return the minimum of the above two cases ; Driver Code ; Given array and value of X ; Store the size of the array ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return INT_MAX ; int inc = findMinCost ( arr , X - arr [ i ] . first , n , i + 1 ) ; if ( inc != INT_MAX ) inc += arr [ i ] . second ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return min ( inc , exc ) ; } int main ( ) { pair < int , int > arr [ ] = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = findMinCost ( arr , X , n ) ; if ( ans != INT_MAX ) cout << ans ; else cout << -1 ; return 0 ; }",Minimum cost of purchasing at least X chocolates.,"#include <bits/stdc++.h>   using namespace std ; int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return INT_MAX ; int inc = findMinCost ( arr , X - arr [ i ] . first , n , i + 1 ) ; if ( inc != INT_MAX ) inc += arr [ i ] . second ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return min ( inc , exc ) ; } int main ( ) { pair < int , int > arr [ ] = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = findMinCost ( arr , X , n ) ; if ( ans != INT_MAX ) cout << ans ; else cout << -1 ; return 0 ; }","['int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) {"
490,Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers | C ++ program for above approach ; Function to calculate the probability for the given sum to be equal to sum in N throws of dice ; Base cases ; Driver Code ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } long double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; long double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }",Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers.,"#include <bits/stdc++.h>   using namespace std ; long double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } long double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; long double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }","['double find ( int N , int sum ) {', 'int main ( ) {']","#include <bits/stdc++.h>   using namespace std ; long double find ( int N , int sum ) {"
491,Minimum steps to reduce N to 0 by given operations | C ++ program for the above approach ; Function to find the minimum number to steps to reduce N to 0 ; Base case ; Recursive call to count the minimum steps needed ; Return the answer ; Driver Code ; Given number N ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; } int main ( ) { int N = 6 ; cout << minDays ( N ) ; return 0 ; }",Minimum steps to reduce N to 0 by given operations.,"#include <bits/stdc++.h>   using namespace std ; int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; } int main ( ) { int N = 6 ; cout << minDays ( N ) ; return 0 ; }","['int minDays ( int n ) {', 'int main ( ) {']",#include <bits/stdc++.h>   using namespace std ; int minDays ( int n ) {
