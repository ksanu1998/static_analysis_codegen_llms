id,text,code,question,code_cleaned,functions,code_context
0,Minimum sum possible by removing all occurrences of any array element | C ++ program for the above approach ; Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Driver code ; Input array ; Size of array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int A [ ] , int N ) { map < int , int > mp ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; } int minSum = INT_MAX ; for ( auto it : mp ) { minSum = min ( minSum , sum - ( it . first * it . second ) ) ; } return minSum ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , N ) << "" STRNEWLINE "" ; }",Minimum sum possible by removing all occurrences of any array element.,"#include <bits/stdc++.h> 
 using namespace std ; int minSum ( int A [ ] , int N ) { map < int , int > mp ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; } int minSum = INT_MAX ; for ( auto it : mp ) { minSum = min ( minSum , sum - ( it . first * it . second ) ) ; } return minSum ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , N ) << "" STRNEWLINE "" ; }","['int minSum ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minSum ( int A [ ] , int N ) {
"
1,Maximum difference between a pair of adjacent elements by excluding every element once | C ++ program for the above approach ; Function to calculate maximum difference between adjacent elements excluding every array element once ; Traverse the array ; Stores the maximum diff ; Check for maximum adjacent element ; Exclude current element ; Update maximum difference ; Update previous value ; Append the result into a vector ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = INT_MIN ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = max ( maxi , abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . push_back ( maxi ) ; } for ( auto x : res ) cout << x << "" ▁ "" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }",Maximum difference between a pair of adjacent elements by excluding every element once.,"#include <bits/stdc++.h> 
 using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = INT_MIN ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = max ( maxi , abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . push_back ( maxi ) ; } for ( auto x : res ) cout << x << "" ▁ "" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }","['void maxAdjacent ( int * arr , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maxAdjacent ( int * arr , int N ) {
"
6,Check if it is possible to split given Array into K odd | C ++ implementation to check if it is possible to split array into K subsets with odd sum ; Function to check if array can be split in required K subsets ; Store count of odd numbers ; Check if element is odd ; Check if split is possible ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; if ( checkArray ( n , k , arr ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if it is possible to split given Array into K odd.,"#include <bits/stdc++.h> 
 using namespace std ; bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; if ( checkArray ( n , k , arr ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool checkArray ( int n , int k , int arr [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool checkArray ( int n , int k , int arr [ ] ) {
"
7,"Sum of division of the possible pairs for the given Array | C ++ implementation to compute the sum of division of all the possible pairs for the given array ; Function to compute the sum ; counting frequency of each term and finding maximum among it ; Making cumulative frequency ; Taking the ceil value ; nos . in [ ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans ; Return the final result ; Driver code","#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; int func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ 100005 ] = { 0 } ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] ) { i = ( double ) i ; double j ; ll value = 0 ; double cur = ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = min ( maxx , ( int ) ( ceil ( i * j ) - 1.0 ) ) ; int times = ( freq [ i ] - freq [ i - 1 ] ) , con = j - 0.5 ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( ll ) ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << func ( arr , n ) << endl ; return 0 ; }",Sum of division of the possible pairs for the given Array.,"#include <bits/stdc++.h> 
 #define ll  long long 
 using namespace std ; int func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ 100005 ] = { 0 } ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] ) { i = ( double ) i ; double j ; ll value = 0 ; double cur = ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = min ( maxx , ( int ) ( ceil ( i * j ) - 1.0 ) ) ; int times = ( freq [ i ] - freq [ i - 1 ] ) , con = j - 0.5 ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( ll ) ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << func ( arr , n ) << endl ; return 0 ; }","['int func ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define ll  long long 
 using namespace std ;
 int func ( int arr [ ] , int n ) {
"
8,Count of elements to be inserted to make Array sum twice the XOR of Array | C ++ program to find the count of elements to be inserted to make Array sum twice the XOR of Array ; Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array ; Variable to store the Xor of all the elements ; Variable to store the sum of all elements ; Loop to find the Xor and the sum of the array ; If sum = 2 * Xor ; No need to insert more elements ; We insert one more element which is Sum ; We insert two more elements Sum + Xor and Xor . ; Print the number of elements inserted in the array ; Print the elements that are inserted in the array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { cout << ""0"" << endl ; return ; } if ( Xor == 0 ) { cout << ""1"" << endl ; cout << Sum << endl ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; cout << ""2"" ; cout << num1 << "" ▁ "" << num2 << endl ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; insert_element ( a , n ) ; }",Count of elements to be inserted to make Array sum twice the XOR of Array.,"#include <bits/stdc++.h> 
 using namespace std ; void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { cout << ""0"" << endl ; return ; } if ( Xor == 0 ) { cout << ""1"" << endl ; cout << Sum << endl ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; cout << ""2"" ; cout << num1 << "" ▁ "" << num2 << endl ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; insert_element ( a , n ) ; }","['void insert_element ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void insert_element ( int a [ ] , int n ) {
"
9,Check if roots of a Quadratic Equation are reciprocal of each other or not | C ++ program to check if roots of a Quadratic Equation are reciprocal of each other or not ; Function to check if the roots of a quadratic equation are reciprocal of each other or not ; Driver code,"#include <iostream> NEW_LINE using namespace std ; void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }",Check if roots of a Quadratic Equation are reciprocal of each other or not.,"#include <iostream> 
 using namespace std ; void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }","['void checkSolution ( int a , int b , int c ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void checkSolution ( int a , int b , int c ) {
"
11,Count the numbers which can convert N to 1 using given operation | C ++ program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Iterate through all the integers ; Check if N can be converted to 1 ; Incrementing the count if it can be converted ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; },Count the numbers which can convert N to 1 using given operation.,"#include <bits/stdc++.h> 
 using namespace std ; int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }","['int countValues ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countValues ( int n ) {
"
12,"Find K numbers with sum equal to N and sum of their squares maximized | C ++ program to find K numbers with sum equal to N and the sum of their squares maximized ; Function that prints the required K numbers ; Print 1 , K - 1 times ; Print ( N - K + 1 ) ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << "" ▁ "" ; cout << ( N - K + 1 ) ; } int main ( ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; return 0 ; }",Find K numbers with sum equal to N and sum of their squares maximized.,"#include <bits/stdc++.h> 
 using namespace std ; void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << "" ▁ "" ; cout << ( N - K + 1 ) ; } int main ( ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; return 0 ; }","['void printKNumbers ( int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printKNumbers ( int N , int K ) {
"
13,"Print Nth Stepping or Autobiographical number | C ++ implementation to find NaTMth stepping natural Number ; Function to find the Nth stepping natural number ; Declare the queue ; Enqueue 1 , 2 , ... , 9 in this order ; Perform K operation on queue ; Get the ith Stepping number ; Perform Dequeue from the Queue ; If x mod 10 is not equal to 0 ; then Enqueue 10 x + ( x mod 10 ) - 1 ; Enqueue 10 x + ( x mod 10 ) ; If x mod 10 is not equal to 9 ; then Enqueue 10 x + ( x mod 10 ) + 1 ; Return the dequeued number of the K - th operation as the Nth stepping number ; Driver Code ; initialise K","#include <bits/stdc++.h> NEW_LINE using namespace std ; int NthSmallest ( int K ) { queue < int > Q ; int x ; for ( int i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . front ( ) ; Q . pop ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; } int main ( ) { int N = 16 ; cout << NthSmallest ( N ) << "" STRNEWLINE "" ; return 0 ; }",Print Nth Stepping or Autobiographical number.,"#include <bits/stdc++.h> 
 using namespace std ; int NthSmallest ( int K ) { queue < int > Q ; int x ; for ( int i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . front ( ) ; Q . pop ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; } int main ( ) { int N = 16 ; cout << NthSmallest ( N ) << "" STRNEWLINE "" ; return 0 ; }","['int NthSmallest ( int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int NthSmallest ( int K ) {
"
14,Least number to be added to or subtracted from N to make it a Perfect Square | C ++ implementation of the approach ; Function to return the Least number ; Get the perfect square before and after N ; Check which is nearest to N ; return the result ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } int main ( ) { int n = 14 ; cout << nearest ( n ) << endl ; n = 16 ; cout << nearest ( n ) << endl ; n = 18 ; cout << nearest ( n ) << endl ; return 0 ; },Least number to be added to or subtracted from N to make it a Perfect Square.,"#include <bits/stdc++.h> 
 using namespace std ; int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } int main ( ) { int n = 14 ; cout << nearest ( n ) << endl ; n = 16 ; cout << nearest ( n ) << endl ; n = 18 ; cout << nearest ( n ) << endl ; return 0 ; }","['int nearest ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int nearest ( int n ) {
"
15,Value of Pi ( Î ) up to 50 decimal places | C ++ program to calculate the value of pi up to n decimal places ; Function that prints the value of pi upto N decimal places ; Find value of pi upto using acos ( ) function ; Print value of pi upto N decimal places ; Driver Code ; Function that prints the value of pi,"#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; void printValueOfPi ( int N ) { double pi = 2 * acos ( 0.0 ) ; printf ( "" % . * lf STRNEWLINE "" , N , pi ) ; } int main ( ) { int N = 45 ; printValueOfPi ( N ) ; return 0 ; }",Value of Pi ( Î ) up to 50 decimal places.,"#include "" bits / stdc + + . h "" 
 using namespace std ; void printValueOfPi ( int N ) { double pi = 2 * acos ( 0.0 ) ; printf ( "" % . * lf STRNEWLINE "" , N , pi ) ; } int main ( ) { int N = 45 ; printValueOfPi ( N ) ; return 0 ; }","['void printValueOfPi ( int N ) {', 'int main ( ) {']","#include "" bits / stdc + + . h "" 
 using namespace std ;
 void printValueOfPi ( int N ) {
"
19,"Angle between 3 given vertices in a n | C ++ implementation of the approach ; Function that checks whether given angle can be created using any 3 sides ; Initialize x and y ; Calculate the number of vertices between i and j , j and k ; Calculate the angle subtended at the circumference ; Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } int main ( ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; cout << calculate_angle ( n , a1 , a2 , a3 ) ; return 0 ; }",Angle between 3 given vertices in a n.,"#include <bits/stdc++.h> 
 using namespace std ; double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } int main ( ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; cout << calculate_angle ( n , a1 , a2 , a3 ) ; return 0 ; }","['double calculate_angle ( int n , int i , int j , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double calculate_angle ( int n , int i , int j , int k ) {
"
20,Loss when two items are sold at same price and same percentage profit / loss | C ++ implementation of above approach . ; Function that will find loss ; Driver Code ; Calling Function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) / float ( 100 * 100 - P * P ) ; cout << "" Loss ▁ = ▁ "" << loss ; } int main ( ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; return 0 ; }",Loss when two items are sold at same price and same percentage profit / loss.,"#include <bits/stdc++.h> 
 using namespace std ; void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) / float ( 100 * 100 - P * P ) ; cout << "" Loss ▁ = ▁ "" << loss ; } int main ( ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; return 0 ; }","['void Loss ( int SP , int P ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void Loss ( int SP , int P ) {
"
22,Ways to Remove Edges from a Complete Graph to make Odd Edges | C ++ implementation of the approach ; Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph ; Total number of edges ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; } int main ( ) { int N = 4 ; cout << countWays ( N ) ; return 0 ; }",Ways to Remove Edges from a Complete Graph to make Odd Edges.,"#include <bits/stdc++.h> 
 using namespace std ; int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; } int main ( ) { int N = 4 ; cout << countWays ( N ) ; return 0 ; }","['int countWays ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countWays ( int N ) {
"
24,Closest sum partition ( into two subsets ) of numbers from 1 to n | C ++ implementation of the approach ; Function to return the minimum required absolute difference ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) return 0 ; return 1 ; } int main ( ) { int n = 5 ; cout << minAbsDiff ( n ) ; return 0 ; },Closest sum partition ( into two subsets ) of numbers from 1 to n.,"#include <bits/stdc++.h> 
 using namespace std ; int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) return 0 ; return 1 ; } int main ( ) { int n = 5 ; cout << minAbsDiff ( n ) ; return 0 ; }","['int minAbsDiff ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minAbsDiff ( int n ) {
"
25,Check if the Xor of the frequency of all digits of a number N is zero or not | C ++ implementation of the above approach ; creating a frequency array ; Finding the last digit of the number ; Dividing the number by 10 to eliminate last digit ; counting frequency of each digit ; checking if the xor of all frequency is zero or not ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int s ) { int freq [ 10 ] = { 0 } , r ; while ( s != 0 ) { r = s % 10 ; s = int ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } } int main ( ) { int s = 122233 ; if ( check ( s ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; }",Check if the Xor of the frequency of all digits of a number N is zero or not.,"#include <bits/stdc++.h> 
 using namespace std ; bool check ( int s ) { int freq [ 10 ] = { 0 } , r ; while ( s != 0 ) { r = s % 10 ; s = int ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } } int main ( ) { int s = 122233 ; if ( check ( s ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; }","['bool check ( int s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool check ( int s ) {
"
26,Print N lines of 4 numbers such that every pair among 4 numbers has a GCD K | C ++ implementation of the above approach ; Function to print N lines ; Iterate N times to print N lines ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { cout << k * ( 6 * i + 1 ) << "" ▁ "" << k * ( 6 * i + 2 ) << "" ▁ "" << k * ( 6 * i + 3 ) << "" ▁ "" << k * ( 6 * i + 5 ) << endl ; } } int main ( ) { int n = 2 , k = 2 ; printLines ( n , k ) ; return 0 ; }",Print N lines of 4 numbers such that every pair among 4 numbers has a GCD K.,"#include <bits/stdc++.h> 
 using namespace std ; void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { cout << k * ( 6 * i + 1 ) << "" ▁ "" << k * ( 6 * i + 2 ) << "" ▁ "" << k * ( 6 * i + 3 ) << "" ▁ "" << k * ( 6 * i + 5 ) << endl ; } } int main ( ) { int n = 2 , k = 2 ; printLines ( n , k ) ; return 0 ; }","['void printLines ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printLines ( int n , int k ) {
"
27,"Sum of first n term of Series 3 , 5 , 9 , 17 , 33. ... | C ++ program to find sum of first n terms ; Sn = n * ( 4 * n * n + 6 * n - 1 ) / 3 ; Driver code ; number of terms to be included in sum ; find the Sn","#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return ( pow ( 2 , n + 1 ) + n - 2 ) ; } int main ( ) { int n = 4 ; cout << "" Sum ▁ = ▁ "" << calculateSum ( n ) ; return 0 ; }","Sum of first n term of Series 3 , 5 , 9 , 17 , 33. ....","#include <bits/stdc++.h> 
 using namespace std ; int calculateSum ( int n ) { return ( pow ( 2 , n + 1 ) + n - 2 ) ; } int main ( ) { int n = 4 ; cout << "" Sum ▁ = ▁ "" << calculateSum ( n ) ; return 0 ; }","['int calculateSum ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int calculateSum ( int n ) {
"
28,Count the number of Special Strings of a given length N | C ++ Program to Count the number of Special Strings of a given length N ; Function to return count of special strings ; stores the answer for a particular value of n ; for n = 0 we have empty string ; for n = 1 we have 2 special strings ; calculate count of special string of length i ; fib [ n ] stores the count of special strings of length n ; Driver code ; initialise n,#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE long count_special ( long n ) { long fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } int main ( ) { long n = 3 ; cout << count_special ( n ) << endl ; return 0 ; },Count the number of Special Strings of a given length N.,"#include <bits/stdc++.h> 
 using namespace std ; #define mod  1000000007 
 long count_special ( long n ) { long fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } int main ( ) { long n = 3 ; cout << count_special ( n ) << endl ; return 0 ; }","['long count_special ( long n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define mod  1000000007 
 long count_special ( long n ) {
"
29,Counts Path in an Array | C ++ implementation of the above approach ; Find the number of ways to reach the end ; Base case ; Recursive structure ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( 0 , arr , n ) << endl ; return 0 ; }",Counts Path in an Array.,"#include <bits/stdc++.h> 
 using namespace std ; const int mod = 1e9 + 7 ; int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( 0 , arr , n ) << endl ; return 0 ; }","['int ways ( int i , int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int mod = 1e9 + 7 ;
 int ways ( int i , int arr [ ] , int n ) {
"
30,Counts Path in an Array | C ++ implementation ; find the number of ways to reach the end ; dp to store value ; base case ; Bottom up dp structure ; F [ i ] is dependent of F [ i + 1 ] to F [ i + k ] ; Return value of dp [ 0 ] ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int arr [ ] , int n ) { int dp [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( arr , n ) % mod << endl ; return 0 ; }",Counts Path in an Array.,"#include <bits/stdc++.h> 
 using namespace std ; const int mod = 1e9 + 7 ; int ways ( int arr [ ] , int n ) { int dp [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( arr , n ) % mod << endl ; return 0 ; }","['int ways ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int mod = 1e9 + 7 ;
 int ways ( int arr [ ] , int n ) {
"
33,"Number of Paths of Weight W in a K | C ++ program to count the number of paths with weight W in a K - ary tree ; Function to return the number of ways having weight as wt in K - ary tree ; Return 0 if weight becomes less than zero ; Return one only if the current path has included edge weight of atleast M ; If the current edge weight is greater than or equal to M , set used as true ; Driver Code to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used ) return 1 ; return 0 ; } if ( dp [ wt ] [ used ] != -1 ) return dp [ wt ] [ used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt ] [ used ] = ans ; } int main ( ) { int W = 3 , K = 3 , M = 2 ; int dp [ W + 1 ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << solve ( dp , W , K , M , 0 ) << endl ; return 0 ; }",Number of Paths of Weight W in a K.,"#include <bits/stdc++.h> 
 using namespace std ; int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used ) return 1 ; return 0 ; } if ( dp [ wt ] [ used ] != -1 ) return dp [ wt ] [ used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt ] [ used ] = ans ; } int main ( ) { int W = 3 , K = 3 , M = 2 ; int dp [ W + 1 ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << solve ( dp , W , K , M , 0 ) << endl ; return 0 ; }","['int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) {
"
34,Ways to write N as sum of two or more positive integers | Set | C ++ implementation of above approach ; Function to find the number of partitions of N ; Base case ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long partitions ( int n ) { vector < long long > p ( n + 1 , 0 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) k *= -1 ; else k = 1 - k ; } } return p [ n ] ; } int main ( ) { int N = 20 ; cout << partitions ( N ) ; return 0 ; }",Ways to write N as sum of two or more positive integers.,"#include <bits/stdc++.h> 
 using namespace std ; long long partitions ( int n ) { vector < long long > p ( n + 1 , 0 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) k *= -1 ; else k = 1 - k ; } } return p [ n ] ; } int main ( ) { int N = 20 ; cout << partitions ( N ) ; return 0 ; }","['long partitions ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long long partitions ( int n ) {
"
36,"Counts paths from a point to reach Origin | C ++ program to count total number of paths from a point to origin ; Recursive function to count number of paths ; If we reach bottom or top left , we are have only one way to reach ( 0 , 0 ) ; Else count sum of both ways ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } int main ( ) { int n = 3 , m = 2 ; cout << "" ▁ Number ▁ of ▁ Paths ▁ "" << countPaths ( n , m ) ; return 0 ; }",Counts paths from a point to reach Origin.,"#include <bits/stdc++.h> 
 using namespace std ; int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } int main ( ) { int n = 3 , m = 2 ; cout << "" ▁ Number ▁ of ▁ Paths ▁ "" << countPaths ( n , m ) ; return 0 ; }","['int countPaths ( int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countPaths ( int n , int m ) {
"
37,"Gold Mine Problem | C ++ program to solve Gold Mine problem ; Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down ; Create a table for storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row ; Gold collected on going to the cell on the right ( -> ) ; Gold collected on going to the cell to right up ( / ) ; Gold collected on going to the cell to right down ( \ ) ; Max gold collected from taking either of the above 3 paths ; The max amount of gold collected will be the max value in first column of all rows ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } int main ( ) { int gold [ MAX ] [ MAX ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; cout << getMaxGold ( gold , m , n ) ; return 0 ; }",Gold Mine Problem.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX = 100 ; int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } int main ( ) { int gold [ MAX ] [ MAX ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; cout << getMaxGold ( gold , m , n ) ; return 0 ; }","['int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX = 100 ;
 int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) {
"
38,"Find minimum adjustment cost of an array | C ++ program to find minimum adjustment cost of an array ; Function to find minimum adjustment cost of an array ; dp [ i ] [ j ] stores minimal adjustment cost on changing A [ i ] to j ; handle first element of array separately ; do for rest elements of the array ; replace A [ i ] to j and calculate minimal adjustment cost dp [ i ] [ j ] ; initialize minimal adjustment cost to INT_MAX ; consider all k such that k >= max ( j - target , 0 ) and k <= min ( M , j + target ) and take minimum ; return minimum value from last row of dp table ; Driver Program to test above functions","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  100 NEW_LINE int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } int main ( ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 10 ; cout << "" Minimum ▁ adjustment ▁ cost ▁ is ▁ "" << minAdjustmentCost ( arr , n , target ) << endl ; return 0 ; }",Find minimum adjustment cost of an array.,"#include <bits/stdc++.h> 
 using namespace std ; #define M  100 
 int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } int main ( ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 10 ; cout << "" Minimum ▁ adjustment ▁ cost ▁ is ▁ "" << minAdjustmentCost ( arr , n , target ) << endl ; return 0 ; }","['int minAdjustmentCost ( int A [ ] , int n , int target ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define M  100 
 int minAdjustmentCost ( int A [ ] , int n , int target ) {
"
39,"Count triplets from a given range having sum of two numbers of a triplet equal to the third number | C ++ program for the above approach ; Function to find the number of triplets from the range [ L , R ] having sum of two numbers from the triplet equal to the third number ; Stores the total number of triplets ; Find the difference of the range ; Case 1 : If triplets can 't  be formed, then return 0 ; Otherwise ; Update the total number of triplets ; Return the count ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } int main ( ) { int L = 2 , R = 6 ; cout << totalCombination ( L , R ) ; return 0 ; }",Count triplets from a given range having sum of two numbers of a triplet equal to the third number.,"#include <bits/stdc++.h> 
 using namespace std ; int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } int main ( ) { int L = 2 , R = 6 ; cout << totalCombination ( L , R ) ; return 0 ; }","['int totalCombination ( int L , int R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int totalCombination ( int L , int R ) {
"
40,"Construct two N | C ++ program for the above approach ; Function to generate two arrays satisfying the given conditions ; Declare the two arrays A and B ; Iterate from range [ 1 , 2 * n ] ; Assign consecutive numbers to same indices of the two arrays ; Print the first array ; Print the second array , B ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArrays ( int n ) { vector < int > A , B ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . push_back ( i ) ; else B . push_back ( i ) ; } cout << "" { ▁ "" ; for ( int i = 0 ; i < n ; i ++ ) { cout << A [ i ] ; if ( i != n - 1 ) cout << "" , ▁ "" ; } cout << "" ▁ } STRNEWLINE "" ; cout << "" { ▁ "" ; for ( int i = 0 ; i < n ; i ++ ) { cout << B [ i ] ; if ( i != n - 1 ) cout << "" , ▁ "" ; } cout << "" ▁ } "" ; } int main ( ) { int N = 5 ; printArrays ( N ) ; return 0 ; }",Construct two N.,"#include <bits/stdc++.h> 
 using namespace std ; void printArrays ( int n ) { vector < int > A , B ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . push_back ( i ) ; else B . push_back ( i ) ; } cout << "" { ▁ "" ; for ( int i = 0 ; i < n ; i ++ ) { cout << A [ i ] ; if ( i != n - 1 ) cout << "" , ▁ "" ; } cout << "" ▁ } STRNEWLINE "" ; cout << "" { ▁ "" ; for ( int i = 0 ; i < n ; i ++ ) { cout << B [ i ] ; if ( i != n - 1 ) cout << "" , ▁ "" ; } cout << "" ▁ } "" ; } int main ( ) { int N = 5 ; printArrays ( N ) ; return 0 ; }","['void printArrays ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printArrays ( int n ) {
"
41,Numbers formed by flipping common set bits in two given integers | C ++ program to implement the above approach ; Function to flip bits of A and B which are set bits in A and B ; Iterater all possible bits of A and B ; If ith bit is set in both A and B ; Clear i - th bit of A ; Clear i - th bit of B ; Print A and B ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) ) && ( B & ( 1 << i ) ) ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << "" ▁ "" << B ; } int main ( ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; return 0 ; }",Numbers formed by flipping common set bits in two given integers.,"#include <bits/stdc++.h> 
 using namespace std ; void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) ) && ( B & ( 1 << i ) ) ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << "" ▁ "" << B ; } int main ( ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; return 0 ; }","['void flipBitsOfAandB ( int A , int B ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void flipBitsOfAandB ( int A , int B ) {
"
42,Count of distinct pair sum between two 1 to N value Arrays | C ++ implementation to find count of distinct pair sum between two 1 to N value Arrays ; Function to find the distinct sums ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; },Count of distinct pair sum between two 1 to N value Arrays.,"#include <bits/stdc++.h> 
 using namespace std ; int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }","['int findDistinctSums ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findDistinctSums ( int N ) {
"
43,"Count of substrings from given Ternary strings containing characters at least once | C ++ program for above approach ; Function to count the number of substrings consists of 0 , 1 , and 2 ; Initialize frequency array of size 3 ; Stores the resultant count ; Traversing string str ; Update frequency array ; If all the characters are present counting number of substrings possible ; Update number of substrings ; Return the number of substrings ; Driver Code","#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int countSubstrings ( string & str ) { int freq [ 3 ] = { 0 } ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; } int main ( ) { string str = ""00021"" ; int count = countSubstrings ( str ) ; cout << count ; return 0 ; }",Count of substrings from given Ternary strings containing characters at least once.,"#include <iostream> 
 #include <string> 
 using namespace std ; int countSubstrings ( string & str ) { int freq [ 3 ] = { 0 } ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; } int main ( ) { string str = ""00021"" ; int count = countSubstrings ( str ) ; cout << count ; return 0 ; }","['int countSubstrings ( string & str ) {', 'int main ( ) {']","#include <iostream> 
 #include <string> 
 using namespace std ;
 int countSubstrings ( string & str ) {
"
44,"Minimum flips to remove any consecutive 3 0 s or 1 s in given Binary string | C ++ program for the above approach ; Function to find the minimum number of flips to make all three pairs of consecutive characters different ; Stores resultant count of pairs ; Base Case ; Iterate over the range [ 0 , N - 2 ] ; If the consecutive 3 numbers are the same then increment the count and the counter ; Return the answer ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlips ( string str ) { int count = 0 ; if ( str . size ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . size ( ) - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } int main ( ) { string S = ""0011101"" ; cout << minFlips ( S ) ; return 0 ; }",Minimum flips to remove any consecutive 3 0 s or 1 s in given Binary string.,"#include <bits/stdc++.h> 
 using namespace std ; int minFlips ( string str ) { int count = 0 ; if ( str . size ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . size ( ) - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } int main ( ) { string S = ""0011101"" ; cout << minFlips ( S ) ; return 0 ; }","['int minFlips ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minFlips ( string str ) {
"
47,Remove all occurrences of a character in a string | Recursive approach | C ++ program for the above approach ; Function to remove all occurrences of a character in the string ; Base Case ; Check the first character of the given string ; Pass the rest of the string to recursion Function call ; Add the first character of str and string from recursion ; Driver Code ; Given String ; Given character ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeCharRecursive ( string str , char X ) { if ( str . length ( ) == 0 ) { return "" "" ; } if ( str [ 0 ] == X ) { return removeCharRecursive ( str . substr ( 1 ) , X ) ; } return str [ 0 ] + removeCharRecursive ( str . substr ( 1 ) , X ) ; } int main ( ) { string str = "" geeksforgeeks "" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; cout << str ; return 0 ; }",Remove all occurrences of a character in a string.,"#include <bits/stdc++.h> 
 using namespace std ; string removeCharRecursive ( string str , char X ) { if ( str . length ( ) == 0 ) { return "" "" ; } if ( str [ 0 ] == X ) { return removeCharRecursive ( str . substr ( 1 ) , X ) ; } return str [ 0 ] + removeCharRecursive ( str . substr ( 1 ) , X ) ; } int main ( ) { string str = "" geeksforgeeks "" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; cout << str ; return 0 ; }","['string removeCharRecursive ( string str , char X ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string removeCharRecursive ( string str , char X ) {
"
49,"Check if a string can be split into even length palindromic substrings | C ++ program for the above approach ; Function to check string str can be split a string into even length palindromic substrings ; Initialize a stack ; Iterate the string ; If the i - th character is same as that at the top of the stack then pop the top element ; Else push the current charactor into the stack ; If the stack is empty , then even palindromic substrings are possible ; Else not - possible ; Driver Code ; Given string ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s , int n ) { stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . empty ( ) && st . top ( ) == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . empty ( ) ) { return true ; } else { return false ; } } int main ( ) { string str = "" aanncddc "" ; int n = str . length ( ) ; if ( check ( str , n ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }",Check if a string can be split into even length palindromic substrings.,"#include <bits/stdc++.h> 
 using namespace std ; bool check ( string s , int n ) { stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . empty ( ) && st . top ( ) == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . empty ( ) ) { return true ; } else { return false ; } } int main ( ) { string str = "" aanncddc "" ; int n = str . length ( ) ; if ( check ( str , n ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }","['bool check ( string s , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool check ( string s , int n ) {
"
50,Number of strings in two array satisfy the given conditions | C ++ program for the above approach ; To store the frequency of string after bitmasking ; To store result for each string in arr2 [ ] ; Traverse the arr1 [ ] and bitmask each string in it ; Bitmasking for each string s ; Update the frequency of string with it 's bitmasking value ; Traverse the arr2 [ ] ; Bitmasking for each string s ; Check if temp is present in an unordered_map or not ; Check for next set bit ; Push the count for current string in resultant array ; Print the count for each string ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumOfValidWords ( vector < string > & w , vector < string > & p ) { unordered_map < int , int > m ; vector < int > res ; for ( string & s : w ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } m [ val ] ++ ; } for ( string & s : p ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s [ 0 ] - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . find ( temp ) != m . end ( ) ) { count += m [ temp ] ; } } temp = ( temp - 1 ) & val ; } res . push_back ( count ) ; } for ( auto & it : res ) { cout << it << ' ' ; } } int main ( ) { vector < string > arr1 ; arr1 = { "" aaaa "" , "" asas "" , "" able "" , "" ability "" , "" actt "" , "" actor "" , "" access "" } ; vector < string > arr2 ; arr2 = { "" aboveyz "" , "" abrodyz "" , "" absolute "" , "" absoryz "" , "" actresz "" , "" gaswxyz "" } ; findNumOfValidWords ( arr1 , arr2 ) ; return 0 ; }",Number of strings in two array satisfy the given conditions.,"#include <bits/stdc++.h> 
 using namespace std ; void findNumOfValidWords ( vector < string > & w , vector < string > & p ) { unordered_map < int , int > m ; vector < int > res ; for ( string & s : w ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } m [ val ] ++ ; } for ( string & s : p ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s [ 0 ] - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . find ( temp ) != m . end ( ) ) { count += m [ temp ] ; } } temp = ( temp - 1 ) & val ; } res . push_back ( count ) ; } for ( auto & it : res ) { cout << it << ' ' ; } } int main ( ) { vector < string > arr1 ; arr1 = { "" aaaa "" , "" asas "" , "" able "" , "" ability "" , "" actt "" , "" actor "" , "" access "" } ; vector < string > arr2 ; arr2 = { "" aboveyz "" , "" abrodyz "" , "" absolute "" , "" absoryz "" , "" actresz "" , "" gaswxyz "" } ; findNumOfValidWords ( arr1 , arr2 ) ; return 0 ; }","['void findNumOfValidWords ( vector < string > & w , vector < string > & p ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findNumOfValidWords ( vector < string > & w , vector < string > & p ) {
"
51,Maximize the decimal equivalent by flipping only a contiguous set of 0 s | C ++ implementation to Maximize the value of the decimal equivalent given in the binary form ; Function to print the binary number ; Check if the current number is 0 ; Find the continuous 0 s ; Replace initially occurring 0 with 1 ; Break out of loop if 1 occurs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void flip ( string & s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } } int main ( ) { string s = ""100010001"" ; flip ( s ) ; cout << s ; return 0 ; }",Maximize the decimal equivalent by flipping only a contiguous set of 0 s.,"#include <bits/stdc++.h> 
 using namespace std ; void flip ( string & s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } } int main ( ) { string s = ""100010001"" ; flip ( s ) ; cout << s ; return 0 ; }","['void flip ( string & s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void flip ( string & s ) {
"
52,Sentence Case of a given Camel cased string | C ++ implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void getOrgString ( string s ) { cout << s [ 0 ] ; int i = 1 ; while ( i < s . length ( ) ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) cout << "" ▁ "" << ( char ) tolower ( s [ i ] ) ; else cout << s [ i ] ; i ++ ; } } int main ( ) { string s = "" ILoveGeeksForGeeks "" ; getOrgString ( s ) ; return 0 ; }",Sentence Case of a given Camel cased string.,"#include <bits/stdc++.h> 
 using namespace std ; void getOrgString ( string s ) { cout << s [ 0 ] ; int i = 1 ; while ( i < s . length ( ) ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) cout << "" ▁ "" << ( char ) tolower ( s [ i ] ) ; else cout << s [ i ] ; i ++ ; } } int main ( ) { string s = "" ILoveGeeksForGeeks "" ; getOrgString ( s ) ; return 0 ; }","['void getOrgString ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void getOrgString ( string s ) {
"
53,Count occurrences of a character in a repeated string | CPP program to find the occurrences of character x in the infinite repeated string upto length n ; Function to count the character ' a ' ; atleast k repetition are required ; if n is not the multiple of the string size check for the remaining repeating character . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countChar ( string str , char x ) { int count = 0 , n = 10 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . size ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . size ( ) ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; } int main ( ) { string str = "" abcac "" ; cout << countChar ( str , ' a ' ) ; return 0 ; }",Count occurrences of a character in a repeated string.,"#include <bits/stdc++.h> 
 using namespace std ; int countChar ( string str , char x ) { int count = 0 , n = 10 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . size ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . size ( ) ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; } int main ( ) { string str = "" abcac "" ; cout << countChar ( str , ' a ' ) ; return 0 ; }","['int countChar ( string str , char x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countChar ( string str , char x ) {
"
54,Frequency Measuring Techniques for Competitive Programming | C ++ program to count frequencies of array items having small values . ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through array elements and count frequencies ( assuming that elements are limited by limit ) ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countFreq ( int arr [ ] , int n , int limit ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << i << "" ▁ "" << count [ i ] << endl ; } int main ( ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int limit = 10 ; countFreq ( arr , n , limit ) ; return 0 ; }",Frequency Measuring Techniques for Competitive Programming.,"#include <bits/stdc++.h> 
 using namespace std ; void countFreq ( int arr [ ] , int n , int limit ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << i << "" ▁ "" << count [ i ] << endl ; } int main ( ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int limit = 10 ; countFreq ( arr , n , limit ) ; return 0 ; }","['void countFreq ( int arr [ ] , int n , int limit ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countFreq ( int arr [ ] , int n , int limit ) {
"
55,Check if a string has m consecutive 1 ' s ▁ or ▁ 0' s | Program to check if the binary string contains m consecutive 1 ' s ▁ or ▁ 0' s ; Function that checks if the binary string contains m consecutive 1 ' s ▁ or ▁ 0' s ; length of binary string ; counts zeros ; counts 1 's ; count consecutive 0 's ; count consecutive 1 's ; Drivers Code ; function call,"#include <bits/stdc++.h> NEW_LINE #include <stdio.h> NEW_LINE using namespace std ; bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } int main ( ) { string s = ""001001"" ; int m = 2 ; if ( check ( s , m ) ) cout << "" YES "" ; else cout << "" NO "" ; return 0 ; }",Check if a string has m consecutive 1 ' s ▁ or ▁ 0' s.,"#include <bits/stdc++.h> 
 #include <stdio.h> 
 using namespace std ; bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } int main ( ) { string s = ""001001"" ; int m = 2 ; if ( check ( s , m ) ) cout << "" YES "" ; else cout << "" NO "" ; return 0 ; }","['bool check ( string s , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <stdio.h> 
 using namespace std ;
 bool check ( string s , int m ) {
"
56,Product of nodes at k | C ++ implementation to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; int product = 1 ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; } int main ( ) { string tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" ; int k = 2 ; cout << productAtKthLevel ( tree , k ) ; return 0 ; }",Product of nodes at k.,"#include <bits/stdc++.h> 
 using namespace std ; int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; } int main ( ) { string tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" ; int k = 2 ; cout << productAtKthLevel ( tree , k ) ; return 0 ; }","['int productAtKthLevel ( string tree , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int productAtKthLevel ( string tree , int k ) {
"
57,Removing row or column wise duplicates from matrix of characters | CPP code to form string after removing duplicates from rows and columns . ; Function to check duplicates in row and column ; Create an array isPresent and initialize all entries of it as false . The value of isPresent [ i ] [ j ] is going to be true if s [ i ] [ j ] is present in its row or column . ; Checking every row for duplicates of a [ i ] [ j ] ; Checking every column for duplicate characters ; If the character is unique in its row and column ; Driver code ; character array ; Calling function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDuplciates ( string a [ ] , int n , int m ) { bool isPresent [ n ] [ m ] ; memset ( isPresent , 0 , sizeof ( isPresent ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] [ j ] == a [ k ] [ j ] && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] [ j ] == a [ i ] [ k ] && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( ! isPresent [ i ] [ j ] ) printf ( "" % c "" , a [ i ] [ j ] ) ; } int main ( ) { int n = 2 , m = 5 ; string a [ ] = { "" zx "" , "" xz "" } ; findDuplciates ( a , n , m ) ; return 0 ; }",Removing row or column wise duplicates from matrix of characters.,"#include <bits/stdc++.h> 
 using namespace std ; void findDuplciates ( string a [ ] , int n , int m ) { bool isPresent [ n ] [ m ] ; memset ( isPresent , 0 , sizeof ( isPresent ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] [ j ] == a [ k ] [ j ] && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] [ j ] == a [ i ] [ k ] && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( ! isPresent [ i ] [ j ] ) printf ( "" % c "" , a [ i ] [ j ] ) ; } int main ( ) { int n = 2 , m = 5 ; string a [ ] = { "" zx "" , "" xz "" } ; findDuplciates ( a , n , m ) ; return 0 ; }","['void findDuplciates ( string a [ ] , int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findDuplciates ( string a [ ] , int n , int m ) {
"
58,"Program to check for ISBN | CPP program to check if a given ISBN is valid or not ; length must be 10 ; Computing weighted sum of first 9 digits ; Checking last digit . ; If last digit is ' X ' , add 10 to sum , else add its value . ; Return true if weighted sum of digits is divisible by 11. ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } int main ( ) { string isbn = ""007462542X "" ; if ( isValidISBN ( isbn ) ) cout << "" Valid "" ; else cout << "" Invalid "" ; return 0 ; }",Program to check for ISBN.,"#include <bits/stdc++.h> 
 using namespace std ; bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } int main ( ) { string isbn = ""007462542X "" ; if ( isValidISBN ( isbn ) ) cout << "" Valid "" ; else cout << "" Invalid "" ; return 0 ; }","['bool isValidISBN ( string & isbn ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isValidISBN ( string & isbn ) {
"
62,"Count of unordered pairs ( x , y ) of Array which satisfy given equation | C ++ Program to find the number of unordered pairs ( x , y ) which satisfy the given equation for the array ; Return the number of unordered pairs satisfying the conditions ; ans stores the number of unordered pairs ; Making each value of array to positive ; Sort the array ; For each index calculating the right boundary for the unordered pairs ; Return the final result ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) { index = upper_bound ( a , a + n , 2 * a [ i ] ) - a ; ans += index - i - 1 ; } return ans ; } int main ( ) { int a [ ] = { 3 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << numPairs ( a , n ) << endl ; return 0 ; }","Count of unordered pairs ( x , y ) of Array which satisfy given equation.","#include <bits/stdc++.h> 
 using namespace std ; int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) { index = upper_bound ( a , a + n , 2 * a [ i ] ) - a ; ans += index - i - 1 ; } return ans ; } int main ( ) { int a [ ] = { 3 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << numPairs ( a , n ) << endl ; return 0 ; }","['int numPairs ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int numPairs ( int a [ ] , int n ) {
"
63,"Area of a Square | Using Side , Diagonal and Perimeter | C ++ program for the above approach ; Function to find the area of a square ; Use above formula ; Driver Code ; Given Side of square ; Function call",#include <iostream> NEW_LINE using namespace std ; int areaOfSquare ( int S ) { int area = S * S ; return area ; } int main ( ) { int S = 5 ; cout << areaOfSquare ( S ) ; return 0 ; },Area of a Square.,"#include <iostream> 
 using namespace std ; int areaOfSquare ( int S ) { int area = S * S ; return area ; } int main ( ) { int S = 5 ; cout << areaOfSquare ( S ) ; return 0 ; }","['int areaOfSquare ( int S ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int areaOfSquare ( int S ) {
"
64,Maximum points of intersections possible among X circles and Y straight lines | C ++ program to implement the above approach ; Driver code ; Number of circles ; Number of straight lines ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } int main ( ) { int x = 3 ; int y = 4 ; cout << ( maxPointOfIntersection ( x , y ) ) ; }",Maximum points of intersections possible among X circles and Y straight lines.,"#include <bits/stdc++.h> 
 using namespace std ; int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } int main ( ) { int x = 3 ; int y = 4 ; cout << ( maxPointOfIntersection ( x , y ) ) ; }","['int maxPointOfIntersection ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxPointOfIntersection ( int x , int y ) {
"
65,Icosihenagonal Number | C ++ program to find nth Icosihenagonal number ; Function to find Icosihenagonal number ; Formula to calculate nth Icosihenagonal number ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icosihenagonal_num ( n ) << endl ; n = 10 ; cout << Icosihenagonal_num ( n ) << endl ; return 0 ; },Icosihenagonal Number.,"#include <bits/stdc++.h> 
 using namespace std ; int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icosihenagonal_num ( n ) << endl ; n = 10 ; cout << Icosihenagonal_num ( n ) << endl ; return 0 ; }","['int Icosihenagonal_num ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Icosihenagonal_num ( int n ) {
"
68,Distance between two parallel Planes in 3 | C ++ program to find the Distance between two parallel Planes in 3 D . ; Function to find distance ; Driver Code,"#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; cout << "" Perpendicular ▁ distance ▁ is ▁ "" << d << endl ; } else cout << "" Planes ▁ are ▁ not ▁ parallel "" ; return ; } int main ( ) { float a1 = 1 ; float b1 = 2 ; float c1 = -1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = -3 ; float d2 = -4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; return 0 ; }",Distance between two parallel Planes in 3.,"#include <bits/stdc++.h> 
 #include <math.h> 
 using namespace std ; void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; cout << "" Perpendicular ▁ distance ▁ is ▁ "" << d << endl ; } else cout << "" Planes ▁ are ▁ not ▁ parallel "" ; return ; } int main ( ) { float a1 = 1 ; float b1 = 2 ; float c1 = -1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = -3 ; float d2 = -4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; return 0 ; }","['void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <math.h> 
 using namespace std ;
 void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) {
"
70,"Check if a number S can be made divisible by D by repeatedly adding the remainder to S | C ++ program for the above approach ; Function to check if S is divisible by D while changing S to ( S + S % D ) ; V ( 0 ) = S % D ; Stores the encountered values ; V ( i ) = ( V ( i - 1 ) + V ( i - 1 ) % D ) % D ; Check if the value has already been encountered ; Edge Case ; Otherwise , insert it into the hashmap ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; string isDivisibleByDivisor ( int S , int D ) { S %= D ; unordered_set < int > hashMap ; hashMap . insert ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . find ( S ) != hashMap . end ( ) ) { if ( S == 0 ) { return "" Yes "" ; } return "" No "" ; } else hashMap . insert ( S ) ; } return "" Yes "" ; } int main ( ) { int S = 3 , D = 6 ; cout << isDivisibleByDivisor ( S , D ) ; return 0 ; }",Check if a number S can be made divisible by D by repeatedly adding the remainder to S.,"#include <bits/stdc++.h> 
 using namespace std ; string isDivisibleByDivisor ( int S , int D ) { S %= D ; unordered_set < int > hashMap ; hashMap . insert ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . find ( S ) != hashMap . end ( ) ) { if ( S == 0 ) { return "" Yes "" ; } return "" No "" ; } else hashMap . insert ( S ) ; } return "" Yes "" ; } int main ( ) { int S = 3 , D = 6 ; cout << isDivisibleByDivisor ( S , D ) ; return 0 ; }","['string isDivisibleByDivisor ( int S , int D ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string isDivisibleByDivisor ( int S , int D ) {
"
71,"Minimum number of given moves required to reach ( 1 , 1 ) from ( X , Y ) | C ++ program for the above approach ; Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 ) ; Store the required result ; Iterate while both x and y are not equal to 0 ; If x is greater than y ; Update count and value of x ; Otherwise ; Update count and value of y ; If both x and y > 1 ; Print the result ; Driver Code ; Given X and Y","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = -1 ; cout << cnt ; } int main ( ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; return 0 ; }","Minimum number of given moves required to reach ( 1 , 1 ) from ( X , Y ).","#include <bits/stdc++.h> 
 using namespace std ; int minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = -1 ; cout << cnt ; } int main ( ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; return 0 ; }","['int minimumSteps ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minimumSteps ( int x , int y ) {
"
72,"Check if an array is stack sortable | C ++ implementation of above approach . ; Function to check if A [ ] is Stack Sortable or Not . ; Stack S ; Pointer to the end value of array B . ; Traversing each element of A [ ] from starting Checking if there is a valid operation that can be performed . ; If the stack is not empty ; Top of the Stack . ; If the top of the stack is Equal to B_end + 1 , we will pop it And increment B_end by 1. ; if current top is equal to B_end + 1 , we will increment B_end to B_end + 1 ; Pop the top element . ; If the stack is empty We cannot further perfom this operation . Therefore break ; Current Top ; If stack is empty Push the Current element ; If the Current element of the array A [ ] if smaller than the top of the stack We can push it in the Stack . ; Else We cannot sort the array Using any valid operations . ; Not Stack Sortable ; If the stack is empty push the current element in the stack . ; Stack Sortable ; Driver 's Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int A [ ] , int N ) { stack < int > S ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . top ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . top ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . top ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } int main ( ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; check ( A , N ) ? cout << "" YES "" : cout << "" NO "" ; return 0 ; }",Check if an array is stack sortable.,"#include <bits/stdc++.h> 
 using namespace std ; bool check ( int A [ ] , int N ) { stack < int > S ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . top ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . top ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . top ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } int main ( ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; check ( A , N ) ? cout << "" YES "" : cout << "" NO "" ; return 0 ; }","['bool check ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool check ( int A [ ] , int N ) {
"
73,"Minimum number of bracket reversals needed to make an expression balanced | C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced . ; length of expression must be even to make it balanced by using reversals . ; After this loop , stack contains unbalanced part of expression , i . e . , expression of the form "" } } . . } { { . . { "" ; Length of the reduced expression red_len = ( m + n ) ; count opening brackets at the end of stack ; return ceil ( m / 2 ) + ceil ( n / 2 ) which is actually equal to ( m + n ) / 2 + n % 2 when m + n is even . ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) s . pop ( ) ; else s . push ( expr [ i ] ) ; } else s . push ( expr [ i ] ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } int main ( ) { string expr = "" } } { { "" ; cout << countMinReversals ( expr ) ; return 0 ; }",Minimum number of bracket reversals needed to make an expression balanced.,"#include <bits/stdc++.h> 
 using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) s . pop ( ) ; else s . push ( expr [ i ] ) ; } else s . push ( expr [ i ] ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } int main ( ) { string expr = "" } } { { "" ; cout << countMinReversals ( expr ) ; return 0 ; }","['int countMinReversals ( string expr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countMinReversals ( string expr ) {
"
74,Minimum number of bracket reversals needed to make an expression balanced | C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced . ; Expressions of odd lengths cannot be balanced ; If we find a left bracket then we simply increment the left bracket ; Else if left bracket is 0 then we find unbalanced right bracket and increment right bracket or if the expression is balanced then we decrement left ; Driver program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) { return -1 ; } int left_brace = 0 , right_brace = 0 ; int ans ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ceil ( left_brace / 2 ) + ceil ( right_brace / 2 ) ; return ans ; } int main ( ) { string expr = "" } } { { "" ; cout << countMinReversals ( expr ) ; return 0 ; }",Minimum number of bracket reversals needed to make an expression balanced.,"#include <bits/stdc++.h> 
 using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) { return -1 ; } int left_brace = 0 , right_brace = 0 ; int ans ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ceil ( left_brace / 2 ) + ceil ( right_brace / 2 ) ; return ans ; } int main ( ) { string expr = "" } } { { "" ; cout << countMinReversals ( expr ) ; return 0 ; }","['int countMinReversals ( string expr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countMinReversals ( string expr ) {
"
75,"Form minimum number from given sequence | C ++ program to print minimum number that can be formed from a given sequence of Is and Ds ; Prints the minimum number that can be formed from input sequence of I ' s ▁ and ▁ D ' s ; Initialize current_max ( to make sure that we don 't use repeated character ; Initialize last_entry ( Keeps track for last printed digit ) ; Iterate over input array ; Initialize ' noOfNextD ' to get count of next D 's available ; If letter is ' I ' Calculate number of next consecutive D 's  available ; If ' I ' is first letter , print incremented sequence from 1 ; Set max digit reached ; If not first letter Get next digit to print ; Print digit for I ; For all next consecutive ' D ' print decremented sequence ; If letter is ' D ' ; If ' D ' is first letter in sequence Find number of Next D 's available ; Calculate first digit to print based on number of consecutive D 's ; Print twice for the first time ; Store last entry ; If current ' D ' is not first letter Decrement last_entry ; Driver program to test above","#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; cout << "" ▁ "" << ++ last_entry ; cout << "" ▁ "" << curr_max ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; cout << "" ▁ "" << last_entry ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { cout << "" ▁ "" << -- last_entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; cout << "" ▁ "" << curr_max << "" ▁ "" << curr_max - 1 ; last_entry = curr_max - 1 ; } else { cout << "" ▁ "" << last_entry - 1 ; last_entry -- ; } break ; } } cout << endl ; } int main ( ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; return 0 ; }",Form minimum number from given sequence.,"#include <bits/stdc++.h> 
 using namespace std ; void PrintMinNumberForPattern ( string arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; cout << "" ▁ "" << ++ last_entry ; cout << "" ▁ "" << curr_max ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; cout << "" ▁ "" << last_entry ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { cout << "" ▁ "" << -- last_entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; cout << "" ▁ "" << curr_max << "" ▁ "" << curr_max - 1 ; last_entry = curr_max - 1 ; } else { cout << "" ▁ "" << last_entry - 1 ; last_entry -- ; } break ; } } cout << endl ; } int main ( ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; return 0 ; }","['void PrintMinNumberForPattern ( string arr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void PrintMinNumberForPattern ( string arr ) {
"
76,Form minimum number from given sequence | C ++ program to print minimum number that can be formed from a given sequence of Is and Ds ; min_avail represents the minimum number which is still available for inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector ; vector to store the output ; cover the base cases ; Traverse rest of the input ; print the number ; Driver program to check the above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLeast ( string arr ) { int min_avail = 1 , pos_of_I = 0 ; vector < int > v ; if ( arr [ 0 ] == ' I ' ) { v . push_back ( 1 ) ; v . push_back ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { v . push_back ( 2 ) ; v . push_back ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr [ i ] == ' I ' ) { v . push_back ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { v . push_back ( v [ i ] ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) v [ j ] ++ ; min_avail ++ ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << "" ▁ "" ; cout << endl ; } int main ( ) { printLeast ( "" IDID "" ) ; printLeast ( "" I "" ) ; printLeast ( "" DD "" ) ; printLeast ( "" II "" ) ; printLeast ( "" DIDI "" ) ; printLeast ( "" IIDDD "" ) ; printLeast ( "" DDIDDIID "" ) ; return 0 ; }",Form minimum number from given sequence.,"#include <bits/stdc++.h> 
 using namespace std ; void printLeast ( string arr ) { int min_avail = 1 , pos_of_I = 0 ; vector < int > v ; if ( arr [ 0 ] == ' I ' ) { v . push_back ( 1 ) ; v . push_back ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { v . push_back ( 2 ) ; v . push_back ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr [ i ] == ' I ' ) { v . push_back ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { v . push_back ( v [ i ] ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) v [ j ] ++ ; min_avail ++ ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << "" ▁ "" ; cout << endl ; } int main ( ) { printLeast ( "" IDID "" ) ; printLeast ( "" I "" ) ; printLeast ( "" DD "" ) ; printLeast ( "" II "" ) ; printLeast ( "" DIDI "" ) ; printLeast ( "" IIDDD "" ) ; printLeast ( "" DDIDDIID "" ) ; return 0 ; }","['void printLeast ( string arr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printLeast ( string arr ) {
"
77,Form minimum number from given sequence | C ++ program to print minimum number that can be formed from a given sequence of Is and Ds ; Function to decode the given sequence to construct minimum number without repeated digits ; result store output string ; create an empty stack of integers ; run n + 1 times where n is length of input sequence ; push number i + 1 into the stack ; if all characters of the input sequence are processed or current character is ' I ' ( increasing ) ; run till stack is empty ; remove top element from the stack and add it to solution ; main function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string seq ) { string result ; stack < int > stk ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) seq [ i ] == ' I ' ) { while ( ! stk . empty ( ) ) { result += to_string ( stk . top ( ) ) ; result += "" ▁ "" ; stk . pop ( ) ; } } } cout << result << endl ; } int main ( ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; return 0 ; }",Form minimum number from given sequence.,"#include <bits/stdc++.h> 
 using namespace std ; void PrintMinNumberForPattern ( string seq ) { string result ; stack < int > stk ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) seq [ i ] == ' I ' ) { while ( ! stk . empty ( ) ) { result += to_string ( stk . top ( ) ) ; result += "" ▁ "" ; stk . pop ( ) ; } } } cout << result << endl ; } int main ( ) { PrintMinNumberForPattern ( "" IDID "" ) ; PrintMinNumberForPattern ( "" I "" ) ; PrintMinNumberForPattern ( "" DD "" ) ; PrintMinNumberForPattern ( "" II "" ) ; PrintMinNumberForPattern ( "" DIDI "" ) ; PrintMinNumberForPattern ( "" IIDDD "" ) ; PrintMinNumberForPattern ( "" DDIDDIID "" ) ; return 0 ; }","['void PrintMinNumberForPattern ( string seq ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void PrintMinNumberForPattern ( string seq ) {
"
78,Form minimum number from given sequence | C ++ program of above approach ; Returns minimum number made from given sequence without repeating digits ; The loop runs for each input character as well as one additional time for assigning rank to remaining characters ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return "" - 1"" ; string result ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= -1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; } int main ( ) { string inputs [ ] = { "" IDID "" , "" I "" , "" DD "" , "" II "" , "" DIDI "" , "" IIDDD "" , "" DDIDDIID "" } ; for ( string input : inputs ) { cout << getMinNumberForPattern ( input ) << "" STRNEWLINE "" ; } return 0 ; }",Form minimum number from given sequence.,"#include <bits/stdc++.h> 
 using namespace std ; string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return "" - 1"" ; string result ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= -1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; } int main ( ) { string inputs [ ] = { "" IDID "" , "" I "" , "" DD "" , "" II "" , "" DIDI "" , "" IIDDD "" , "" DDIDDIID "" } ; for ( string input : inputs ) { cout << getMinNumberForPattern ( input ) << "" STRNEWLINE "" ; } return 0 ; }","['string getMinNumberForPattern ( string seq ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string getMinNumberForPattern ( string seq ) {
"
81,"Reach A and B by multiplying them with K and K ^ 2 at every step | CPP program to determine if A and B can be reached starting from 1 , 1 following the given steps . ; function to check is it is possible to reach A and B starting from 1 and 1 ; find the cuberoot of the number ; divide the number by cuberoot ; if it is a perfect cuberoot and divides a and b ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possibleToReach ( int a , int b ) { int c = cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } int main ( ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) cout << "" yes "" ; else cout << "" no "" ; return 0 ; }",Reach A and B by multiplying them with K and K ^ 2 at every step.,"#include <bits/stdc++.h> 
 using namespace std ; bool possibleToReach ( int a , int b ) { int c = cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } int main ( ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) cout << "" yes "" ; else cout << "" no "" ; return 0 ; }","['bool possibleToReach ( int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool possibleToReach ( int a , int b ) {
"
82,Undulating numbers | C ++ program to check whether a number is undulating or not ; Considering the definition with restriction that there should be at least 3 digits ; Check if all alternate digits are same or not . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isUndulating ( string n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) false ; return true ; } int main ( ) { string n = ""1212121"" ; if ( isUndulating ( n ) ) cout << "" Yes "" ; else cout << "" No "" ; }",Undulating numbers.,"#include <bits/stdc++.h> 
 using namespace std ; bool isUndulating ( string n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) false ; return true ; } int main ( ) { string n = ""1212121"" ; if ( isUndulating ( n ) ) cout << "" Yes "" ; else cout << "" No "" ; }","['bool isUndulating ( string n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isUndulating ( string n ) {
"
83,Program to find the sum of a Series ( 1 * 1 ) + ( 2 * 2 ) + ( 3 * 3 ) + ( 4 * 4 ) + ( 5 * 5 ) + ... + ( n * n ) | CPP program to calculate the following series ; Function to calculate the following series ; Driver Code,#include <iostream> NEW_LINE using namespace std ; int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } int main ( ) { int n = 3 ; int res = Series ( n ) ; cout << res << endl ; },Program to find the sum of a Series ( 1 * 1 ) + ( 2 * 2 ) + ( 3 * 3 ) + ( 4 * 4 ) + ( 5 * 5 ) + ... + ( n * n ).,"#include <iostream> 
 using namespace std ; int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } int main ( ) { int n = 3 ; int res = Series ( n ) ; cout << res << endl ; }","['int Series ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int Series ( int n ) {
"
84,Count numbers with unit digit k in given range | Efficient CPP program to count numbers with last digit as k in given range . ; Returns count of numbers with k as last digit . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLastDigitK ( long long low , long long high , long long K ) { long long mlow = 10 * ceil ( low / 10.0 ) ; long long mhigh = 10 * floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= K ) count ++ ; if ( low % 10 <= K && ( low % 10 ) ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << countLastDigitK ( low , high , k ) ; return 0 ; }",Count numbers with unit digit k in given range.,"#include <bits/stdc++.h> 
 using namespace std ; int countLastDigitK ( long long low , long long high , long long K ) { long long mlow = 10 * ceil ( low / 10.0 ) ; long long mhigh = 10 * floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= K ) count ++ ; if ( low % 10 <= K && ( low % 10 ) ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << countLastDigitK ( low , high , k ) ; return 0 ; }","['int countLastDigitK ( long long low , long long high , long long K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countLastDigitK ( long long low , long long high , long long K ) {
"
85,Sum of all numbers divisible by 6 in a given range | CPP program to find sum of numbers divisible by 6 in a given range . ; function to calculate the sum of all numbers divisible by 6 in range L - R . . ; no of multiples of 6 upto r ; no of multiples of 6 upto l - 1 ; summation of all multiples of 6 upto r ; summation of all multiples of 6 upto l - 1 ; returns the answer ; driver program to test the above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } int main ( ) { int L = 1 , R = 20 ; cout << sum ( L , R ) ; return 0 ; }",Sum of all numbers divisible by 6 in a given range.,"#include <bits/stdc++.h> 
 using namespace std ; int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } int main ( ) { int L = 1 , R = 20 ; cout << sum ( L , R ) ; return 0 ; }","['int sum ( int L , int R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int sum ( int L , int R ) {
"
86,"Largest smaller number possible using only one swap operation | C ++ program to find the largest smaller number by swapping one digit . ; Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s . ; Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4. ; We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr [ index ] which is smaller than arr [ index ] ; If index is - 1 i . e . digits are in increasing order . ; Swap both values ; Drivers code","#include <bits/stdc++.h> NEW_LINE using namespace std ; string prevNum ( string str ) { int len = str . length ( ) ; int index = -1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { index = i ; break ; } } int smallGreatDgt = -1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str [ i ] < str [ index ] ) { if ( smallGreatDgt == -1 ) smallGreatDgt = i ; else if ( str [ i ] >= str [ smallGreatDgt ] ) smallGreatDgt = i ; } } if ( index == -1 ) return "" - 1"" ; if ( smallGreatDgt != -1 ) { swap ( str [ index ] , str [ smallGreatDgt ] ) ; return str ; } return "" - 1"" ; } int main ( ) { string str = ""34125"" ; cout << prevNum ( str ) ; return 0 ; }",Largest smaller number possible using only one swap operation.,"#include <bits/stdc++.h> 
 using namespace std ; string prevNum ( string str ) { int len = str . length ( ) ; int index = -1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { index = i ; break ; } } int smallGreatDgt = -1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str [ i ] < str [ index ] ) { if ( smallGreatDgt == -1 ) smallGreatDgt = i ; else if ( str [ i ] >= str [ smallGreatDgt ] ) smallGreatDgt = i ; } } if ( index == -1 ) return "" - 1"" ; if ( smallGreatDgt != -1 ) { swap ( str [ index ] , str [ smallGreatDgt ] ) ; return str ; } return "" - 1"" ; } int main ( ) { string str = ""34125"" ; cout << prevNum ( str ) ; return 0 ; }","['string prevNum ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string prevNum ( string str ) {
"
89,Sum of all Subarrays | Set 1 | Simple C ++ program to compute sum of subarray elements ; Computes sum all sub - array ; Pick starting point ; Pick ending point ; sum subarray between current starting and ending points ; driver program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Sum ▁ of ▁ SubArray ▁ : ▁ "" << SubArraySum ( arr , n ) << endl ; return 0 ; }",Sum of all Subarrays.,"#include <bits/stdc++.h> 
 using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Sum ▁ of ▁ SubArray ▁ : ▁ "" << SubArraySum ( arr , n ) << endl ; return 0 ; }","['int SubArraySum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long int SubArraySum ( int arr [ ] , int n ) {
"
90,Highest power of 2 less than or equal to given number | C ++ program to find highest power of 2 smaller than or equal to n . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }",Highest power of 2 less than or equal to given number.,"#include <bits/stdc++.h> 
 using namespace std ; int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }","['int highestPowerof2 ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int highestPowerof2 ( int n ) {
"
91,"Rearrange characters in a string such that no two adjacent are same | C ++ program to rearrange characters in a string so that no two adjacent characters are same . ; store frequency of character ; function for priority_queue to store Key according to freq ; Function to rearrange character of a string so that no char repeat twice ; Store frequencies of all characters in string ; Insert all characters with their frequencies into a priority_queue ; ' str ' that will store resultant value ; work as the previous visited element initial previous element be . ( ' # ' and it ' s ▁ frequency ▁ ' - 1 ' ) ; traverse queue ; pop top element from queue and add it to string . ; IF frequency of previous character is less than zero that means it is useless , we need not to push it ; make current character as the previous ' char ' decrease frequency by ' one ' ; If length of the resultant string and original string is not same then string is not valid ; valid string ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; struct Key { int freq ; char ch ; bool operator< ( const Key & k ) const { return freq < k . freq ; } } ; void rearrangeString ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; priority_queue < Key > pq ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] ) { pq . push ( Key { count [ val ] , c } ) ; } } str = "" "" ; Key prev { -1 , ' # ' } ; while ( ! pq . empty ( ) ) { Key k = pq . top ( ) ; pq . pop ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . push ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) cout << "" ▁ Not ▁ valid ▁ String ▁ "" << endl ; else cout << str << endl ; } int main ( ) { string str = "" bbbaa "" ; rearrangeString ( str ) ; return 0 ; }",Rearrange characters in a string such that no two adjacent are same.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX_CHAR = 26 ; struct Key { int freq ; char ch ; bool operator< ( const Key & k ) const { return freq < k . freq ; } } ; void rearrangeString ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; priority_queue < Key > pq ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] ) { pq . push ( Key { count [ val ] , c } ) ; } } str = "" "" ; Key prev { -1 , ' # ' } ; while ( ! pq . empty ( ) ) { Key k = pq . top ( ) ; pq . pop ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . push ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) cout << "" ▁ Not ▁ valid ▁ String ▁ "" << endl ; else cout << str << endl ; } int main ( ) { string str = "" bbbaa "" ; rearrangeString ( str ) ; return 0 ; }","['void rearrangeString ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX_CHAR = 26 ;
 struct Key {
 int freq ;
 char ch ;
 bool operator< ( const Key & k ) const {
 return freq < k . freq ;
 } } ;
 void rearrangeString ( string str ) {
"
93,Lagrange 's Interpolation | C ++ program for implementation of Lagrange 's Interpolation ; To represent a data point corresponding to x and y = f ( x ) ; function to interpolate the given data points using Lagrange 's formula xi corresponds to the new data point whose value is to be obtained n represents the number of known data points ; double result = 0 ; Initialize result ; Compute individual terms of above formula ; Add current term to result ; driver function to check the program ; creating an array of 4 known data points ; Using the interpolate function to obtain a data point corresponding to x = 3,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Data { int x , y ; } ; double interpolate ( Data f [ ] , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / double ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } int main ( ) { Data f [ ] = { { 0 , 2 } , { 1 , 3 } , { 2 , 12 } , { 5 , 147 } } ; cout << "" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ "" << interpolate ( f , 3 , 5 ) ; return 0 ; }",Lagrange 's Interpolation.,"#include <bits/stdc++.h> 
 using namespace std ; struct Data { int x , y ; } ; double interpolate ( Data f [ ] , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / double ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } int main ( ) { Data f [ ] = { { 0 , 2 } , { 1 , 3 } , { 2 , 12 } , { 5 , 147 } } ; cout << "" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ "" << interpolate ( f , 3 , 5 ) ; return 0 ; }","['double interpolate ( Data f [ ] , int xi , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 struct Data {
 int x , y ;
 } ;
 double interpolate ( Data f [ ] , int xi , int n ) {
"
94,"Sieve of Sundaram to print all primes smaller than n | C ++ program to print primes smaller than n using Sieve of Sundaram . ; Prints all prime numbers smaller ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than n , we reduce n to half ; This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j ; Initialize all elements as not marked ; Main logic of Sundaram . Mark all numbers of the form i + j + 2 ij as true where 1 <= i <= j ; Since 2 is a prime number ; Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; Driver program to test above","#include <bits/stdc++.h> NEW_LINE using namespace std ; int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool marked [ nNew + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << "" ▁ "" ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << "" ▁ "" ; } int main ( void ) { int n = 20 ; SieveOfSundaram ( n ) ; return 0 ; }",Sieve of Sundaram to print all primes smaller than n.,"#include <bits/stdc++.h> 
 using namespace std ; int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool marked [ nNew + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << "" ▁ "" ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << "" ▁ "" ; } int main ( void ) { int n = 20 ; SieveOfSundaram ( n ) ; return 0 ; }","['int SieveOfSundaram ( int n ) {', 'int main ( void ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int SieveOfSundaram ( int n ) {
"
95,Construct original array starting with K from an array of XOR of all elements except elements at same index | C ++ program for the above approach ; Function to construct an array with each element equal to XOR of all array elements except the element at the same index ; Original array ; Stores Bitwise XOR of array ; Calculate XOR of all array elements ; Print the original array B [ ] ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int A [ ] , int N , int K ) { int B [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << "" ▁ "" ; } } int main ( ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; constructArray ( A , N , K ) ; return 0 ; }",Construct original array starting with K from an array of XOR of all elements except elements at same index.,"#include <bits/stdc++.h> 
 using namespace std ; void constructArray ( int A [ ] , int N , int K ) { int B [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << "" ▁ "" ; } } int main ( ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; constructArray ( A , N , K ) ; return 0 ; }","['void constructArray ( int A [ ] , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void constructArray ( int A [ ] , int N , int K ) {
"
96,Find extra element in the second array | C ++ implementation of the approach ; Function to return the extra element in B [ ] ; To store the result ; Find the XOR of all the element of array A [ ] and array B [ ] ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } int main ( ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << extraElement ( A , B , n ) ; return 0 ; }",Find extra element in the second array.,"#include <bits/stdc++.h> 
 using namespace std ; int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } int main ( ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << extraElement ( A , B , n ) ; return 0 ; }","['int extraElement ( int A [ ] , int B [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int extraElement ( int A [ ] , int B [ ] , int n ) {
"
97,Hamming distance between two Integers | C ++ implementation of above approach ; Function to calculate hamming distance ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } int main ( ) { int n1 = 9 , n2 = 14 ; cout << hammingDistance ( 9 , 14 ) << endl ; return 0 ; }",Hamming distance between two Integers.,"#include <bits/stdc++.h> 
 using namespace std ; int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } int main ( ) { int n1 = 9 , n2 = 14 ; cout << hammingDistance ( 9 , 14 ) << endl ; return 0 ; }","['int hammingDistance ( int n1 , int n2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int hammingDistance ( int n1 , int n2 ) {
"
98,Print bitwise AND set of a number N | CPP program to print all bitwise subsets of N ( Naive approach ) ; function to find bitwise subsets Naive approach ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) cout << i << "" ▁ "" ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }",Print bitwise AND set of a number N.,"#include <bits/stdc++.h> 
 using namespace std ; void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) cout << i << "" ▁ "" ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }","['void printSubsets ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printSubsets ( int n ) {
"
99,Find most significant set bit of a number | CPP program to find MSB number for given n . ; To find the position of the most significant set bit ; To return the the value of the number with set bit at k - th position ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBitNumber ( int n ) { int k = ( int ) ( log2 ( n ) ) ; return 1 << k ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; },Find most significant set bit of a number.,"#include <bits/stdc++.h> 
 using namespace std ; int setBitNumber ( int n ) { int k = ( int ) ( log2 ( n ) ) ; return 1 << k ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; }","['int setBitNumber ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int setBitNumber ( int n ) {
"
100,Minimum number of subsets with distinct elements | A sorting based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Take input and initialize res = 0 ; Sort the array ; Traverse the input array and find maximum frequency ; For each number find its repetition / frequency ; Update res ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }",Minimum number of subsets with distinct elements.,"#include <bits/stdc++.h> 
 using namespace std ; int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }","['int subset ( int ar [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int subset ( int ar [ ] , int n ) {
"
101,Minimum number of subsets with distinct elements | A hashing based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Traverse the input array and store frequencies of elements ; Find the maximum value in map . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto x : mp ) res = max ( res , x . second ) ; return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }",Minimum number of subsets with distinct elements.,"#include <bits/stdc++.h> 
 using namespace std ; int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto x : mp ) res = max ( res , x . second ) ; return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }","['int subset ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int subset ( int arr [ ] , int n ) {
"
103,"Sum of distances of all nodes from a given node | C ++ program for the above approach ; Structure of a binary tree node ; Function that allocates a new node with the given data and NULL to its left and right pointers ; Return newly created node ; Function to count the number of nodes in the left and right subtrees ; Initialize a pair that stores the pair { number of nodes , depth } ; Finding the number of nodes in the left subtree ; Find the number of nodes in the right subtree ; Filling up size field ; Stores the sum of distances of all nodes from the given node ; Function to find the total distance ; If target node matches with the current node ; If root -> left is not null ; Update sum ; Recur for the left subtree ; If root -> right is not null ; Apply the formula given in the approach ; Recur for the right subtree ; Driver Code ; Input tree ; Total number of nodes ; Print the sum of distances","#include <bits/stdc++.h> NEW_LINE using namespace std ; class TreeNode { public : int data , size ; TreeNode * left ; TreeNode * right ; } ; TreeNode * newNode ( int data ) { TreeNode * Node = new TreeNode ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } pair < int , int > sumofsubtree ( TreeNode * root ) { pair < int , int > p = make_pair ( 1 , 0 ) ; if ( root -> left ) { pair < int , int > ptemp = sumofsubtree ( root -> left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root -> right ) { pair < int , int > ptemp = sumofsubtree ( root -> right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root -> size = p . first ; return p ; } int sum = 0 ; void distance ( TreeNode * root , int target , int distancesum , int n ) { if ( root -> data == target ) { sum = distancesum ; } if ( root -> left ) { int tempsum = distancesum - root -> left -> size + ( n - root -> left -> size ) ; distance ( root -> left , target , tempsum , n ) ; } if ( root -> right ) { int tempsum = distancesum - root -> right -> size + ( n - root -> right -> size ) ; distance ( root -> right , target , tempsum , n ) ; } } int main ( ) { TreeNode * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; int target = 3 ; pair < int , int > p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; cout << sum << endl ; return 0 ; }",Sum of distances of all nodes from a given node.,"#include <bits/stdc++.h> 
 using namespace std ; class TreeNode { public : int data , size ; TreeNode * left ; TreeNode * right ; } ; TreeNode * newNode ( int data ) { TreeNode * Node = new TreeNode ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } pair < int , int > sumofsubtree ( TreeNode * root ) { pair < int , int > p = make_pair ( 1 , 0 ) ; if ( root -> left ) { pair < int , int > ptemp = sumofsubtree ( root -> left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root -> right ) { pair < int , int > ptemp = sumofsubtree ( root -> right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root -> size = p . first ; return p ; } int sum = 0 ; void distance ( TreeNode * root , int target , int distancesum , int n ) { if ( root -> data == target ) { sum = distancesum ; } if ( root -> left ) { int tempsum = distancesum - root -> left -> size + ( n - root -> left -> size ) ; distance ( root -> left , target , tempsum , n ) ; } if ( root -> right ) { int tempsum = distancesum - root -> right -> size + ( n - root -> right -> size ) ; distance ( root -> right , target , tempsum , n ) ; } } int main ( ) { TreeNode * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; int target = 3 ; pair < int , int > p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; cout << sum << endl ; return 0 ; }","['void distance ( TreeNode * root , int target , int distancesum , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 class TreeNode {
 public : int data , size ;
 TreeNode * left ;
 TreeNode * right ;
 } ;
 TreeNode * newNode ( int data ) {
 TreeNode * Node = new TreeNode ( ) ;
 Node -> data = data ;
 Node -> left = NULL ;
 Node -> right = NULL ;
 return ( Node ) ;
 } pair < int , int > sumofsubtree ( TreeNode * root ) {
 pair < int , int > p = make_pair ( 1 , 0 ) ;
 if ( root -> left ) {
 pair < int , int > ptemp = sumofsubtree ( root -> left ) ;
 p . second += ptemp . first + ptemp . second ;
 p . first += ptemp . first ;
 } if ( root -> right ) {
 pair < int , int > ptemp = sumofsubtree ( root -> right ) ;
 p . second += ptemp . first + ptemp . second ;
 p . first += ptemp . first ;
 } root -> size = p . first ;
 return p ;
 } int sum = 0 ;
 void distance ( TreeNode * root , int target , int distancesum , int n ) {
"
104,Rearrange array such that sum of same indexed elements is atmost K | C ++ program for the above approach ; Function to rearrange array such that sum of similar indexed elements does not exceed K ; Sort the array B [ ] in descending order ; If condition fails ; Print the array ; Driver Code ; Given arrays,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { sort ( B , B + N , greater < int > ( ) ) ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { cout << "" - 1"" << endl ; } else { for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << "" ▁ "" ; } } } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; return 0 ; }",Rearrange array such that sum of same indexed elements is atmost K.,"#include <bits/stdc++.h> 
 using namespace std ; void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { sort ( B , B + N , greater < int > ( ) ) ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { cout << "" - 1"" << endl ; } else { for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << "" ▁ "" ; } } } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; return 0 ; }","['void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) {
"
105,Count rows with sum exceeding sum of the remaining Matrix | C ++ program to implement the above approach ; Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix ; To store the result ; Stores the total sum of the matrix elements ; Calculate the total sum ; Traverse to check for each row ; Stores the sum of elements of the current row ; Calculate the sum of elements of the current row ; If sum of current row exceeds the sum of rest of the matrix ; Increase count ; Print the result ; Driver Code ; Given matrix ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  3 NEW_LINE void countRows ( int mat [ M ] [ N ] ) { int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < M ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } cout << count ; } int main ( ) { int mat [ N ] [ M ] = { { 2 , -1 , 5 } , { -3 , 0 , -2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; }",Count rows with sum exceeding sum of the remaining Matrix.,"#include <bits/stdc++.h> 
 using namespace std ; #define N  3 
 #define M  3 
 void countRows ( int mat [ M ] [ N ] ) { int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < M ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } cout << count ; } int main ( ) { int mat [ N ] [ M ] = { { 2 , -1 , 5 } , { -3 , 0 , -2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; }","['void countRows ( int mat [ M ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define N  3 
 #define M  3 
 void countRows ( int mat [ M ] [ N ] ) {
"
106,"Check if array contains contiguous integers with duplicates allowed | C ++ implementation to check whether the array contains a set of contiguous integers ; function to check whether the array contains a set of contiguous integers ; Find maximum and minimum elements . ; There should be at least m elements in array to make them contiguous . ; Create a visited array and initialize false . ; Mark elements as true . ; If any element is not marked , all elements are not contiguous . ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if array contains contiguous integers with duplicates allowed.,"#include <bits/stdc++.h> 
 using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool areElementsContiguous ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool areElementsContiguous ( int arr [ ] , int n ) {
"
107,"Check if array contains contiguous integers with duplicates allowed | C ++ implementation to check whether the array contains a set of contiguous integers ; Function to check whether the array contains a set of contiguous integers ; Storing elements of ' arr [ ] ' in a hash table ' us ' ; as arr [ 0 ] is present in ' us ' ; starting with previous smaller element of arr [ 0 ] ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; starting with next greater element of arr [ 0 ] ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; returns true if array contains a set of contiguous integers else returns false ; Driver program to test above","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { unordered_set < int > us ; for ( int i = 0 ; i < n ; i ++ ) us . insert ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele ++ ; } return ( count == ( int ) ( us . size ( ) ) ) ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if array contains contiguous integers with duplicates allowed.,"#include <bits/stdc++.h> 
 using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { unordered_set < int > us ; for ( int i = 0 ; i < n ; i ++ ) us . insert ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele ++ ; } return ( count == ( int ) ( us . size ( ) ) ) ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool areElementsContiguous ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool areElementsContiguous ( int arr [ ] , int n ) {
"
108,"Longest subarray not having more than K distinct elements | CPP program to find longest subarray with k or less distinct elements . ; function to print the longest sub - array ; mark the element visited ; if its visited first time , then increase the counter of distinct elements by 1 ; When the counter of distinct elements increases from k , then reduce it to k ; from the left , reduce the number of time of visit ; if the reduced visited time element is not present in further segment then decrease the count of distinct elements ; increase the subsegment mark ; check length of longest sub - segment when greater then previous best then change it ; print the longest sub - segment ; driver program to test the above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << "" ▁ "" ; } int main ( ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; longest ( a , n , k ) ; return 0 ; }",Longest subarray not having more than K distinct elements.,"#include <bits/stdc++.h> 
 using namespace std ; void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << "" ▁ "" ; } int main ( ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; longest ( a , n , k ) ; return 0 ; }","['void longest ( int a [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void longest ( int a [ ] , int n , int k ) {
"
110,"Find smallest range containing elements from k lists | C ++ program to finds out smallest range that includes elements from each of the given sorted lists . ; array for storing the current index of list i ; This function takes an k sorted lists in the form of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists . ; initializing to 0 index ; ; for maintaining the index of list containing the minimum element ; iterating over all the list ; if every element of list [ i ] is traversed then break the loop ; find minimum value among all the list elements pointing by the ptr [ ] array ; update the index of the list ; find maximum value among all the list elements pointing by the ptr [ ] array ; if any list exhaust we will not get any better answer , so break the while loop ; updating the minrange ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int ptr [ 501 ] ; void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) ptr [ i ] = 0 ; minrange = INT_MAX ; while ( 1 ) { minind = -1 ; minval = INT_MAX ; maxval = INT_MIN ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } printf ( "" The ▁ smallest ▁ range ▁ is ▁ [ % d , ▁ % d ] STRNEWLINE "" , minel , maxel ) ; } int main ( ) { int arr [ ] [ N ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSmallestRange ( arr , N , k ) ; return 0 ; }",Find smallest range containing elements from k lists.,"#include <bits/stdc++.h> 
 using namespace std ; #define N  5 
 int ptr [ 501 ] ; void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) ptr [ i ] = 0 ; minrange = INT_MAX ; while ( 1 ) { minind = -1 ; minval = INT_MAX ; maxval = INT_MIN ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } printf ( "" The ▁ smallest ▁ range ▁ is ▁ [ % d , ▁ % d ] STRNEWLINE "" , minel , maxel ) ; } int main ( ) { int arr [ ] [ N ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSmallestRange ( arr , N , k ) ; return 0 ; }","['void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define N  5 
 int ptr [ 501 ] ;
 void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) {
"
111,"Find largest d in array such that a + b + c = d | CPP Program to find the largest d such that d = a + b + c ; function to find largest d ; sort the array in ascending order ; iterating from backwards to find the required largest d ; since all four a , b , c , d should be distinct ; if the current combination of j , k , l in the set is equal to S [ i ] return this value as this would be the largest d since we are iterating in descending order ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; } int main ( ) { int S [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; int ans = findLargestd ( S , n ) ; if ( ans == INT_MIN ) cout << "" No ▁ Solution "" << endl ; else cout << "" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + ▁ "" << "" c ▁ = ▁ d ▁ is ▁ "" << ans << endl ; return 0 ; }",Find largest d in array such that a + b + c = d.,"#include <bits/stdc++.h> 
 using namespace std ; int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; } int main ( ) { int S [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; int ans = findLargestd ( S , n ) ; if ( ans == INT_MIN ) cout << "" No ▁ Solution "" << endl ; else cout << "" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + ▁ "" << "" c ▁ = ▁ d ▁ is ▁ "" << ans << endl ; return 0 ; }","['int findLargestd ( int S [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findLargestd ( int S [ ] , int n ) {
"
112,"Find largest d in array such that a + b + c = d | A hashing based CPP program to find largest d such that a + b + c = d . ; The function finds four elements with given sum X ; Store sums ( a + b ) of all pairs ( a , b ) in a hash table ; Traverse through all pairs and find ( d - c ) is present in hash table ; If d - c is present in hash table , ; Making sure that all elements are distinct array elements and an element is not considered more than once . ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFourElements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = findFourElements ( arr , n ) ; if ( res == INT_MIN ) cout << "" No ▁ Solution . "" ; else cout << res ; return 0 ; }",Find largest d in array such that a + b + c = d.,"#include <bits/stdc++.h> 
 using namespace std ; int findFourElements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = findFourElements ( arr , n ) ; if ( res == INT_MIN ) cout << "" No ▁ Solution . "" ; else cout << res ; return 0 ; }","['int findFourElements ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findFourElements ( int arr [ ] , int n ) {
"
113,Maximize count of elements that can be selected having minimum difference between their sum and K | C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort the array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }",Maximize count of elements that can be selected having minimum difference between their sum and K.,"#include <bits/stdc++.h> 
 using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }","['int CountMaximum ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int CountMaximum ( int arr [ ] , int n , int k ) {
"
115,Sort the array in a given index range | C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Temporary array ; Sort the temporary array ; Modifying original array with temporary array elements ; Print the modified array ; Driver code ; length of the array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; int temp [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } sort ( temp , temp + r - l + 1 ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 ; int b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; return 0 ; }",Sort the array in a given index range.,"#include <bits/stdc++.h> 
 using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; int temp [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } sort ( temp , temp + r - l + 1 ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 ; int b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; return 0 ; }","['void partSort ( int arr [ ] , int N , int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void partSort ( int arr [ ] , int N , int a , int b ) {
"
117,"Move all zeroes to end of array | A C ++ program to move all zeroes at the end of array ; Function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element ; here count is ; incremented Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end . ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } int main ( ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pushZerosToEnd ( arr , n ) ; cout << "" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array ▁ : STRNEWLINE "" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Move all zeroes to end of array.,"#include <iostream> 
 using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } int main ( ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pushZerosToEnd ( arr , n ) ; cout << "" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array ▁ : STRNEWLINE "" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }","['void pushZerosToEnd ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void pushZerosToEnd ( int arr [ ] , int n ) {
"
120,"Double the first element and move zero to end | Utility Function For Swaping Two Element Of An Array ; shift all zero to left side of an array ; Maintain last index with positive value ; If Element is non - zero ; swap current index , with lastSeen non - zero ; next element will be last seen non - zero","void swap ( int & a , int & b ) { a = b + a - ( b = a ) ; } void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } }",Double the first element and move zero to end.,"void swap ( int & a , int & b ) { a = b + a - ( b = a ) ; } void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } }","['void swap ( int & a , int & b ) {', 'void shiftAllZeroToLeft ( int array [ ] , int n ) {']","void swap ( int & a , int & b ) {
"
123,Rearrange positive and negative numbers with constant extra space | C ++ implementation of the above approach ; Loop until arr [ i ] < 0 and still inside the array ; Loop until arr [ j ] > 0 and still inside the array ; if i is less than j ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; void RearrangePosNeg ( int arr [ ] , int n ) { int i = 0 ; int j = n - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < n ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Rearrange positive and negative numbers with constant extra space.,"#include <iostream> 
 using namespace std ; void RearrangePosNeg ( int arr [ ] , int n ) { int i = 0 ; int j = n - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < n ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }","['void RearrangePosNeg ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void RearrangePosNeg ( int arr [ ] , int n ) {
"
124,"Find the player to be able to replace the last element that can be replaced by its divisors | C ++ program for the above approach ; Function to find the winner of the game played based on given conditions ; A wins if size of array is odd ; Otherwise , B wins ; Driver Code ; Input array ; Size of the array","#include <bits/stdc++.h> NEW_LINE using namespace std ; void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { cout << "" A "" ; } else { cout << "" B "" ; } } int main ( ) { int arr [ ] = { 24 , 45 , 45 , 24 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; winner ( arr , N ) ; }",Find the player to be able to replace the last element that can be replaced by its divisors.,"#include <bits/stdc++.h> 
 using namespace std ; void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { cout << "" A "" ; } else { cout << "" B "" ; } } int main ( ) { int arr [ ] = { 24 , 45 , 45 , 24 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; winner ( arr , N ) ; }","['void winner ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void winner ( int arr [ ] , int N ) {
"
126,"Find all elements in array which have at | Simple C ++ program to find all elements in array which have at - least two greater elements itself . ; Pick elements one by one and count greater elements . If count is more than 2 , print that element . ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }",Find all elements in array which have at.,"#include <bits/stdc++.h> 
 using namespace std ; void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }","['void findElements ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findElements ( int arr [ ] , int n ) {
"
127,Find all elements in array which have at | Sorting based C ++ program to find all elements in array which have atleast two greater elements itself . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }",Find all elements in array which have at.,"#include <bits/stdc++.h> 
 using namespace std ; void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }","['void findElements ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findElements ( int arr [ ] , int n ) {
"
128,Find all elements in array which have at | C ++ program to find all elements in array which have atleast two greater elements itself . ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }",Find all elements in array which have at.,"#include <bits/stdc++.h> 
 using namespace std ; void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }","['void findElements ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findElements ( int arr [ ] , int n ) {
"
129,"Minimize count of increments of each element of subarrays required to make Array non | C ++ Program to implement the above approach ; Function to find the minimum number of operations required to make the array non - increasing ; Stores the count of required operations ; If arr [ i ] > arr [ i + 1 ] , no increments required . Otherwise , add their difference to the answer ; Return the result res ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinOps ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMinOps ( arr , N ) ; }",Minimize count of increments of each element of subarrays required to make Array non.,"#include <bits/stdc++.h> 
 using namespace std ; int getMinOps ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMinOps ( arr , N ) ; }","['int getMinOps ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getMinOps ( int arr [ ] , int n ) {
"
130,Find the smallest missing number | C ++ program to find the smallest elements missing in a sorted array . ; function that returns smallest elements missing in a sorted array . ; Left half has all elements from 0 to mid ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Smallest ▁ missing ▁ element ▁ is ▁ "" << findFirstMissing ( arr , 0 , n - 1 ) << endl ; }",Find the smallest missing number.,"#include <bits/stdc++.h> 
 using namespace std ; int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Smallest ▁ missing ▁ element ▁ is ▁ "" << findFirstMissing ( arr , 0 , n - 1 ) << endl ; }","['int findFirstMissing ( int array [ ] , int start , int end ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findFirstMissing ( int array [ ] , int start , int end ) {
"
132,Maximum sum such that no two elements are adjacent | c ++ program for the above approach ; Function to return max sum such that no two elements are adjacent ; current max excluding i ; current max including i ; return max of incl and excl ; Driver program to test above functions,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } int main ( ) { vector < int > arr = { 5 , 5 , 10 , 100 , 10 , 5 } ; cout << FindMaxSum ( arr , arr . size ( ) ) ; }",Maximum sum such that no two elements are adjacent.,"#include <bits/stdc++.h> 
 using namespace std ; int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } int main ( ) { vector < int > arr = { 5 , 5 , 10 , 100 , 10 , 5 } ; cout << FindMaxSum ( arr , arr . size ( ) ) ; }","['int FindMaxSum ( vector < int > arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int FindMaxSum ( vector < int > arr , int n ) {
"
133,"Minimum steps to convert all top left to bottom right paths in Matrix as palindrome | Set 2 | C ++ program for the above approach ; Function for counting minimum number of changes ; Distance of elements from ( 0 , 0 ) will is i range [ 0 , n + m - 2 ] ; Store frequencies of [ 0 , 9 ] at distance i ; Initialize frequencies as 0 ; Count frequencies of [ 0 , 9 ] ; Increment frequency of value matrix [ i ] [ j ] at distance i + j ; Find value with max frequency and count total cells at distance i from front end and rear end ; Change all values to the value with max frequency ; Return the answer ; Driver Code ; Given Matrix ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  7 NEW_LINE int countChanges ( int matrix [ ] [ N ] , int n , int m ) { int dist = n + m - 1 ; int freq [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } int main ( ) { int mat [ ] [ N ] = { { 1 , 2 } , { 3 , 5 } } ; cout << countChanges ( mat , 2 , 2 ) ; return 0 ; }",Minimum steps to convert all top left to bottom right paths in Matrix as palindrome.,"#include <bits/stdc++.h> 
 using namespace std ; #define N  7 
 int countChanges ( int matrix [ ] [ N ] , int n , int m ) { int dist = n + m - 1 ; int freq [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } int main ( ) { int mat [ ] [ N ] = { { 1 , 2 } , { 3 , 5 } } ; cout << countChanges ( mat , 2 , 2 ) ; return 0 ; }","['int countChanges ( int matrix [ ] [ N ] , int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define N  7 
 int countChanges ( int matrix [ ] [ N ] , int n , int m ) {
"
136,Lexicographically smallest array after at | C ++ program to find lexicographically minimum value after k swaps . ; Modifies arr [ 0. . n - 1 ] to lexicographically smallest with k swaps . ; Set the position where we want to put the smallest integer ; If we exceed the Max swaps then terminate the loop ; Find the minimum value from i + 1 to max k or n ; Swap the elements from Minimum position we found till now to the i index ; Set the final value after swapping pos - i elements ; Driver code ; Function calling ; Print the final Array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } } int main ( ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << "" ▁ "" ; }",Lexicographically smallest array after at.,"#include <bits/stdc++.h> 
 using namespace std ; void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } } int main ( ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << "" ▁ "" ; }","['void minimizeWithKSwaps ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minimizeWithKSwaps ( int arr [ ] , int n , int k ) {
"
137,Find maximum average subarray of k length | C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Create and fill array to store cumulative sum . csum [ i ] stores sum of arr [ 0 ] to arr [ i ] ; Initialize max_sm as sum of first subarray ; Find sum of other subarrays and update max_sum if required . ; To avoid memory leak ; Return starting index ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ "" "" length ▁ "" << k << "" ▁ begins ▁ at ▁ index ▁ "" << findMaxAverage ( arr , n , k ) ; return 0 ; }",Find maximum average subarray of k length.,"#include <bits/stdc++.h> 
 using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ "" "" length ▁ "" << k << "" ▁ begins ▁ at ▁ index ▁ "" << findMaxAverage ( arr , n , k ) ; return 0 ; }","['int findMaxAverage ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMaxAverage ( int arr [ ] , int n , int k ) {
"
138,Find maximum average subarray of k length | C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Compute sum of first ' k ' elements ; Compute sum of remaining subarrays ; Return starting index ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ "" "" length ▁ "" << k << "" ▁ begins ▁ at ▁ index ▁ "" << findMaxAverage ( arr , n , k ) ; return 0 ; }",Find maximum average subarray of k length.,"#include <bits/stdc++.h> 
 using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ "" "" length ▁ "" << k << "" ▁ begins ▁ at ▁ index ▁ "" << findMaxAverage ( arr , n , k ) ; return 0 ; }","['int findMaxAverage ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMaxAverage ( int arr [ ] , int n , int k ) {
"
142,"Count of integers from the range [ 0 , N ] whose digit sum is a multiple of K | C ++ implementation of the approach ; To store the states of the dp ; Function to return the count of numbers from the range [ 0 , n ] whose digit sum is a multiple of k using bottom - up dp ; The digit in this index can only be from [ 0 , num [ idx ] ] ; The digit in this index can be anything from [ 0 , 9 ] ; new_tight is the flag value for the next position ; res can 't be negative ; Function to process the string to a vector of digits from MSD to LSD ; Driver code ; For large input number n ; Total number of digits in n ; Clean dp table ; Process the string to a vector of digits from MSD to LSD","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE #define MOD  1000000007 NEW_LINE int dp [ MAX ] [ 101 ] [ 2 ] ; int countNum ( int idx , int sum , int tight , vector < int > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != -1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } vector < int > process ( string s ) { vector < int > num ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . push_back ( s [ i ] - '0' ) ; } return num ; } int main ( ) { string n = ""98765432109876543210"" ; int len = n . length ( ) ; int k = 58 ; memset ( dp , -1 , sizeof ( dp ) ) ; vector < int > num = process ( n ) ; cout << countNum ( 0 , 0 , 0 , num , len , k ) ; return 0 ; }","Count of integers from the range [ 0 , N ] whose digit sum is a multiple of K.","#include <bits/stdc++.h> 
 using namespace std ; #define MAX  100005 
 #define MOD  1000000007 
 int dp [ MAX ] [ 101 ] [ 2 ] ; int countNum ( int idx , int sum , int tight , vector < int > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != -1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } vector < int > process ( string s ) { vector < int > num ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . push_back ( s [ i ] - '0' ) ; } return num ; } int main ( ) { string n = ""98765432109876543210"" ; int len = n . length ( ) ; int k = 58 ; memset ( dp , -1 , sizeof ( dp ) ) ; vector < int > num = process ( n ) ; cout << countNum ( 0 , 0 , 0 , num , len , k ) ; return 0 ; }","['int countNum ( int idx , int sum , int tight , vector < int > num , int len , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define MAX  100005 
 #define MOD  1000000007 
 int dp [ MAX ] [ 101 ] [ 2 ] ;
 int countNum ( int idx , int sum , int tight , vector < int > num , int len , int k ) {
"
143,Double Knapsack | Dynamic Programming | C ++ implementation of the above approach ; 3D array to store states of DP ; w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on ; Base case ; Variables to store the result of three parts of recurrence relation ; Store the state in the 3D array ; Driver code ; Input array ; Initializing the array with - 1 ; Number of elements in the array ; Capacity of knapsacks ; Function to be called,"#include <bits/stdc++.h> NEW_LINE #define maxN  31 NEW_LINE #define maxW  31 NEW_LINE using namespace std ; int dp [ maxN ] [ maxW ] [ maxW ] ; int maxWeight ( int * arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != -1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } int main ( ) { int arr [ ] = { 8 , 2 , 3 } ; memset ( dp , -1 , sizeof ( dp ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int w1 = 10 , w2 = 3 ; cout << maxWeight ( arr , n , w1 , w2 , 0 ) ; return 0 ; }",Double Knapsack.,"#include <bits/stdc++.h> 
 #define maxN  31 
 #define maxW  31 
 using namespace std ; int dp [ maxN ] [ maxW ] [ maxW ] ; int maxWeight ( int * arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != -1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } int main ( ) { int arr [ ] = { 8 , 2 , 3 } ; memset ( dp , -1 , sizeof ( dp ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int w1 = 10 , w2 = 3 ; cout << maxWeight ( arr , n , w1 , w2 , 0 ) ; return 0 ; }","['int maxWeight ( int * arr , int n , int w1_r , int w2_r , int i ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define maxN  31 
 #define maxW  31 
 using namespace std ;
 int dp [ maxN ] [ maxW ] [ maxW ] ;
 int maxWeight ( int * arr , int n , int w1_r , int w2_r , int i ) {
"
145,"Count ways to reach a score using 1 and 2 with no consecutive 2 s | Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays [ i ] will store count for last 3 values before i . ; Loop till "" n + 1"" to compute value for "" n "" ; number of ways if first run is 1 ; number of ways if first run is 2 and second run is 1 ; Remember last 3 values ; Driver code",#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { int noOfWays [ 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 5 ; cout << CountWays ( n ) ; return 0 ; },Count ways to reach a score using 1 and 2 with no consecutive 2 s.,"#include <iostream> 
 using namespace std ; int CountWays ( int n ) { int noOfWays [ 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 5 ; cout << CountWays ( n ) ; return 0 ; }","['int CountWays ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int CountWays ( int n ) {
"
147,"Maximum size subset with given sum | A Dynamic Programming solution for subset sum problem + maximal subset value . ; Returns size of maximum sized subset if there is a subset of set [ ] with sun equal to given sum . It returns - 1 if there is no subset with given sum . ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ sum + 1 ] [ n + 1 ] ; int count [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = -1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } int main ( ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = 4 ; cout << isSubsetSum ( set , n , sum ) ; }",Maximum size subset with given sum.,"#include <bits/stdc++.h> 
 using namespace std ; int isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ sum + 1 ] [ n + 1 ] ; int count [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = -1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } int main ( ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = 4 ; cout << isSubsetSum ( set , n , sum ) ; }","['int isSubsetSum ( int set [ ] , int n , int sum ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int isSubsetSum ( int set [ ] , int n , int sum ) {
"
149,Check for Majority Element in a sorted array | C ++ Program to check for majority element in a sorted array ; get last index according to n ( even or odd ) ; search for first occurrence of x in arr [ ] ; check if x is present and is present more than n / 2 times ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( isMajority ( arr , n , x ) ) cout << x << "" ▁ appears ▁ more ▁ than ▁ "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; else cout << x << "" ▁ does ▁ not ▁ appear ▁ more ▁ than "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; return 0 ; }",Check for Majority Element in a sorted array.,"#include <bits/stdc++.h> 
 using namespace std ; bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( isMajority ( arr , n , x ) ) cout << x << "" ▁ appears ▁ more ▁ than ▁ "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; else cout << x << "" ▁ does ▁ not ▁ appear ▁ more ▁ than "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; return 0 ; }","['bool isMajority ( int arr [ ] , int n , int x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isMajority ( int arr [ ] , int n , int x ) {
"
151,Check for Majority Element in a sorted array |  ;,"#include <iostream> NEW_LINE using namespace std ; bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) cout << x << "" ▁ appears ▁ more ▁ than ▁ "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; else cout << x << "" ▁ does ▁ not ▁ appear ▁ more ▁ than "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; return 0 ; }",Check for Majority Element in a sorted array.,"#include <iostream> 
 using namespace std ; bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) cout << x << "" ▁ appears ▁ more ▁ than ▁ "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; else cout << x << "" ▁ does ▁ not ▁ appear ▁ more ▁ than "" << n / 2 << "" ▁ times ▁ in ▁ arr [ ] "" << endl ; return 0 ; }","['bool isMajorityElement ( int arr [ ] , int n , int key ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 bool isMajorityElement ( int arr [ ] , int n , int key ) {
"
153,"Cutting a Rod | DP | CPP program for above approach ; Global Array for the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call","#include <iostream> NEW_LINE using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << "" Maximum ▁ obtained ▁ value ▁ is ▁ "" << un_kp ( price , length , n , Max_len ) << endl ; }",Cutting a Rod.,"#include <iostream> 
 using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << "" Maximum ▁ obtained ▁ value ▁ is ▁ "" << un_kp ( price , length , n , Max_len ) << endl ; }","['int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int t [ 9 ] [ 9 ] ;
 int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) {
"
154,"Modify array to another given array by replacing array elements with the sum of the array | CPP program to implement the above approach ; Function to check if the arr [ ] can be converted to target [ ] by replacing any element in arr [ ] by the sum of arr [ ] ; Store the maximum element ; Store the index of the maximum element ; Traverse the array target [ ] ; If current element is greater than max ; If max element is 1 ; Traverse the array , target [ ] ; If current index is not equal to maximum element index ; Update max ; If max is less than or equal to 0 , ; Update the maximum element ; Recursively call the function ; Driver Code ; Size of the array","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int target [ ] , int n ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target , n ) ; } int main ( ) { int target [ ] = { 9 , 3 , 5 } ; int n = sizeof ( target ) / sizeof ( target [ 0 ] ) ; bool res = isPossible ( target , n ) ; if ( res ) { cout << "" YES "" ; } else { cout << "" NO "" ; } return 0 ; }",Modify array to another given array by replacing array elements with the sum of the array.,"#include <bits/stdc++.h> 
 using namespace std ; bool isPossible ( int target [ ] , int n ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target , n ) ; } int main ( ) { int target [ ] = { 9 , 3 , 5 } ; int n = sizeof ( target ) / sizeof ( target [ 0 ] ) ; bool res = isPossible ( target , n ) ; if ( res ) { cout << "" YES "" ; } else { cout << "" NO "" ; } return 0 ; }","['bool isPossible ( int target [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isPossible ( int target [ ] , int n ) {
"
155,"Sum of all products of the Binomial Coefficients of two numbers up to K | C ++ implementation of the above approach ; Function returns nCr i . e . Binomial Coefficient ; Initialize res with 1 ; Since C ( n , r ) = C ( n , n - r ) ; Evaluating expression ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 3 , m = 2 , k = 2 ; cout << nCr ( n + m , k ) ; return 0 ; }",Sum of all products of the Binomial Coefficients of two numbers up to K.,"#include <bits/stdc++.h> 
 using namespace std ; int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 3 , m = 2 , k = 2 ; cout << nCr ( n + m , k ) ; return 0 ; }","['int nCr ( int n , int r ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int nCr ( int n , int r ) {
"
156,Check if N can be obtained from 1 by repetitively multiplying by 10 or 20 | C ++ program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20 ; Function to check if N can be obtained or not ; Count and remove trailing zeroes ; Check if remaining N is a power of 2 ; To check the condition to print YES or NO ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void Is_possible ( long long int N ) { int C = 0 ; int D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( pow ( 2 , ( int ) log2 ( N ) ) == N ) { D = ( int ) log2 ( N ) ; if ( C >= D ) cout << "" YES "" ; else cout << "" NO "" ; } else cout << "" NO "" ; } int main ( ) { long long int N = 2000000000000 ; Is_possible ( N ) ; }",Check if N can be obtained from 1 by repetitively multiplying by 10 or 20.,"#include <bits/stdc++.h> 
 using namespace std ; void Is_possible ( long long int N ) { int C = 0 ; int D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( pow ( 2 , ( int ) log2 ( N ) ) == N ) { D = ( int ) log2 ( N ) ; if ( C >= D ) cout << "" YES "" ; else cout << "" NO "" ; } else cout << "" NO "" ; } int main ( ) { long long int N = 2000000000000 ; Is_possible ( N ) ; }","['void Is_possible ( long long int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void Is_possible ( long long int N ) {
"
157,Central polygonal numbers | C ++ program to find N - th term in the series ; Function to find N - th term in the series ; Driver code,#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findNthTerm ( int n ) { cout << n * n - n + 1 << endl ; } int main ( ) { int N = 4 ; findNthTerm ( N ) ; return 0 ; },Central polygonal numbers.,"#include <iostream> 
 #include <math.h> 
 using namespace std ; void findNthTerm ( int n ) { cout << n * n - n + 1 << endl ; } int main ( ) { int N = 4 ; findNthTerm ( N ) ; return 0 ; }","['void findNthTerm ( int n ) {', 'int main ( ) {']","#include <iostream> 
 #include <math.h> 
 using namespace std ;
 void findNthTerm ( int n ) {
"
159,"Program to print the series 1 , 3 , 4 , 8 , 15 , 27 , 50 â €¦ till N terms | C ++ implementation to print the N terms of the series whose three terms are given ; Function to print the series ; Generate the ith term and print it ; Driver Code ; Function Call","#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { cout << a << "" ▁ "" ; return ; } if ( n == 2 ) { cout << a << "" ▁ "" << b << "" ▁ "" ; return ; } cout << a << "" ▁ "" << b << "" ▁ "" << c << "" ▁ "" ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; cout << d << "" ▁ "" ; a = b ; b = c ; c = d ; } } int main ( ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; return 0 ; }","Program to print the series 1 , 3 , 4 , 8 , 15 , 27 , 50 â €¦ till N terms.","#include "" bits / stdc + + . h "" 
 using namespace std ; void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { cout << a << "" ▁ "" ; return ; } if ( n == 2 ) { cout << a << "" ▁ "" << b << "" ▁ "" ; return ; } cout << a << "" ▁ "" << b << "" ▁ "" << c << "" ▁ "" ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; cout << d << "" ▁ "" ; a = b ; b = c ; c = d ; } } int main ( ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; return 0 ; }","['void printSeries ( int n , int a , int b , int c ) {', 'int main ( ) {']","#include "" bits / stdc + + . h "" 
 using namespace std ;
 void printSeries ( int n , int a , int b , int c ) {
"
160,Diameter of a Binary Indexed Tree with N nodes |  ; Function to find diameter of BIT with N + 1 nodes ; L is size of subtree just before subtree in which N lies ; H is the height of subtree just before subtree in which N lies ; Base Cases ; Size of subtree are power of 2 ; 3 Cases as explained in Approach ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } int main ( ) { int n = 15 ; cout << diameter ( n ) << endl ; }",Diameter of a Binary Indexed Tree with N nodes.,"#include <bits/stdc++.h> 
 using namespace std ; int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } int main ( ) { int n = 15 ; cout << diameter ( n ) << endl ; }","['int diameter ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int diameter ( int n ) {
"
161,Find the larger exponential among two exponentials | C ++ implementation of the approach ; Function to find whether a ^ b is greater or c ^ d ; Find b * log ( a ) ; Find d * log ( c ) ; Compare both values ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void compareValues ( int a , int b , int c , int d ) { double log1 = log10 ( a ) ; double num1 = log1 * b ; double log2 = log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) cout << a << "" ^ "" << b ; else cout << c << "" ^ "" << d ; } int main ( ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; }",Find the larger exponential among two exponentials.,"#include <bits/stdc++.h> 
 using namespace std ; void compareValues ( int a , int b , int c , int d ) { double log1 = log10 ( a ) ; double num1 = log1 * b ; double log2 = log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) cout << a << "" ^ "" << b ; else cout << c << "" ^ "" << d ; } int main ( ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; }","['void compareValues ( int a , int b , int c , int d ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void compareValues ( int a , int b , int c , int d ) {
"
164,Minimum value to be added to X such that it is at least Y percent of N | C ++ implementation of the approach ; Function to return the required value that must be added to x so that it is at least y percent of n ; Required value ; If x is already >= y percent of n ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; } int main ( ) { int n = 10 , x = 2 , y = 40 ; cout << minValue ( n , x , y ) ; }",Minimum value to be added to X such that it is at least Y percent of N.,"#include <bits/stdc++.h> 
 using namespace std ; int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; } int main ( ) { int n = 10 , x = 2 , y = 40 ; cout << minValue ( n , x , y ) ; }","['int minValue ( int n , int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minValue ( int n , int x , int y ) {
"
168,Perfect cube greater than a given number | C ++ implementation of above approach ; Function to find the next perfect cube ; Driver Code,#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int nextPerfectCube ( int N ) { int nextN = floor ( cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } int main ( ) { int n = 35 ; cout << nextPerfectCube ( n ) ; return 0 ; },Perfect cube greater than a given number.,"#include <cmath> 
 #include <iostream> 
 using namespace std ; int nextPerfectCube ( int N ) { int nextN = floor ( cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } int main ( ) { int n = 35 ; cout << nextPerfectCube ( n ) ; return 0 ; }","['int nextPerfectCube ( int N ) {', 'int main ( ) {']","#include <cmath> 
 #include <iostream> 
 using namespace std ;
 int nextPerfectCube ( int N ) {
"
170,"Position of n among the numbers made of 2 , 3 , 5 & 7 |  ; If number is 2 then it is on the position pos * 2 + 1 ; If number is 3 then it is on the position pos * 2 + 2 ; If number is 5 then it is on the position pos * 2 + 3 ; If number is 7 then it is on the position pos * 2 + 4 ; Driver code","#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int findpos ( string n ) { int pos = 0 ; for ( int i = 0 ; n [ i ] != ' \0' ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } int main ( ) { string n = ""777"" ; cout << findpos ( n ) ; }","Position of n among the numbers made of 2 , 3 , 5 & 7.","#include <algorithm> 
 #include <iostream> 
 using namespace std ; int findpos ( string n ) { int pos = 0 ; for ( int i = 0 ; n [ i ] != ' \0' ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } int main ( ) { string n = ""777"" ; cout << findpos ( n ) ; }","['int findpos ( string n ) {', 'int main ( ) {']","#include <algorithm> 
 #include <iostream> 
 using namespace std ;
 int findpos ( string n ) {
"
174,Program to Convert Radian to Degree | C ++ code to convert radian to degree ; Function for convertion ; Driver code,#include <iostream> NEW_LINE using namespace std ; double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } int main ( ) { double radian = 5.0 ; double degree = Convert ( radian ) ; cout << degree ; return 0 ; },Program to Convert Radian to Degree.,"#include <iostream> 
 using namespace std ; double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } int main ( ) { double radian = 5.0 ; double degree = Convert ( radian ) ; cout << degree ; return 0 ; }","['double Convert ( double radian ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 double Convert ( double radian ) {
"
176,Maximum of smallest possible area that can get with exactly k cut of given rectangular | C ++ code for Maximum of smallest possible area that can get with exactly k cut of given rectangular ; Utility Function ; for the 1 st case ; for the second case ; print final result ; driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << "" Not ▁ possible "" << endl ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result << endl ; } } int main ( ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; }",Maximum of smallest possible area that can get with exactly k cut of given rectangular.,"#include <bits/stdc++.h> 
 using namespace std ; void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << "" Not ▁ possible "" << endl ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result << endl ; } } int main ( ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; }","['void max_area ( int n , int m , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void max_area ( int n , int m , int k ) {
"
177,Program to find the area of a Square | CPP program to find the area of a square ; function to find the area ; Driver program,#include <iostream> NEW_LINE using namespace std ; int area_fun ( int side ) { int area = side * side ; return area ; } int main ( ) { int side = 4 ; int area = area_fun ( side ) ; cout << area ; return 0 ; },Program to find the area of a Square.,"#include <iostream> 
 using namespace std ; int area_fun ( int side ) { int area = side * side ; return area ; } int main ( ) { int side = 4 ; int area = area_fun ( side ) ; cout << area ; return 0 ; }","['int area_fun ( int side ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int area_fun ( int side ) {
"
178,Count ways to express a number as sum of consecutive numbers | C ++ program to count number of ways to express N as sum of consecutive numbers . ; Utility method to compute number of ways in which N can be represented as sum of consecutive number ; constraint on values of L gives us the time Complexity as O ( N ^ 0.5 ) ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; long int countConsecutive ( long int N ) { long int count = 0 ; for ( long int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } int main ( ) { long int N = 15 ; cout << countConsecutive ( N ) << endl ; N = 10 ; cout << countConsecutive ( N ) << endl ; return 0 ; },Count ways to express a number as sum of consecutive numbers.,"#include <bits/stdc++.h> 
 using namespace std ; long int countConsecutive ( long int N ) { long int count = 0 ; for ( long int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } int main ( ) { long int N = 15 ; cout << countConsecutive ( N ) << endl ; N = 10 ; cout << countConsecutive ( N ) << endl ; return 0 ; }","['int countConsecutive ( long int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long int countConsecutive ( long int N ) {
"
179,"Automorphic Number | C ++ program to check if a number is Authomorphic ; Function to check Automorphic number ; Store the square ; Start Comparing digits ; Return false , if any digit of N doesn ' t ▁ ▁ match ▁ with ▁ its ▁ square ' s digits from last ; Reduce N and square ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } int main ( ) { int N = 5 ; isAutomorphic ( N ) ? cout << "" Automorphic "" : cout << "" Not ▁ Automorphic "" ; return 0 ; }",Automorphic Number.,"#include <iostream> 
 using namespace std ; bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } int main ( ) { int N = 5 ; isAutomorphic ( N ) ? cout << "" Automorphic "" : cout << "" Not ▁ Automorphic "" ; return 0 ; }","['bool isAutomorphic ( int N ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 bool isAutomorphic ( int N ) {
"
180,Number with maximum number of prime factors | C ++ program to find integer having maximum number of prime factor in first N natural numbers ; Return smallest number having maximum prime factors . ; default value of boolean is false ; Sieve of eratosthenes ; Storing prime numbers . ; Generating number having maximum prime factors . ; Driven Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { bool arr [ N + 5 ] ; memset ( arr , true , sizeof ( arr ) ) ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( arr [ i ] ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = false ; } vector < int > prime ; prime . push_back ( 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) if ( arr [ i ] ) prime . push_back ( i ) ; int i = 0 , ans = 1 ; while ( ans * prime [ i ] <= N && i < prime . size ( ) ) { ans *= prime [ i ] ; i ++ ; } return ans ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }",Number with maximum number of prime factors.,"#include <bits/stdc++.h> 
 using namespace std ; int maxPrimefactorNum ( int N ) { bool arr [ N + 5 ] ; memset ( arr , true , sizeof ( arr ) ) ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( arr [ i ] ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = false ; } vector < int > prime ; prime . push_back ( 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) if ( arr [ i ] ) prime . push_back ( i ) ; int i = 0 , ans = 1 ; while ( ans * prime [ i ] <= N && i < prime . size ( ) ) { ans *= prime [ i ] ; i ++ ; } return ans ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }","['int maxPrimefactorNum ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxPrimefactorNum ( int N ) {
"
181,"Highest power of 2 less than or equal to given number | C ++ program to find highest power of 2 smaller than or equal to n . ; check for the set bits ; Then we remove all but the top bit by xor ' ing ▁ the ▁ ▁ string ▁ of ▁ 1' s with that string of 1 ' s ▁ shifted ▁ one ▁ to ▁ ▁ the ▁ left , ▁ and ▁ we ▁ end ▁ up ▁ with ▁ just ▁ the ▁ one ▁ top ▁ bit ▁ ▁ followed ▁ by ▁ 0' s . ; Driver code","#include <iostream> NEW_LINE using namespace std ; unsigned highestPowerof2 ( unsigned x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) << "" STRNEWLINE "" ; return 0 ; }",Highest power of 2 less than or equal to given number.,"#include <iostream> 
 using namespace std ; unsigned highestPowerof2 ( unsigned x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) << "" STRNEWLINE "" ; return 0 ; }","['unsigned highestPowerof2 ( unsigned x ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 unsigned highestPowerof2 ( unsigned x ) {
"
182,Sum of all proper divisors of a natural number | C ++ program to find sum of all divisors of a natural number ; Function to calculate sum of all proper divisors num -- > given natural number ; Final result of summation of divisors ; there will be no proper divisor ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Driver program to run the case,#include <bits/stdc++.h> NEW_LINE using namespace std ; int divSum ( int num ) { int result = 0 ; if ( num == 1 ) return result ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } int main ( ) { int num = 36 ; cout << divSum ( num ) ; return 0 ; },Sum of all proper divisors of a natural number.,"#include <bits/stdc++.h> 
 using namespace std ; int divSum ( int num ) { int result = 0 ; if ( num == 1 ) return result ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } int main ( ) { int num = 36 ; cout << divSum ( num ) ; return 0 ; }","['int divSum ( int num ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int divSum ( int num ) {
"
185,Length of the Longest Consecutive 1 s in Binary Representation | C ++ program to find length of the longest consecutive 1 s in binary representation of a number . ; Function to find length of the longest consecutive 1 s in binary representation of a number ; Initialize result ; Count the number of iterations to reach x = 0. ; This operation reduces length of every sequence of 1 s by one . ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } int main ( ) { cout << maxConsecutiveOnes ( 14 ) << endl ; cout << maxConsecutiveOnes ( 222 ) << endl ; return 0 ; },Length of the Longest Consecutive 1 s in Binary Representation.,"#include <bits/stdc++.h> 
 using namespace std ; int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } int main ( ) { cout << maxConsecutiveOnes ( 14 ) << endl ; cout << maxConsecutiveOnes ( 222 ) << endl ; return 0 ; }","['int maxConsecutiveOnes ( int x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxConsecutiveOnes ( int x ) {
"
186,Subtract two numbers without using arithmetic operators | C ++ program to Subtract two numbers without using arithmetic operators ; Iterate till there is no carry ; borrow contains common set bits of y and unset bits of x ; Subtraction of bits of x and y where at least one of the bits is not set ; Borrow is shifted by one so that subtracting it from x gives the required sum ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } int main ( ) { int x = 29 , y = 13 ; cout << "" x ▁ - ▁ y ▁ is ▁ "" << subtract ( x , y ) ; return 0 ; }",Subtract two numbers without using arithmetic operators.,"#include <iostream> 
 using namespace std ; int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } int main ( ) { int x = 29 , y = 13 ; cout << "" x ▁ - ▁ y ▁ is ▁ "" << subtract ( x , y ) ; return 0 ; }","['int subtract ( int x , int y ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int subtract ( int x , int y ) {
"
187,Subtract two numbers without using arithmetic operators | CPP Program to subtract two Number without using arithmetic operator Recursive implementation . ; Driver program,"#include <iostream> NEW_LINE using namespace std ; int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } int main ( ) { int x = 29 , y = 13 ; cout << "" x ▁ - ▁ y ▁ is ▁ "" << subtract ( x , y ) ; return 0 ; }",Subtract two numbers without using arithmetic operators.,"#include <iostream> 
 using namespace std ; int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } int main ( ) { int x = 29 , y = 13 ; cout << "" x ▁ - ▁ y ▁ is ▁ "" << subtract ( x , y ) ; return 0 ; }","['int subtract ( int x , int y ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int subtract ( int x , int y ) {
"
190,Minimize Array length by repeatedly replacing co | C ++ Program for the above approach ; Function to find the final array length by replacing coprime pair with 1 ; Iterate over all pairs of element ; Check if gcd is 1 ; If no coprime pair found return false ; Driver code ; Check if atleast one coprime pair exists in the array ; If no such pair exists,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool hasCoprimePair ( vector < int > & arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( arr [ i ] , arr [ j ] ) == 1 ) { return true ; } } } return false ; } int main ( ) { int n = 3 ; vector < int > arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { cout << 1 << endl ; } else { cout << n << endl ; } }",Minimize Array length by repeatedly replacing co.,"#include <bits/stdc++.h> 
 using namespace std ; bool hasCoprimePair ( vector < int > & arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( arr [ i ] , arr [ j ] ) == 1 ) { return true ; } } } return false ; } int main ( ) { int n = 3 ; vector < int > arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { cout << 1 << endl ; } else { cout << n << endl ; } }","['bool hasCoprimePair ( vector < int > & arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool hasCoprimePair ( vector < int > & arr , int n ) {
"
191,"Count of ways to split N into Triplets forming a Triangle | C ++ Program to implement the above approach ; Function to return the required number of ways ; Check if a , b and c can form a triangle ; Return number of ways ; Driver Code",#include <bits/stdc++.h> NEW_LINE using namespace std ; int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } int main ( ) { int n = 15 ; cout << Numberofways ( n ) << endl ; return 0 ; },Count of ways to split N into Triplets forming a Triangle.,"#include <bits/stdc++.h> 
 using namespace std ; int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } int main ( ) { int n = 15 ; cout << Numberofways ( n ) << endl ; return 0 ; }","['int Numberofways ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Numberofways ( int n ) {
"
192,Count of pairs having each element equal to index of the other from an Array | C ++ program to implement the above approach ; Function to print the count of pair ; Iterate over all the elements of the array ; Increment the count ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } cout << ( count / 2 ) << endl ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( N , arr ) ; }",Count of pairs having each element equal to index of the other from an Array.,"#include <bits/stdc++.h> 
 using namespace std ; void countPairs ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } cout << ( count / 2 ) << endl ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( N , arr ) ; }","['void countPairs ( int N , int arr [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countPairs ( int N , int arr [ ] ) {
"
193,Find length of longest Fibonacci like subsequence | CPP implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all array elements in a hash table ; check until next fib element is found ; next element of fib subseq ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestFibSubseq ( int A [ ] , int n ) { unordered_set < int > S ( A , A + n ) ; int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 2 ; while ( S . find ( y ) != S . end ( ) ) { int z = x + y ; x = y ; y = z ; maxLen = max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << LongestFibSubseq ( A , n ) ; return 0 ; }",Find length of longest Fibonacci like subsequence.,"#include <bits/stdc++.h> 
 using namespace std ; int LongestFibSubseq ( int A [ ] , int n ) { unordered_set < int > S ( A , A + n ) ; int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 2 ; while ( S . find ( y ) != S . end ( ) ) { int z = x + y ; x = y ; y = z ; maxLen = max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << LongestFibSubseq ( A , n ) ; return 0 ; }","['int LongestFibSubseq ( int A [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int LongestFibSubseq ( int A [ ] , int n ) {
"
194,Maximize count of elements that can be selected having minimum difference between their sum and K | C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort he array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }",Maximize count of elements that can be selected having minimum difference between their sum and K.,"#include <bits/stdc++.h> 
 using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }","['int CountMaximum ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int CountMaximum ( int arr [ ] , int n , int k ) {
"
196,Length of diagonals of a Rhombus using length of Side and vertex Angle | C ++ program to implement the above approach ; Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double Length_Diagonals ( int a , double theta ) { double p = a * sqrt ( 2 + ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; double q = a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; cout << fixed << setprecision ( 2 ) << p << "" ▁ "" << q ; } int main ( ) { int a = 6 ; int theta = 45 ; Length_Diagonals ( a , theta ) ; return 0 ; }",Length of diagonals of a Rhombus using length of Side and vertex Angle.,"#include <bits/stdc++.h> 
 using namespace std ; double Length_Diagonals ( int a , double theta ) { double p = a * sqrt ( 2 + ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; double q = a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; cout << fixed << setprecision ( 2 ) << p << "" ▁ "" << q ; } int main ( ) { int a = 6 ; int theta = 45 ; Length_Diagonals ( a , theta ) ; return 0 ; }","['double Length_Diagonals ( int a , double theta ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double Length_Diagonals ( int a , double theta ) {
"
197,"Count of even and odd set bit with array element after XOR with K | C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd","#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << "" Even ▁ = ▁ "" << odd << "" , ▁ Odd ▁ = ▁ "" << even ; } else { cout << "" Even ▁ = ▁ "" << even << "" , ▁ Odd ▁ = ▁ "" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }",Count of even and odd set bit with array element after XOR with K.,"#include <bits/stdc++.h> 
 using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << "" Even ▁ = ▁ "" << odd << "" , ▁ Odd ▁ = ▁ "" << even ; } else { cout << "" Even ▁ = ▁ "" << even << "" , ▁ Odd ▁ = ▁ "" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }","['void countEvenOdd ( int arr [ ] , int n , int K ) {', 'int main ( void ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countEvenOdd ( int arr [ ] , int n , int K ) {
"
199,Longest subsequence from an array of pairs having first element increasing and second element decreasing . | C ++ program for the above approach ; Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing ; Base case ; Not include the current pair in the longest subsequence ; Including the current pair in the longest subsequence ; Driver Code ; Given Input ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubSequence ( pair < int , int > A [ ] , int N , int ind = 0 , int lastf = INT_MIN , int lasts = INT_MAX ) { if ( ind == N ) return 0 ; int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ; if ( A [ ind ] . first > lastf && A [ ind ] . second < lasts ) ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] . first , A [ ind ] . second ) + 1 ) ; return ans ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << longestSubSequence ( A , N ) << "" STRNEWLINE "" ; return 0 ; }",Longest subsequence from an array of pairs having first element increasing and second element decreasing ..,"#include <bits/stdc++.h> 
 using namespace std ; int longestSubSequence ( pair < int , int > A [ ] , int N , int ind = 0 , int lastf = INT_MIN , int lasts = INT_MAX ) { if ( ind == N ) return 0 ; int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ; if ( A [ ind ] . first > lastf && A [ ind ] . second < lasts ) ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] . first , A [ ind ] . second ) + 1 ) ; return ans ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << longestSubSequence ( A , N ) << "" STRNEWLINE "" ; return 0 ; }","['int longestSubSequence ( pair < int , int > A [ ] , int N , int ind = 0 , int lastf = INT_MIN , int lasts = INT_MAX ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int longestSubSequence ( pair < int , int > A [ ] , int N , int ind = 0 , int lastf = INT_MIN , int lasts = INT_MAX ) {
"
200,"Count triples with Bitwise AND equal to Zero | C ++ program for the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A [ i ] & A [ j ] ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call","#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }",Count triples with Bitwise AND equal to Zero.,"#include <bits/stdc++.h> 
 #include <iostream> 
 using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }","['int countTriplets ( vector < int > & A ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <iostream> 
 using namespace std ;
 int countTriplets ( vector < int > & A ) {
"
201,"Count ways to reach a score using 1 and 2 with no consecutive 2 s | Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays [ i ] will store count for value i . 3 extra values are to take care of corner case n = 0 ; Loop till "" n + 1"" to compute value for "" n "" ; number of ways if first run is 1 ; Driver code",#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { int noOfWays [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 0 ; cout << CountWays ( n ) ; return 0 ; },Count ways to reach a score using 1 and 2 with no consecutive 2 s.,"#include <iostream> 
 using namespace std ; int CountWays ( int n ) { int noOfWays [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 0 ; cout << CountWays ( n ) ; return 0 ; }","['int CountWays ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int CountWays ( int n ) {
"
202,"Program to print Spiral Pattern |  ; Create row and col to traverse rows and columns ; Variable to determine the movement r = right , l = left , d = down , u = upper ; Array for matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size for the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern","#include <iostream> NEW_LINE using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << "" ▁ "" ; else cout << n << "" ▁ "" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }",Program to print Spiral Pattern.,"#include <iostream> 
 using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << "" ▁ "" ; else cout << n << "" ▁ "" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }","['void printSpiral ( int size ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void printSpiral ( int size ) {
"
203,"Find the last player to be able to flip a character in a Binary String | C ++ program for the above approach ; Function to check if player A wins the game or not ; Stores size of the groups of 0 s ; Stores size of the group of 0 s ; Traverse the array ; Increment c by 1 if a [ i ] is 0 ; Otherwise , push the size in array and reset c to 0 ; If there is no substring of odd length consisting only of 0 s ; If there is only 1 substring of odd length consisting only of 0 s ; Otherwise ; Stores the size of the largest and second largest substrings of 0 s ; Traverse the array v [ ] ; If current element is greater than first , then update both first and second ; If arr [ i ] is in between first and second , then update second ; If the condition is satisfied ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( string a , int n ) { vector < int > v ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) { c ++ ; } else { if ( c != 0 ) v . push_back ( c ) ; c = 0 ; } } if ( c != 0 ) v . push_back ( c ) ; if ( v . size ( ) == 0 ) { cout << "" Player ▁ B "" ; return ; } if ( v . size ( ) == 1 ) { if ( v [ 0 ] & 1 ) cout << "" Player ▁ A "" ; else cout << "" Player ▁ B "" ; return ; } int first = INT_MIN ; int second = INT_MIN ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) && ( first + 1 ) / 2 > second ) cout << "" Player ▁ A "" ; else cout << "" Player ▁ B "" ; } int main ( ) { string S = ""1100011"" ; int N = S . length ( ) ; findWinner ( S , N ) ; return 0 ; }",Find the last player to be able to flip a character in a Binary String.,"#include <bits/stdc++.h> 
 using namespace std ; void findWinner ( string a , int n ) { vector < int > v ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) { c ++ ; } else { if ( c != 0 ) v . push_back ( c ) ; c = 0 ; } } if ( c != 0 ) v . push_back ( c ) ; if ( v . size ( ) == 0 ) { cout << "" Player ▁ B "" ; return ; } if ( v . size ( ) == 1 ) { if ( v [ 0 ] & 1 ) cout << "" Player ▁ A "" ; else cout << "" Player ▁ B "" ; return ; } int first = INT_MIN ; int second = INT_MIN ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) && ( first + 1 ) / 2 > second ) cout << "" Player ▁ A "" ; else cout << "" Player ▁ B "" ; } int main ( ) { string S = ""1100011"" ; int N = S . length ( ) ; findWinner ( S , N ) ; return 0 ; }","['void findWinner ( string a , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findWinner ( string a , int n ) {
"
204,Check if K palindromic strings can be formed from a given string | C ++ program to check whether the string is K palindrome or not ; function to check whether the string is K palindrome or not ; map to frequency of character ; Check when k is given as same as length of string ; iterator for map ; storing the frequency of every character in map ; if K is greater than size of string then return false ; check that number of character having the odd frequency ; if k is less than number of odd frequency character then it is again false other wise true ; Driver code,"#include <iostream> NEW_LINE #include <map> NEW_LINE using namespace std ; bool can_Construct ( string S , int K ) { map < int , int > m ; int i = 0 , j = 0 , p = 0 ; if ( S . length ( ) == K ) { return true ; } map < int , int > :: iterator h ; for ( i = 0 ; i < S . length ( ) ; i ++ ) { m [ S [ i ] ] = m [ S [ i ] ] + 1 ; } if ( K > S . length ( ) ) { return false ; } else { for ( h = m . begin ( ) ; h != m . end ( ) ; h ++ ) { if ( m [ h -> first ] % 2 != 0 ) { p = p + 1 ; } } } if ( K < p ) { return false ; } return true ; } int main ( ) { string S = "" annabelle "" ; int K = 4 ; if ( can_Construct ( S , K ) ) { cout << "" Yes "" ; } else { cout << "" No "" ; } }",Check if K palindromic strings can be formed from a given string.,"#include <iostream> 
 #include <map> 
 using namespace std ; bool can_Construct ( string S , int K ) { map < int , int > m ; int i = 0 , j = 0 , p = 0 ; if ( S . length ( ) == K ) { return true ; } map < int , int > :: iterator h ; for ( i = 0 ; i < S . length ( ) ; i ++ ) { m [ S [ i ] ] = m [ S [ i ] ] + 1 ; } if ( K > S . length ( ) ) { return false ; } else { for ( h = m . begin ( ) ; h != m . end ( ) ; h ++ ) { if ( m [ h -> first ] % 2 != 0 ) { p = p + 1 ; } } } if ( K < p ) { return false ; } return true ; } int main ( ) { string S = "" annabelle "" ; int K = 4 ; if ( can_Construct ( S , K ) ) { cout << "" Yes "" ; } else { cout << "" No "" ; } }","['bool can_Construct ( string S , int K ) {', 'int main ( ) {']","#include <iostream> 
 #include <map> 
 using namespace std ;
 bool can_Construct ( string S , int K ) {
"
206,Program to print Step Pattern | C ++ program to print Step Pattern ; function to print the steps ; declare a flag ; traverse through all the characters in the string ; if the x value is 0. . then we must increment till n ... set flag to true ; if the x value is n - 1 then we must decrement till 0 ... set flag as false ; print x * s ; checking whether to increment or decrement x ; Driver code ; Get the String and the number n ; calling the function,"#include <iostream> NEW_LINE using namespace std ; void steps ( string str , int n ) { bool flag ; int x = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( x == 0 ) flag = true ; if ( x == n - 1 ) flag = false ; for ( int j = 0 ; j < x ; j ++ ) cout << "" * "" ; cout << str [ i ] << "" STRNEWLINE "" ; if ( flag == true ) x ++ ; else x -- ; } } int main ( ) { int n = 4 ; string str = "" GeeksForGeeks "" ; cout << "" String : ▁ "" << str << endl ; cout << "" Max ▁ Length ▁ of ▁ Steps : ▁ "" << n << endl ; steps ( str , n ) ; return 0 ; }",Program to print Step Pattern.,"#include <iostream> 
 using namespace std ; void steps ( string str , int n ) { bool flag ; int x = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( x == 0 ) flag = true ; if ( x == n - 1 ) flag = false ; for ( int j = 0 ; j < x ; j ++ ) cout << "" * "" ; cout << str [ i ] << "" STRNEWLINE "" ; if ( flag == true ) x ++ ; else x -- ; } } int main ( ) { int n = 4 ; string str = "" GeeksForGeeks "" ; cout << "" String : ▁ "" << str << endl ; cout << "" Max ▁ Length ▁ of ▁ Steps : ▁ "" << n << endl ; steps ( str , n ) ; return 0 ; }","['void steps ( string str , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void steps ( string str , int n ) {
"
207,Frequency Measuring Techniques for Competitive Programming | C ++ program to count frequencies of array items ; Mark all array elements as not visited ; Traverse through array elements and count frequencies ; Skip this element if already processed ; Count frequency ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countFreq ( int arr [ ] , int n ) { vector < int > visited ( n , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } cout << arr [ i ] << "" ▁ "" << count << endl ; } } int main ( ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countFreq ( arr , n ) ; return 0 ; }",Frequency Measuring Techniques for Competitive Programming.,"#include <bits/stdc++.h> 
 using namespace std ; void countFreq ( int arr [ ] , int n ) { vector < int > visited ( n , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } cout << arr [ i ] << "" ▁ "" << count << endl ; } } int main ( ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countFreq ( arr , n ) ; return 0 ; }","['void countFreq ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countFreq ( int arr [ ] , int n ) {
"
208,"Check divisibility of binary string by 2 ^ k | C ++ implementation to check whether given binary number is evenly divisible by 2 ^ k or not ; function to check whether given binary number is evenly divisible by 2 ^ k or not ; count of number of 0 from last ; if count = k , number is evenly divisible , so returns true else false ; Driver program to test above ; first example ; Second example","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; } int main ( ) { char str1 [ ] = ""10101100"" ; int k = 2 ; if ( isDivisible ( str1 , k ) ) cout << "" Yes "" << endl ; else cout << "" No "" << "" STRNEWLINE "" ; char str2 [ ] = ""111010100"" ; k = 2 ; if ( isDivisible ( str2 , k ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; return 0 ; }",Check divisibility of binary string by 2 ^ k.,"#include <bits/stdc++.h> 
 using namespace std ; bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; } int main ( ) { char str1 [ ] = ""10101100"" ; int k = 2 ; if ( isDivisible ( str1 , k ) ) cout << "" Yes "" << endl ; else cout << "" No "" << "" STRNEWLINE "" ; char str2 [ ] = ""111010100"" ; k = 2 ; if ( isDivisible ( str2 , k ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; return 0 ; }","['bool isDivisible ( char str [ ] , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isDivisible ( char str [ ] , int k ) {
"
209,"Check if any anagram of a string is palindrome or not |  ; function to check whether characters of a string can form a palindrome ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; Count odd occurring characters ; Return true if odd count is 0 or 1 , ; Driver program to test to print printDups","#include <iostream> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } int main ( ) { canFormPalindrome ( "" geeksforgeeks "" ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; canFormPalindrome ( "" geeksogeeks "" ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }",Check if any anagram of a string is palindrome or not.,"#include <iostream> 
 using namespace std ; #define NO_OF_CHARS  256 
 bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } int main ( ) { canFormPalindrome ( "" geeksforgeeks "" ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; canFormPalindrome ( "" geeksogeeks "" ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }","['bool canFormPalindrome ( string str ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 #define NO_OF_CHARS  256 
 bool canFormPalindrome ( string str ) {
"
210,Program to check if input is an integer or a string | CPP program to check if a given string is a valid integer ; Returns true if s is a number else false ; Driver code ; Saving the input in a string ; Function returns 1 if all elements are in range '0-9' ; Function returns 0 if the input is not an integer,"#include <iostream> NEW_LINE using namespace std ; bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; } int main ( ) { string str = ""6790"" ; if ( isNumber ( str ) ) cout << "" Integer "" ; else cout << "" String "" ; }",Program to check if input is an integer or a string.,"#include <iostream> 
 using namespace std ; bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; } int main ( ) { string str = ""6790"" ; if ( isNumber ( str ) ) cout << "" Integer "" ; else cout << "" String "" ; }","['bool isNumber ( string s ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 bool isNumber ( string s ) {
"
211,Print reverse of a string using recursion | C ++ program to reverse a string using recursion ; Function to print reverse of the passed string ; Driver program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverse ( string str ) { if ( str . size ( ) == 0 ) { return ; } reverse ( str . substr ( 1 ) ) ; cout << str [ 0 ] ; } int main ( ) { string a = "" Geeks ▁ for ▁ Geeks "" ; reverse ( a ) ; return 0 ; }",Print reverse of a string using recursion.,"#include <bits/stdc++.h> 
 using namespace std ; void reverse ( string str ) { if ( str . size ( ) == 0 ) { return ; } reverse ( str . substr ( 1 ) ) ; cout << str [ 0 ] ; } int main ( ) { string a = "" Geeks ▁ for ▁ Geeks "" ; reverse ( a ) ; return 0 ; }","['void reverse ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void reverse ( string str ) {
"
213,Area of a n | C ++ Program to find the area of a regular polygon with given radius ; Function to find the area of a regular polygon ; Side and radius cannot be negative ; Area degree converted to radians ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyarea ( float n , float r ) { if ( r < 0 && n < 0 ) return -1 ; float A = ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } int main ( ) { float r = 9 , n = 6 ; cout << polyarea ( n , r ) << endl ; return 0 ; }",Area of a n.,"#include <bits/stdc++.h> 
 using namespace std ; float polyarea ( float n , float r ) { if ( r < 0 && n < 0 ) return -1 ; float A = ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } int main ( ) { float r = 9 , n = 6 ; cout << polyarea ( n , r ) << endl ; return 0 ; }","['float polyarea ( float n , float r ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float polyarea ( float n , float r ) {
"
214,"Check if a line at 45 degree can divide the plane into two equal weight parts |  ; Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal ; Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates ; storing weight sum upto x - y point ; Finding prefix sum ; Line passes through i , so it neither falls left nor right . ; Driven Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { map < int , int > weight_at_x ; int max_x = -2e3 , min_x = 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = max ( max_x , new_x ) ; min_x = min ( min_x , new_x ) ; weight_at_x [ new_x ] += w [ i ] ; } vector < int > sum_till ; sum_till . push_back ( 0 ) ; for ( int x = min_x ; x <= max_x ; x ++ ) { sum_till . push_back ( sum_till . back ( ) + weight_at_x [ x ] ) ; } int total_sum = sum_till . back ( ) ; int partition_possible = false ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = true ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = true ; } printf ( partition_possible ? "" YES STRNEWLINE "" : "" NO STRNEWLINE "" ) ; } int main ( ) { int n = 3 ; int x [ ] = { -1 , -2 , 1 } ; int y [ ] = { 1 , 1 , -1 } ; int w [ ] = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; return 0 ; }",Check if a line at 45 degree can divide the plane into two equal weight parts.,"#include <bits/stdc++.h> 
 using namespace std ; void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { map < int , int > weight_at_x ; int max_x = -2e3 , min_x = 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = max ( max_x , new_x ) ; min_x = min ( min_x , new_x ) ; weight_at_x [ new_x ] += w [ i ] ; } vector < int > sum_till ; sum_till . push_back ( 0 ) ; for ( int x = min_x ; x <= max_x ; x ++ ) { sum_till . push_back ( sum_till . back ( ) + weight_at_x [ x ] ) ; } int total_sum = sum_till . back ( ) ; int partition_possible = false ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = true ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = true ; } printf ( partition_possible ? "" YES STRNEWLINE "" : "" NO STRNEWLINE "" ) ; } int main ( ) { int n = 3 ; int x [ ] = { -1 , -2 , 1 } ; int y [ ] = { 1 , 1 , -1 } ; int w [ ] = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; return 0 ; }","['void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) {
"
215,Slope of perpendicular to line | C ++ program find slope of perpendicular line ; Function to find the Slope of other line ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; double findPCSlope ( double m ) { return -1.0 / m ; } int main ( ) { double m = 2.0 ; cout << findPCSlope ( m ) ; return 0 ; },Slope of perpendicular to line.,"#include <bits/stdc++.h> 
 using namespace std ; double findPCSlope ( double m ) { return -1.0 / m ; } int main ( ) { double m = 2.0 ; cout << findPCSlope ( m ) ; return 0 ; }","['double findPCSlope ( double m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double findPCSlope ( double m ) {
"
216,Program to find area of a Circular Segment | C ++ Program to find area of segment of a circle ; Function to find area of segment ; Calculating area of sector ; Calculating area of triangle ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float pi = 3.14159 ; float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; } int main ( ) { float radius = 10.0 , angle = 90.0 ; cout << "" Area ▁ of ▁ minor ▁ segment ▁ = ▁ "" << area_of_segment ( radius , angle ) << endl ; cout << "" Area ▁ of ▁ major ▁ segment ▁ = ▁ "" << area_of_segment ( radius , ( 360 - angle ) ) ; }",Program to find area of a Circular Segment.,"#include <bits/stdc++.h> 
 using namespace std ; float pi = 3.14159 ; float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; } int main ( ) { float radius = 10.0 , angle = 90.0 ; cout << "" Area ▁ of ▁ minor ▁ segment ▁ = ▁ "" << area_of_segment ( radius , angle ) << endl ; cout << "" Area ▁ of ▁ major ▁ segment ▁ = ▁ "" << area_of_segment ( radius , ( 360 - angle ) ) ; }","['float area_of_segment ( float radius , float angle ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float pi = 3.14159 ;
 float area_of_segment ( float radius , float angle ) {
"
217,Area of a Circular Sector | C ++ program to find Area of a Sector ; Calculating area of the sector ; Driver code,"#include <iostream> NEW_LINE using namespace std ; void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << "" Angle ▁ not ▁ possible "" ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } } int main ( ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; return 0 ; }",Area of a Circular Sector.,"#include <iostream> 
 using namespace std ; void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << "" Angle ▁ not ▁ possible "" ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } } int main ( ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; return 0 ; }","['void SectorArea ( double radius , double angle ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void SectorArea ( double radius , double angle ) {
"
218,Make two numbers equal by multiplying with their prime factors minimum number of times | C ++ program for the above approach ; Function to calculate total number of prime factor with their prime factor ; Iterate while the number is even ; Reduce to half ; Iterate up to sqrt ( N ) ; Iterate while N has factors of i ; Removing one factor of i ; Function to count the number of factors ; Find the GCD ; Find multiples left in X and Y ; Find prime factor of multiple left in X and Y ; Initialize ans ; Check if it possible to obtain X or not ; Check if it possible to obtain Y or not ; return main ans ; Driver code ; Given Input ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_map < int , int > PrimeFactor ( int N ) { unordered_map < int , int > primef ; while ( N % 2 == 0 ) { if ( primef . count ( 2 ) ) { primef [ 2 ] += 1 ; } else { primef [ 2 ] = 1 ; } N /= 2 ; } for ( int i = 3 ; i <= sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . count ( i ) ) { primef [ i ] += 1 ; } else { primef [ i ] = 1 ; } N /= 2 ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; } int CountToMakeEqual ( int X , int Y ) { int gcdofXY = __gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; unordered_map < int , int > primeX ; unordered_map < int , int > primeY ; primeX = PrimeFactor ( newX ) ; primeY = PrimeFactor ( newY ) ; int ans = 0 ; for ( auto c : primeX ) { if ( X % c . first != 0 ) { return -1 ; } ans += primeX [ c . first ] ; } for ( auto c : primeY ) { if ( Y % c . first != 0 ) { return -1 ; } ans += primeY [ c . first ] ; } return ans ; } int main ( ) { int X = 36 ; int Y = 48 ; int ans = CountToMakeEqual ( X , Y ) ; cout << ans << endl ; return 0 ; }",Make two numbers equal by multiplying with their prime factors minimum number of times.,"#include <bits/stdc++.h> 
 using namespace std ; unordered_map < int , int > PrimeFactor ( int N ) { unordered_map < int , int > primef ; while ( N % 2 == 0 ) { if ( primef . count ( 2 ) ) { primef [ 2 ] += 1 ; } else { primef [ 2 ] = 1 ; } N /= 2 ; } for ( int i = 3 ; i <= sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . count ( i ) ) { primef [ i ] += 1 ; } else { primef [ i ] = 1 ; } N /= 2 ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; } int CountToMakeEqual ( int X , int Y ) { int gcdofXY = __gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; unordered_map < int , int > primeX ; unordered_map < int , int > primeY ; primeX = PrimeFactor ( newX ) ; primeY = PrimeFactor ( newY ) ; int ans = 0 ; for ( auto c : primeX ) { if ( X % c . first != 0 ) { return -1 ; } ans += primeX [ c . first ] ; } for ( auto c : primeY ) { if ( Y % c . first != 0 ) { return -1 ; } ans += primeY [ c . first ] ; } return ans ; } int main ( ) { int X = 36 ; int Y = 48 ; int ans = CountToMakeEqual ( X , Y ) ; cout << ans << endl ; return 0 ; }","['int CountToMakeEqual ( int X , int Y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 unordered_map < int , int > PrimeFactor ( int N ) {
 unordered_map < int , int > primef ;
 while ( N % 2 == 0 ) {
 if ( primef . count ( 2 ) ) {
 primef [ 2 ] += 1 ;
 } else {
 primef [ 2 ] = 1 ;
 } N /= 2 ;
 } for ( int i = 3 ;
 i <= sqrt ( N ) ;
 i ++ ) {
 while ( N % i == 0 ) {
 if ( primef . count ( i ) ) {
 primef [ i ] += 1 ;
 } else {
 primef [ i ] = 1 ;
 } N /= 2 ;
 } } if ( N > 2 ) {
 primef [ N ] = 1 ;
 } return primef ;
 } int CountToMakeEqual ( int X , int Y ) {
"
221,Minimum number of swaps required to sort an array of first N number | Function to find minimum swaps ; Initialise count variable ; If current element is not at the right position ; Swap current element with correct position of that element ; Increment for next index when current element is at correct position ; Driver code ; Function to find minimum swaps,"#include <iostream> NEW_LINE using namespace std ; int minimumSwaps ( int arr [ ] , int n ) { int count = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumSwaps ( arr , n ) ; }",Minimum number of swaps required to sort an array of first N number.,"#include <iostream> 
 using namespace std ; int minimumSwaps ( int arr [ ] , int n ) { int count = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumSwaps ( arr , n ) ; }","['int minimumSwaps ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int minimumSwaps ( int arr [ ] , int n ) {
"
227,Split an array into subarrays with maximum Bitwise XOR of their respective Bitwise OR values | C ++ program for the above approach ; Function to find the bitwise OR of array elements ; Stores the resultant maximum value of Bitwise XOR ; Traverse the array arr [ ] ; Return the maximum value res ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaxXOR ( arr , N ) ; return 0 ; }",Split an array into subarrays with maximum Bitwise XOR of their respective Bitwise OR values.,"#include <bits/stdc++.h> 
 using namespace std ; int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaxXOR ( arr , N ) ; return 0 ; }","['int MaxXOR ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MaxXOR ( int arr [ ] , int N ) {
"
231,Maximize count of Decreasing Consecutive Subsequences from an Array | C ++ program to implement the above approach ; Function to find the maximum number number of required subsequences ; HashMap to store number of arrows available with height of arrow as key ; Stores the maximum count of possible subsequences ; Stores the count of possible subsequences ; Check if i - th element can be part of any of the previous subsequence ; Count of subsequences possible with arr [ i ] as the next element ; If more than one such subsequence exists ; Include arr [ i ] in a subsequence ; Otherwise ; Increase count of subsequence possible with arr [ i ] - 1 as the next element ; Start a new subsequence ; Increase count of subsequence possible with arr [ i ] - 1 as the next element ; Return the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubsequences ( int arr [ ] , int n ) { unordered_map < int , int > m ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . find ( arr [ i ] ) != m . end ( ) ) { count = m [ arr [ i ] ] ; if ( count > 1 ) { m [ arr [ i ] ] = count - 1 ; } else m . erase ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } } return maxCount ; } int main ( ) { int n = 5 ; int arr [ ] = { 4 , 5 , 2 , 1 , 4 } ; cout << maxSubsequences ( arr , n ) << endl ; }",Maximize count of Decreasing Consecutive Subsequences from an Array.,"#include <bits/stdc++.h> 
 using namespace std ; int maxSubsequences ( int arr [ ] , int n ) { unordered_map < int , int > m ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . find ( arr [ i ] ) != m . end ( ) ) { count = m [ arr [ i ] ] ; if ( count > 1 ) { m [ arr [ i ] ] = count - 1 ; } else m . erase ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } } return maxCount ; } int main ( ) { int n = 5 ; int arr [ ] = { 4 , 5 , 2 , 1 , 4 } ; cout << maxSubsequences ( arr , n ) << endl ; }","['int maxSubsequences ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxSubsequences ( int arr [ ] , int n ) {
"
232,Remove the first and last occurrence of a given Character from a String | C ++ Program to implement the above approach ; Function to remove first and last occurrence of a given character from the given string ; Traverse the given string from the beginning ; If ch is found ; Traverse the given string from the end ; If ch is found ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOcc ( string & s , char ch ) { for ( int i = 0 ; s [ i ] ; i ++ ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } for ( int i = s . length ( ) - 1 ; i > -1 ; i -- ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } return s ; } int main ( ) { string s = "" hello ▁ world "" ; char ch = ' l ' ; cout << removeOcc ( s , ch ) ; return 0 ; }",Remove the first and last occurrence of a given Character from a String.,"#include <bits/stdc++.h> 
 using namespace std ; string removeOcc ( string & s , char ch ) { for ( int i = 0 ; s [ i ] ; i ++ ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } for ( int i = s . length ( ) - 1 ; i > -1 ; i -- ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } return s ; } int main ( ) { string s = "" hello ▁ world "" ; char ch = ' l ' ; cout << removeOcc ( s , ch ) ; return 0 ; }","['string removeOcc ( string & s , char ch ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string removeOcc ( string & s , char ch ) {
"
233,Minimum steps for increasing and decreasing Array to reach either 0 or N | C ++ program for the above approach ; Function that finds the minimum steps to reach either 0 or N for given increasing and decreasing arrays ; Initialize variable to find the minimum element ; Find minimum element in increasing [ ] array ; Initialize variable to find the maximum element ; Find maximum element in decreasing [ ] array ; Find the minimum steps ; Print the minimum steps ; Driver code ; Given N ; Given increasing and decreasing array ; Find length of arrays increasing and decreasing ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSteps ( int N , int increasing [ ] , int decreasing [ ] , int m1 , int m2 ) { int mini = INT_MAX ; for ( int i = 0 ; i < m1 ; i ++ ) { if ( mini > increasing [ i ] ) mini = increasing [ i ] ; } int maxi = INT_MIN ; for ( int i = 0 ; i < m2 ; i ++ ) { if ( maxi < decreasing [ i ] ) maxi = decreasing [ i ] ; } int minSteps = max ( maxi , N - mini ) ; cout << minSteps << endl ; } int main ( ) { int N = 7 ; int increasing [ ] = { 3 , 5 } ; int decreasing [ ] = { 6 } ; int m1 = sizeof ( increasing ) / sizeof ( increasing [ 0 ] ) ; int m2 = sizeof ( decreasing ) / sizeof ( decreasing [ 0 ] ) ; minSteps ( N , increasing , decreasing , m1 , m2 ) ; }",Minimum steps for increasing and decreasing Array to reach either 0 or N.,"#include <bits/stdc++.h> 
 using namespace std ; void minSteps ( int N , int increasing [ ] , int decreasing [ ] , int m1 , int m2 ) { int mini = INT_MAX ; for ( int i = 0 ; i < m1 ; i ++ ) { if ( mini > increasing [ i ] ) mini = increasing [ i ] ; } int maxi = INT_MIN ; for ( int i = 0 ; i < m2 ; i ++ ) { if ( maxi < decreasing [ i ] ) maxi = decreasing [ i ] ; } int minSteps = max ( maxi , N - mini ) ; cout << minSteps << endl ; } int main ( ) { int N = 7 ; int increasing [ ] = { 3 , 5 } ; int decreasing [ ] = { 6 } ; int m1 = sizeof ( increasing ) / sizeof ( increasing [ 0 ] ) ; int m2 = sizeof ( decreasing ) / sizeof ( decreasing [ 0 ] ) ; minSteps ( N , increasing , decreasing , m1 , m2 ) ; }","['void minSteps ( int N , int increasing [ ] , int decreasing [ ] , int m1 , int m2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minSteps ( int N , int increasing [ ] , int decreasing [ ] , int m1 , int m2 ) {
"
234,Minimum number of adjacent swaps required to convert a permutation to another permutation by given condition | C ++ program for the above approach ; Function to find the minimum number of swaps ; New array to convert to 1 - based indexing ; Keeps count of swaps ; Check if it is an ' X ' position ; Corner Case ; Swap ; Print the minimum swaps ; Driver Code ; Given Number N ; Given Permutation of N numbers ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( vector < int > & P , int n ) { vector < int > arr ; arr . push_back ( 0 ) ; for ( auto x : P ) arr . push_back ( x ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; cnt ++ ; } } if ( arr [ n ] == n ) { swap ( arr [ n - 1 ] , arr [ n ] ) ; cnt ++ ; } cout << cnt << endl ; } signed main ( ) { int N = 9 ; vector < int > P = { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ; solve ( P , N ) ; return 0 ; }",Minimum number of adjacent swaps required to convert a permutation to another permutation by given condition.,"#include <bits/stdc++.h> 
 using namespace std ; void solve ( vector < int > & P , int n ) { vector < int > arr ; arr . push_back ( 0 ) ; for ( auto x : P ) arr . push_back ( x ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; cnt ++ ; } } if ( arr [ n ] == n ) { swap ( arr [ n - 1 ] , arr [ n ] ) ; cnt ++ ; } cout << cnt << endl ; } signed main ( ) { int N = 9 ; vector < int > P = { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ; solve ( P , N ) ; return 0 ; }","['void solve ( vector < int > & P , int n ) {', 'signed main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void solve ( vector < int > & P , int n ) {
"
237,"Count distinct sequences obtained by replacing all elements of subarrays having equal first and last elements with the first element any number of times | C ++ program for the above approach ; Function to count number of sequences satisfying the given criteria ; Stores the index of the last occurrence of the element ; Initialize an array to store the number of different sequences that are possible of length i ; Base Case ; If no operation is applied on ith element ; If operation is applied on ith element ; Update the last occurrence of curEle ; Finally , print the answer ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPossiblities ( int arr [ ] , int n ) { int lastOccur [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = -1 ; } int dp [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ; dp [ i ] = dp [ i - 1 ] ; if ( lastOccur [ curEle ] != -1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; } lastOccur [ curEle ] = i ; } cout << dp [ n ] << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPossiblities ( arr , N ) ; return 0 ; }",Count distinct sequences obtained by replacing all elements of subarrays having equal first and last elements with the first element any number of times.,"#include <bits/stdc++.h> 
 using namespace std ; void countPossiblities ( int arr [ ] , int n ) { int lastOccur [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = -1 ; } int dp [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ; dp [ i ] = dp [ i - 1 ] ; if ( lastOccur [ curEle ] != -1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; } lastOccur [ curEle ] = i ; } cout << dp [ n ] << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPossiblities ( arr , N ) ; return 0 ; }","['void countPossiblities ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countPossiblities ( int arr [ ] , int n ) {
"
238,Maximum sum possible from given Matrix by performing given operations | C ++ program for the above approach ; Function to print the maximum sum ; Dp table ; Initializing dp array with 0 s ; Base case ; Traverse each column ; Update answer for both rows ; Print the maximum sum ; Driver Code ; Given array ; Number of Columns ; Function calls,"#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void maxSum ( vector < vector < int > > arr , int n , int m ) { vector < vector < int > > dp ( n ) ; for ( int i = 0 ; i < 2 ; i ++ ) { dp [ i ] = vector < int > ( m ) ; for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } cout << max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int N = arr [ 0 ] . size ( ) ; maxSum ( arr , 2 , N ) ; return 0 ; }",Maximum sum possible from given Matrix by performing given operations.,"#include <iostream> 
 #include <vector> 
 using namespace std ; void maxSum ( vector < vector < int > > arr , int n , int m ) { vector < vector < int > > dp ( n ) ; for ( int i = 0 ; i < 2 ; i ++ ) { dp [ i ] = vector < int > ( m ) ; for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } cout << max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int N = arr [ 0 ] . size ( ) ; maxSum ( arr , 2 , N ) ; return 0 ; }","['void maxSum ( vector < vector < int > > arr , int n , int m ) {', 'int main ( ) {']","#include <iostream> 
 #include <vector> 
 using namespace std ;
 void maxSum ( vector < vector < int > > arr , int n , int m ) {
"
239,Maximum sum possible from given Matrix by performing given operations | C ++ code for the above approach ; Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row ; Initialize variables ; Traverse each column ; Print answer ; Driver Code ; Numberof columns,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( vector < vector < int > > arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = max ( r2 , temp + arr [ 1 ] [ i ] ) ; } cout << max ( r1 , r2 ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int n = arr [ 0 ] . size ( ) ; maxSum ( arr , n ) ; return 0 ; }",Maximum sum possible from given Matrix by performing given operations.,"#include <bits/stdc++.h> 
 using namespace std ; void maxSum ( vector < vector < int > > arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = max ( r2 , temp + arr [ 1 ] [ i ] ) ; } cout << max ( r1 , r2 ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int n = arr [ 0 ] . size ( ) ; maxSum ( arr , n ) ; return 0 ; }","['void maxSum ( vector < vector < int > > arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maxSum ( vector < vector < int > > arr , int n ) {
"
241,Longest subsequence possible that starts and ends with 1 and filled with 0 in the middle | C ++ Program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle ; Prefix array to store the occurences of '1' and '0' ; Initialise prefix arrays with 0 ; Iterate over the length of the string ; If current character is '1' ; If current character is '0' ; Add '1' available for the first string ; Add '0' available for the second string ; Add '1' available for the third string ; Update answer ; Print the final result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubseq ( string s , int length ) { int ones [ length + 1 ] , zeroes [ length + 1 ] ; memset ( ones , 0 , sizeof ( ones ) ) ; memset ( zeroes , 0 , sizeof ( zeroes ) ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( s [ i ] == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; } else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = INT_MIN ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) { x += ones [ i ] ; x += ( zeroes [ j ] - zeroes [ i ] ) ; x += ( ones [ length ] - ones [ j ] ) ; answer = max ( answer , x ) ; x = 0 ; } } cout << answer << endl ; } int main ( ) { string s = ""10010010111100101"" ; int length = s . length ( ) ; longestSubseq ( s , length ) ; return 0 ; }",Longest subsequence possible that starts and ends with 1 and filled with 0 in the middle.,"#include <bits/stdc++.h> 
 using namespace std ; int longestSubseq ( string s , int length ) { int ones [ length + 1 ] , zeroes [ length + 1 ] ; memset ( ones , 0 , sizeof ( ones ) ) ; memset ( zeroes , 0 , sizeof ( zeroes ) ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( s [ i ] == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; } else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = INT_MIN ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) { x += ones [ i ] ; x += ( zeroes [ j ] - zeroes [ i ] ) ; x += ( ones [ length ] - ones [ j ] ) ; answer = max ( answer , x ) ; x = 0 ; } } cout << answer << endl ; } int main ( ) { string s = ""10010010111100101"" ; int length = s . length ( ) ; longestSubseq ( s , length ) ; return 0 ; }","['int longestSubseq ( string s , int length ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int longestSubseq ( string s , int length ) {
"
242,Largest Square in a Binary Matrix with at most K 1 s for multiple Queries | C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to calculate the largest square with atmost K 1 s for Q queries ; Loop to solve for each query ; Traversing the each sub square and counting total ; Breaks when exceeds the maximum count ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << "" STRNEWLINE "" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }",Largest Square in a Binary Matrix with at most K 1 s for multiple Queries.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << "" STRNEWLINE "" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }","['void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX = 100 ;
 void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {
"
243,Largest Square in a Binary Matrix with at most K 1 s for multiple Queries | C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to find the largest square in the matrix such that it contains atmost K 1 's ; Precomputing the countDP prefix sum of the matrix ; Loop to solve Queries ; Calculating the maximum possible distance of the centre from edge ; Calculating the number of 1 s in the submatrix ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << "" STRNEWLINE "" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }",Largest Square in a Binary Matrix with at most K 1 s for multiple Queries.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << "" STRNEWLINE "" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }","['void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX = 100 ;
 void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {
"
244,"N consecutive ropes problem | C ++ implementation of the approach ; Function to return the minimum cost to connect the given ropes ; dp [ i ] [ j ] = minimum cost in range ( i , j ) sum [ i ] [ j ] = sum of range ( i , j ) ; Initializing the sum table ; Computing minimum cost for all the possible interval ( i , j ) Left range ; Right range ; No cost for a single rope ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinCost ( int arr [ ] , int n ) { int dp [ n + 5 ] [ n + 5 ] , sum [ n + 5 ] [ n + 5 ] ; memset ( sum , 0 , sizeof ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinCost ( arr , n ) ; return 0 ; }",N consecutive ropes problem.,"#include <bits/stdc++.h> 
 using namespace std ; int MinCost ( int arr [ ] , int n ) { int dp [ n + 5 ] [ n + 5 ] , sum [ n + 5 ] [ n + 5 ] ; memset ( sum , 0 , sizeof ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinCost ( arr , n ) ; return 0 ; }","['int MinCost ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MinCost ( int arr [ ] , int n ) {
"
246,Remove an element to maximize the GCD of the given array | C ++ implementation of the above approach ; Function to return the maximized gcd after removing a single element from the given array ; Prefix and Suffix arrays ; Single state dynamic programming relation for storing gcd of first i elements from the left in Prefix [ i ] ; Initializing Suffix array ; Single state dynamic programming relation for storing gcd of all the elements having greater than or equal to i in Suffix [ i ] ; If first or last element of the array has to be removed ; If any other element is replaced ; Return the maximized gcd ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxGCD ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 14 , 17 , 28 , 70 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxGCD ( a , n ) ; return 0 ; }",Remove an element to maximize the GCD of the given array.,"#include <bits/stdc++.h> 
 using namespace std ; int MaxGCD ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 14 , 17 , 28 , 70 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxGCD ( a , n ) ; return 0 ; }","['int MaxGCD ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MaxGCD ( int a [ ] , int n ) {
"
248,Find the sum of first N odd Fibonacci numbers | CPP program to Find the sum of first N odd Fibonacci numbers ; Function to calculate sum of first N odd Fibonacci numbers ; base values ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE long long sumOddFibonacci ( int n ) { long long Sum [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; } int main ( ) { long long n = 6 ; cout << sumOddFibonacci ( n ) ; return 0 ; },Find the sum of first N odd Fibonacci numbers.,"#include <bits/stdc++.h> 
 using namespace std ; #define mod  1000000007 
 long long sumOddFibonacci ( int n ) { long long Sum [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; } int main ( ) { long long n = 6 ; cout << sumOddFibonacci ( n ) ; return 0 ; }","['long sumOddFibonacci ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define mod  1000000007 
 long long sumOddFibonacci ( int n ) {
"
249,Minimize the total number of teddies to be distributed | C ++ implementation of the above approach ; Initializing one tablet for each student ; if left adjacent is having higher marks review and change all the dp values assigned before until assigned dp values are found wrong according to given constrains ; if right adjacent is having higher marks add one in dp of left adjacent and assign to right one ; Driver Code ; n number of students ; marks of students ; solution of problem,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long fun ( int marks [ ] , int n ) { long long dp [ n ] , temp ; fill ( dp , dp + n , 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; } int main ( ) { int n = 6 ; int marks [ 6 ] = { 1 , 4 , 5 , 2 , 2 , 1 } ; cout << fun ( marks , n ) ; return 0 ; }",Minimize the total number of teddies to be distributed.,"#include <bits/stdc++.h> 
 using namespace std ; long long fun ( int marks [ ] , int n ) { long long dp [ n ] , temp ; fill ( dp , dp + n , 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; } int main ( ) { int n = 6 ; int marks [ 6 ] = { 1 , 4 , 5 , 2 , 2 , 1 } ; cout << fun ( marks , n ) ; return 0 ; }","['long fun ( int marks [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long long fun ( int marks [ ] , int n ) {
"
250,Number of ways to reach Nth floor by taking at | C ++ program to reach N - th stair by taking a maximum of K leap ; elements of combo [ ] stores the no of possible ways to reach it by all combinations of k leaps or less ; assuming leap 0 exist and assigning its value to 1 for calculation ; loop to iterate over all possible leaps upto k ; ; in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less ; if the leap is not more than the i - j ; calculate the value and store in combo [ j ] to reuse it for next leap calculation for the jth stair ; returns the no of possible number of leaps to reach the top of building of n stairs ; Driver Code ; N i the no of total stairs K is the value of the greatest leap,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int N , int K ) { int combo [ N + 1 ] = { 0 } ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } int main ( ) { int N = 29 ; int K = 5 ; cout << solve ( N , K ) ; solve ( N , K ) ; return 0 ; }",Number of ways to reach Nth floor by taking at.,"#include <bits/stdc++.h> 
 using namespace std ; int solve ( int N , int K ) { int combo [ N + 1 ] = { 0 } ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } int main ( ) { int N = 29 ; int K = 5 ; cout << solve ( N , K ) ; solve ( N , K ) ; return 0 ; }","['int solve ( int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int solve ( int N , int K ) {
"
252,Counts paths from a point to reach Origin | C ++ Program for above approach ; Function to find binomial Coefficient ; Constructing Pascal 's Triangle ; Driver Code,"#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 3 , m = 2 ; cout << "" Number ▁ of ▁ Paths : ▁ "" << binomialCoeff ( n + m , n ) << endl ; return 0 ; }",Counts paths from a point to reach Origin.,"#include <iostream> 
 #include <bits/stdc++.h> 
 using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 3 , m = 2 ; cout << "" Number ▁ of ▁ Paths : ▁ "" << binomialCoeff ( n + m , n ) << endl ; return 0 ; }","['int binomialCoeff ( int n , int k ) {', 'int main ( ) {']","#include <iostream> 
 #include <bits/stdc++.h> 
 using namespace std ;
 int binomialCoeff ( int n , int k ) {
"
253,"Longest Common Increasing Subsequence ( LCS + LIS ) | A C ++ Program to find length of the Longest Common Increasing Subsequence ( LCIS ) ; Returns the length and the LCIS of two arrays arr1 [ 0. . n - 1 ] and arr2 [ 0. . m - 1 ] ; table [ j ] is going to store length of LCIS ending with arr2 [ j ] . We initialize it as 0 , ; Traverse all elements of arr1 [ ] ; Initialize current length of LCIS ; For each element of arr1 [ ] , traverse all elements of arr2 [ ] . ; If both the array have same elements . Note that we don 't break the loop here. ; Now seek for previous smaller common element for current element of arr1 ; The maximum value in table [ ] is out result ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } int main ( ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" Length ▁ of ▁ LCIS ▁ is ▁ "" << LCIS ( arr1 , n , arr2 , m ) ; return ( 0 ) ; }",Longest Common Increasing Subsequence ( LCS + LIS ).,"#include <bits/stdc++.h> 
 using namespace std ; int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } int main ( ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" Length ▁ of ▁ LCIS ▁ is ▁ "" << LCIS ( arr1 , n , arr2 , m ) ; return ( 0 ) ; }","['int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) {
"
254,Length of longest common prefix possible by rearranging strings in a given array | C ++ program to implement the above approach ; Function to get the length of the longest common prefix by rearranging the strings ; freq [ i ] [ j ] : stores the frequency of a character ( = j ) in a string arr [ i ] ; Traverse the given array ; Stores length of current string ; Traverse current string of the given array ; Update the value of freq [ i ] [ arr [ i ] [ j ] ] ; Stores the length of longest common prefix ; Count the minimum frequency of each character in in all the strings of arr [ ] ; Stores minimum value in each row of freq [ ] [ ] ; Calculate minimum frequency of current character in all the strings . ; Update minRowVal ; Update maxLen ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int longComPre ( string arr [ ] , int N ) { int freq [ N ] [ 256 ] ; for ( let String of DistString ) { for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] [ j ] ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; } int main ( ) { string arr [ ] = { "" aabdc "" , "" abcd "" , "" aacd "" } ; int N = 3 ; cout << longComPre ( arr , N ) ; }",Length of longest common prefix possible by rearranging strings in a given array.,"#include <bits/stdc++.h> 
 using namespace std ; int longComPre ( string arr [ ] , int N ) { int freq [ N ] [ 256 ] ; for ( let String of DistString ) { for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] [ j ] ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; } int main ( ) { string arr [ ] = { "" aabdc "" , "" abcd "" , "" aacd "" } ; int N = 3 ; cout << longComPre ( arr , N ) ; }","['int longComPre ( string arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int longComPre ( string arr [ ] , int N ) {
"
255,Remove characters from a String that appears exactly K times | C ++ program to remove characters from a String that appears exactly K times ; Function to reduce the string by removing the characters which appears exactly k times ; Hash table initialised to 0 ; Increment the frequency of the character ; To store answer ; Next index in reduced string ; Append the characters which appears exactly k times ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; string removeChars ( char arr [ ] , int k ) { int hash [ MAX_CHAR ] = { 0 } ; int n = strlen ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ; string ans = "" "" ; int index = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; } int main ( ) { char str [ ] = "" geeksforgeeks "" ; int k = 2 ; cout << removeChars ( str , k ) ; return 0 ; }",Remove characters from a String that appears exactly K times.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX_CHAR = 26 ; string removeChars ( char arr [ ] , int k ) { int hash [ MAX_CHAR ] = { 0 } ; int n = strlen ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ; string ans = "" "" ; int index = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; } int main ( ) { char str [ ] = "" geeksforgeeks "" ; int k = 2 ; cout << removeChars ( str , k ) ; return 0 ; }","['string removeChars ( char arr [ ] , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX_CHAR = 26 ;
 string removeChars ( char arr [ ] , int k ) {
"
256,Contiguous subsegments of a string having distinct subsequent characters | C ++ implementation of the approach ; Function that prints the segments ; New array for every iteration ; Check if iterator points to end or not ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void sub_segments ( string str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { string newlist = str . substr ( x , n ) ; list < char > arr ; list < char > :: iterator it ; for ( auto y : newlist ) { it = find ( arr . begin ( ) , arr . end ( ) , y ) ; if ( it == arr . end ( ) ) arr . push_back ( y ) ; } for ( auto y : arr ) cout << y ; cout << endl ; } } int main ( ) { string str = "" geeksforgeeksgfg "" ; int n = 4 ; sub_segments ( str , n ) ; }",Contiguous subsegments of a string having distinct subsequent characters.,"#include <bits/stdc++.h> 
 using namespace std ; void sub_segments ( string str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { string newlist = str . substr ( x , n ) ; list < char > arr ; list < char > :: iterator it ; for ( auto y : newlist ) { it = find ( arr . begin ( ) , arr . end ( ) , y ) ; if ( it == arr . end ( ) ) arr . push_back ( y ) ; } for ( auto y : arr ) cout << y ; cout << endl ; } } int main ( ) { string str = "" geeksforgeeksgfg "" ; int n = 4 ; sub_segments ( str , n ) ; }","['void sub_segments ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void sub_segments ( string str , int n ) {
"
257,"Program to find the Encrypted word | C ++ program to implement the above approach ; Function to find the encrypted string ; to store the encrypted string ; after ' z ' , it should go to a . ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWord ( string c , int n ) { int co = 0 , i ; string s ( n , ' ▁ ' ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ; if ( c [ i ] + co <= 122 ) s [ i ] = ( char ) ( ( int ) c [ i ] + co ) ; else s [ i ] = ( char ) ( ( int ) c [ i ] + co - 26 ) ; } cout << s ; } int main ( ) { string s = "" abcd "" ; findWord ( s , s . length ( ) ) ; return 0 ; }",Program to find the Encrypted word.,"#include <bits/stdc++.h> 
 using namespace std ; void findWord ( string c , int n ) { int co = 0 , i ; string s ( n , ' ▁ ' ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ; if ( c [ i ] + co <= 122 ) s [ i ] = ( char ) ( ( int ) c [ i ] + co ) ; else s [ i ] = ( char ) ( ( int ) c [ i ] + co - 26 ) ; } cout << s ; } int main ( ) { string s = "" abcd "" ; findWord ( s , s . length ( ) ) ; return 0 ; }","['void findWord ( string c , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findWord ( string c , int n ) {
"
259,Maximize the value of A by replacing some of its digits with digits of B | C ++ implementation of the approach ; Function to return the maximized value of A ; Sort digits in ascending order ; j points to largest digit in B ; If all the digits of b have been used ; Current digit has been used ; Return the maximized value ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxValue ( string a , string b ) { sort ( b . begin ( ) , b . end ( ) ) ; int n = a . length ( ) ; int m = b . length ( ) ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return a ; } int main ( ) { string a = ""1234"" ; string b = ""4321"" ; cout << maxValue ( a , b ) ; return 0 ; }",Maximize the value of A by replacing some of its digits with digits of B.,"#include <bits/stdc++.h> 
 using namespace std ; string maxValue ( string a , string b ) { sort ( b . begin ( ) , b . end ( ) ) ; int n = a . length ( ) ; int m = b . length ( ) ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return a ; } int main ( ) { string a = ""1234"" ; string b = ""4321"" ; cout << maxValue ( a , b ) ; return 0 ; }","['string maxValue ( string a , string b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string maxValue ( string a , string b ) {
"
261,Check if it is possible to rearrange a binary string with alternate 0 s and 1 s | CPP program to check if we can rearrange a string such that it has alternate 0 s and 1 s . ; function to check the binary string ; length of string ; count zero 's ; count one 's ; if length is even ; if length is odd ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_possible ( string s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( abs ( one - zero ) == 1 ) ; } int main ( ) { string s = ""100110"" ; if ( is_possible ( s ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if it is possible to rearrange a binary string with alternate 0 s and 1 s.,"#include <bits/stdc++.h> 
 using namespace std ; bool is_possible ( string s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( abs ( one - zero ) == 1 ) ; } int main ( ) { string s = ""100110"" ; if ( is_possible ( s ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool is_possible ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool is_possible ( string s ) {
"
262,Frequency Measuring Techniques for Competitive Programming | C ++ program to count frequencies of array items ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through string characters and count frequencies ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int limit = 255 ; void countFreq ( string str ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << ( char ) i << "" ▁ "" << count [ i ] << endl ; } int main ( ) { string str = "" GeeksforGeeks "" ; countFreq ( str ) ; return 0 ; }",Frequency Measuring Techniques for Competitive Programming.,"#include <bits/stdc++.h> 
 using namespace std ; const int limit = 255 ; void countFreq ( string str ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << ( char ) i << "" ▁ "" << count [ i ] << endl ; } int main ( ) { string str = "" GeeksforGeeks "" ; countFreq ( str ) ; return 0 ; }","['void countFreq ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int limit = 255 ;
 void countFreq ( string str ) {
"
263,"Count of even and odd set bit with array element after XOR with K | C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd","#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << "" Even ▁ = ▁ "" << odd << "" , ▁ Odd ▁ = ▁ "" << even ; } else { cout << "" Even ▁ = ▁ "" << even << "" , ▁ Odd ▁ = ▁ "" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }",Count of even and odd set bit with array element after XOR with K.,"#include <bits/stdc++.h> 
 using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << "" Even ▁ = ▁ "" << odd << "" , ▁ Odd ▁ = ▁ "" << even ; } else { cout << "" Even ▁ = ▁ "" << even << "" , ▁ Odd ▁ = ▁ "" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }","['void countEvenOdd ( int arr [ ] , int n , int K ) {', 'int main ( void ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countEvenOdd ( int arr [ ] , int n , int K ) {
"
264,"gOOGLE cASE of a given sentence | CPP program to convert given sentence to camel case . ; Function to remove spaces and convert into camel case ; check for spaces in the sentence ; conversion into upper case ; If not space , copy character ; return string to main ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string s ) { int n = s . length ( ) ; s [ 0 ] = tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ) ; i ++ ; } else s [ i ] = toupper ( s [ i ] ) ; } return s ; } int main ( ) { string str = "" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks "" ; cout << convert ( str ) ; return 0 ; }",gOOGLE cASE of a given sentence.,"#include <bits/stdc++.h> 
 using namespace std ; string convert ( string s ) { int n = s . length ( ) ; s [ 0 ] = tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ) ; i ++ ; } else s [ i ] = toupper ( s [ i ] ) ; } return s ; } int main ( ) { string str = "" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks "" ; cout << convert ( str ) ; return 0 ; }","['string convert ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string convert ( string s ) {
"
267,"Program to find the N | C ++ program to find n - th number containing only 3 and 5. ; If n is odd , append 3 and move to parent ; If n is even , append 5 and move to parent ; Reverse res and return . ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; string findNthNo ( int n ) { string res = "" "" ; while ( n >= 1 ) { if ( n & 1 ) { res = res + ""3"" ; n = ( n - 1 ) / 2 ; } else { res = res + ""5"" ; n = ( n - 2 ) / 2 ; } } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } int main ( ) { int n = 5 ; cout << findNthNo ( n ) ; return 0 ; }",Program to find the N.,"#include <bits/stdc++.h> 
 using namespace std ; string findNthNo ( int n ) { string res = "" "" ; while ( n >= 1 ) { if ( n & 1 ) { res = res + ""3"" ; n = ( n - 1 ) / 2 ; } else { res = res + ""5"" ; n = ( n - 2 ) / 2 ; } } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } int main ( ) { int n = 5 ; cout << findNthNo ( n ) ; return 0 ; }","['string findNthNo ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string findNthNo ( int n ) {
"
268,Nth non | CPP program to find n - th non - square number . ; function to find the nth Non - Square Number ; conversion from int to long double is necessary in order to preserve decimal places after square root . ; calculating the result ; Driver code ; initializing the term number ; Print the result,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNthNonSquare ( int n ) { long double x = ( long double ) n ; long double ans = x + floor ( 0.5 + sqrt ( x ) ) ; return ( int ) ans ; } int main ( ) { int n = 16 ; cout << "" The ▁ "" << n << "" th ▁ Non - Square ▁ number ▁ is ▁ "" ; cout << findNthNonSquare ( n ) ; return 0 ; }",Nth non.,"#include <bits/stdc++.h> 
 using namespace std ; int findNthNonSquare ( int n ) { long double x = ( long double ) n ; long double ans = x + floor ( 0.5 + sqrt ( x ) ) ; return ( int ) ans ; } int main ( ) { int n = 16 ; cout << "" The ▁ "" << n << "" th ▁ Non - Square ▁ number ▁ is ▁ "" ; cout << findNthNonSquare ( n ) ; return 0 ; }","['int findNthNonSquare ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findNthNonSquare ( int n ) {
"
269,Sum of series with alternate signed squares of AP | Efficient CPP program to find sum of series with alternate signed square AP sums . ; function to calculate series sum ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }",Sum of series with alternate signed squares of AP.,"#include <bits/stdc++.h> 
 using namespace std ; int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }","['int seiresSum ( int n , int a [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int seiresSum ( int n , int a [ ] ) {
"
271,Count of subarrays of size K which is a permutation of numbers from 1 to K | C ++ program to implement the above approach ; Save index of numbers of the array ; Update min and max index with the current index and check if it 's a valid permutation ; Driver code,"#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE #include <vector> NEW_LINE using namespace std ; int find_permutations ( vector < int > & arr ) { int cnt = 0 ; int max_ind = -1 , min_ind = 10000000 ; int n = arr . size ( ) ; unordered_map < int , int > index_of ; for ( int i = 0 ; i < n ; i ++ ) { index_of [ arr [ i ] ] = i + 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { max_ind = max ( max_ind , index_of [ i ] ) ; min_ind = min ( min_ind , index_of [ i ] ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; } int main ( ) { vector < int > nums ; nums . push_back ( 2 ) ; nums . push_back ( 3 ) ; nums . push_back ( 1 ) ; nums . push_back ( 5 ) ; nums . push_back ( 4 ) ; cout << find_permutations ( nums ) ; return 0 ; }",Count of subarrays of size K which is a permutation of numbers from 1 to K.,"#include <iostream> 
 #include <unordered_map> 
 #include <vector> 
 using namespace std ; int find_permutations ( vector < int > & arr ) { int cnt = 0 ; int max_ind = -1 , min_ind = 10000000 ; int n = arr . size ( ) ; unordered_map < int , int > index_of ; for ( int i = 0 ; i < n ; i ++ ) { index_of [ arr [ i ] ] = i + 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { max_ind = max ( max_ind , index_of [ i ] ) ; min_ind = min ( min_ind , index_of [ i ] ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; } int main ( ) { vector < int > nums ; nums . push_back ( 2 ) ; nums . push_back ( 3 ) ; nums . push_back ( 1 ) ; nums . push_back ( 5 ) ; nums . push_back ( 4 ) ; cout << find_permutations ( nums ) ; return 0 ; }","['int find_permutations ( vector < int > & arr ) {', 'int main ( ) {']","#include <iostream> 
 #include <unordered_map> 
 #include <vector> 
 using namespace std ;
 int find_permutations ( vector < int > & arr ) {
"
272,Count of integers that divide all the elements of the given array | C ++ implementation of the approach ; Function to return the count of the required integers ; To store the gcd of the array elements ; To store the count of factors of the found gcd ; If g is a perfect square ; Factors appear in pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int a [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; } int main ( ) { int a [ ] = { 4 , 16 , 1024 , 48 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getCount ( a , n ) ; return 0 ; }",Count of integers that divide all the elements of the given array.,"#include <bits/stdc++.h> 
 using namespace std ; int getCount ( int a [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; } int main ( ) { int a [ ] = { 4 , 16 , 1024 , 48 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getCount ( a , n ) ; return 0 ; }","['int getCount ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getCount ( int a [ ] , int n ) {
"
273,"Minimize cost of removals required to make all remaining characters of the string unique | C ++ program to implement the above approach ; Function to find the minimum cost of removing characters to make the String unique ; stores the visited character ; stores the answer ; traverse the String ; if already visited ; Stores the maximum cost of removing a particular character ; Store the total deletion cost of a particular character ; Mark the current character visited ; Traverse the indices of the String [ i , N - 1 ] ; If any duplicate is found ; Update the maximum cost and total cost ; Mark the current character visited ; Keep the character with maximum cost and delete the rest ; return the minimum cost ; Driver code ; input String ; input array ; function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int delCost ( string s , int cost [ ] , int l1 , int l2 ) { bool visited [ l1 ] ; memset ( visited , 0 , sizeof ( visited ) ) ; int ans = 0 ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( visited [ i ] ) { continue ; } int maxDel = 0 ; int totalCost = 0 ; visited [ i ] = 1 ; for ( int j = i ; j < l1 ; j ++ ) { if ( s [ i ] == s [ j ] ) { maxDel = max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ; visited [ j ] = 1 ; } } ans += totalCost - maxDel ; } return ans ; } int main ( ) { string s = "" AAABBB "" ; int l1 = s . size ( ) ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int l2 = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << delCost ( s , cost , l1 , l2 ) ; return 0 ; }",Minimize cost of removals required to make all remaining characters of the string unique.,"#include <bits/stdc++.h> 
 using namespace std ; int delCost ( string s , int cost [ ] , int l1 , int l2 ) { bool visited [ l1 ] ; memset ( visited , 0 , sizeof ( visited ) ) ; int ans = 0 ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( visited [ i ] ) { continue ; } int maxDel = 0 ; int totalCost = 0 ; visited [ i ] = 1 ; for ( int j = i ; j < l1 ; j ++ ) { if ( s [ i ] == s [ j ] ) { maxDel = max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ; visited [ j ] = 1 ; } } ans += totalCost - maxDel ; } return ans ; } int main ( ) { string s = "" AAABBB "" ; int l1 = s . size ( ) ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int l2 = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << delCost ( s , cost , l1 , l2 ) ; return 0 ; }","['int delCost ( string s , int cost [ ] , int l1 , int l2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int delCost ( string s , int cost [ ] , int l1 , int l2 ) {
"
274,"Make all array elements equal by replacing triplets with their Bitwise XOR | C ++ program to implement the above approach ; Function to find triplets such that replacing them with their XOR make all array elements equal ; If N is even ; Calculate xor of array elements ; Traverse the array ; Update xor ; If xor is not equal to 0 ; Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ] ; Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ] ; Driver Code ; Given array ; Size of array ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkXOR ( int arr [ ] , int N ) { if ( N % 2 == 0 ) { int xro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xro ^= arr [ i ] ; } if ( xro != 0 ) { cout << -1 << endl ; return ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << i + 2 << endl ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << N - 1 << endl ; } } else { for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << i + 2 << endl ; } for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << N - 1 << endl ; } } } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkXOR ( arr , N ) ; }",Make all array elements equal by replacing triplets with their Bitwise XOR.,"#include <bits/stdc++.h> 
 using namespace std ; void checkXOR ( int arr [ ] , int N ) { if ( N % 2 == 0 ) { int xro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xro ^= arr [ i ] ; } if ( xro != 0 ) { cout << -1 << endl ; return ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << i + 2 << endl ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << N - 1 << endl ; } } else { for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << i + 2 << endl ; } for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << "" ▁ "" << i + 1 << "" ▁ "" << N - 1 << endl ; } } } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkXOR ( arr , N ) ; }","['void checkXOR ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void checkXOR ( int arr [ ] , int N ) {
"
275,Make all array elements even by replacing adjacent pair of array elements with their sum | C ++ program to implement the above approach ; Function to find minimum count of operations required to make all array elements even ; Stores minimum count of replacements to make all array elements even ; Stores the count of odd continuous numbers ; Traverse the array ; If arr [ i ] is an odd number ; Update odd_cont_seg ; If odd_cont_seg is even ; Update res ; Update res ; Reset odd_cont_seg = 0 ; If odd_cont_seg exceeds 0 ; If odd_cont_seg is even ; Update res ; Update res ; Print the result ; Drivers Code,"#include <iostream> NEW_LINE using namespace std ; int make_array_element_even ( int arr [ ] , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << make_array_element_even ( arr , N ) ; return 0 ; }",Make all array elements even by replacing adjacent pair of array elements with their sum.,"#include <iostream> 
 using namespace std ; int make_array_element_even ( int arr [ ] , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << make_array_element_even ( arr , N ) ; return 0 ; }","['int make_array_element_even ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int make_array_element_even ( int arr [ ] , int N ) {
"
276,Find a number K such that exactly K array elements are greater than or equal to K | C ++ program for the above approach ; Function to find K for which there are exactly K array elements greater than or equal to K ; Finding the largest array element ; Possible values of K ; Traverse the array ; If current array element is greater than or equal to i ; If i array elements are greater than or equal to i ; Otherwise ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int zvalue ( vector < int > & nums ) { int m = * max_element ( nums . begin ( ) , nums . end ( ) ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . size ( ) ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return -1 ; } int main ( ) { vector < int > nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; cout << zvalue ( nums ) << endl ; }",Find a number K such that exactly K array elements are greater than or equal to K.,"#include <bits/stdc++.h> 
 using namespace std ; int zvalue ( vector < int > & nums ) { int m = * max_element ( nums . begin ( ) , nums . end ( ) ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . size ( ) ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return -1 ; } int main ( ) { vector < int > nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; cout << zvalue ( nums ) << endl ; }","['int zvalue ( vector < int > & nums ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int zvalue ( vector < int > & nums ) {
"
277,Lexicographically smallest and largest anagrams of a string containing another string as its substring | C ++ program for the above approach ; Function to find the lexicographically smallest anagram of string which contains another string ; Initializing the map and set ; Iterating over s1 ; Storing the frequency of characters present in s1 ; Storing the distinct characters present in s1 ; Decreasing the frequency of characters from M that are already present in s2 ; Traversing alphabets in sorted order ; If current character of set is not equal to current character of s2 ; If element is equal to current character of s2 ; Checking for second distinct character in s2 ; s2 [ j ] will store second distinct character ; Return the answer ; Function to find the lexicographically largest anagram of string which contains another string ; Getting the lexicographically smallest anagram ; d1 stores the prefix ; d2 stores the suffix ; Return the result ; Driver Code ; Given two strings ; Function Calls,"#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < string , int > lexico_smallest ( string s1 , string s2 ) { map < char , int > M ; set < char > S ; pair < string , int > pr ; for ( int i = 0 ; i <= s1 . size ( ) - 1 ; ++ i ) { M [ s1 [ i ] ] ++ ; S . insert ( s1 [ i ] ) ; } for ( int i = 0 ; i <= s2 . size ( ) - 1 ; ++ i ) { M [ s2 [ i ] ] -- ; } char c = s2 [ 0 ] ; int index = 0 ; string res = "" "" ; for ( auto x : S ) { if ( x != c ) { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { int j = 0 ; index = res . size ( ) ; while ( s2 [ j ] == x ) { j ++ ; } if ( s2 [ j ] < c ) { res += s2 ; for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } index += M [ x ] ; res += s2 ; } } } pr . first = res ; pr . second = index ; return pr ; } string lexico_largest ( string s1 , string s2 ) { pair < string , int > pr = lexico_smallest ( s1 , s2 ) ; string d1 = "" "" ; for ( int i = pr . second - 1 ; i >= 0 ; i -- ) { d1 += pr . first [ i ] ; } string d2 = "" "" ; for ( int i = pr . first . size ( ) - 1 ; i >= pr . second + s2 . size ( ) ; -- i ) { d2 += pr . first [ i ] ; } string res = d2 + s2 + d1 ; return res ; } int main ( ) { string s1 = "" ethgakagmenpgs "" ; string s2 = "" geeks "" ; cout << lexico_smallest ( s1 , s2 ) . first << "" STRNEWLINE "" ; cout << lexico_largest ( s1 , s2 ) ; return ( 0 ) ; }",Lexicographically smallest and largest anagrams of a string containing another string as its substring.,"#include <bits/stdc++.h> 
 using namespace std ; pair < string , int > lexico_smallest ( string s1 , string s2 ) { map < char , int > M ; set < char > S ; pair < string , int > pr ; for ( int i = 0 ; i <= s1 . size ( ) - 1 ; ++ i ) { M [ s1 [ i ] ] ++ ; S . insert ( s1 [ i ] ) ; } for ( int i = 0 ; i <= s2 . size ( ) - 1 ; ++ i ) { M [ s2 [ i ] ] -- ; } char c = s2 [ 0 ] ; int index = 0 ; string res = "" "" ; for ( auto x : S ) { if ( x != c ) { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { int j = 0 ; index = res . size ( ) ; while ( s2 [ j ] == x ) { j ++ ; } if ( s2 [ j ] < c ) { res += s2 ; for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } index += M [ x ] ; res += s2 ; } } } pr . first = res ; pr . second = index ; return pr ; } string lexico_largest ( string s1 , string s2 ) { pair < string , int > pr = lexico_smallest ( s1 , s2 ) ; string d1 = "" "" ; for ( int i = pr . second - 1 ; i >= 0 ; i -- ) { d1 += pr . first [ i ] ; } string d2 = "" "" ; for ( int i = pr . first . size ( ) - 1 ; i >= pr . second + s2 . size ( ) ; -- i ) { d2 += pr . first [ i ] ; } string res = d2 + s2 + d1 ; return res ; } int main ( ) { string s1 = "" ethgakagmenpgs "" ; string s2 = "" geeks "" ; cout << lexico_smallest ( s1 , s2 ) . first << "" STRNEWLINE "" ; cout << lexico_largest ( s1 , s2 ) ; return ( 0 ) ; }","['string lexico_largest ( string s1 , string s2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 pair < string , int > lexico_smallest ( string s1 , string s2 ) {
 map < char , int > M ;
 set < char > S ;
 pair < string , int > pr ;
 for ( int i = 0 ;
 i <= s1 . size ( ) - 1 ;
 ++ i ) {
 M [ s1 [ i ] ] ++ ;
 S . insert ( s1 [ i ] ) ;
 } for ( int i = 0 ;
 i <= s2 . size ( ) - 1 ;
 ++ i ) {
 M [ s2 [ i ] ] -- ;
 } char c = s2 [ 0 ] ;
 int index = 0 ;
 string res = "" "" ;
 for ( auto x : S ) {
 if ( x != c ) {
 for ( int i = 1 ;
 i <= M [ x ] ;
 ++ i ) {
 res += x ;
 } } else {
 int j = 0 ;
 index = res . size ( ) ;
 while ( s2 [ j ] == x ) {
 j ++ ;
 } if ( s2 [ j ] < c ) {
 res += s2 ;
 for ( int i = 1 ;
 i <= M [ x ] ;
 ++ i ) {
 res += x ;
 } } else {
 for ( int i = 1 ;
 i <= M [ x ] ;
 ++ i ) {
 res += x ;
 } index += M [ x ] ;
 res += s2 ;
 } } } pr . first = res ;
 pr . second = index ;
 return pr ;
 } string lexico_largest ( string s1 , string s2 ) {
"
279,Count of permutations of an Array having each element as a multiple or a factor of its index | C ++ Program to implement the above approach ; Function to find the count of desired permutations ; Base case ; If i has not been inserted ; Backtrack ; Insert i ; Recur to find valid permutations ; Remove i ; Return the final count ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPermutation ( unordered_set < int > & arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . find ( i ) == arr . end ( ) ) { if ( i % pos == 0 or pos % i == 0 ) { arr . insert ( i ) ; res += findPermutation ( arr , N ) ; arr . erase ( arr . find ( i ) ) ; } } } return res ; } int main ( ) { int N = 5 ; unordered_set < int > arr ; cout << findPermutation ( arr , N ) ; return 0 ; }",Count of permutations of an Array having each element as a multiple or a factor of its index.,"#include <bits/stdc++.h> 
 using namespace std ; int findPermutation ( unordered_set < int > & arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . find ( i ) == arr . end ( ) ) { if ( i % pos == 0 or pos % i == 0 ) { arr . insert ( i ) ; res += findPermutation ( arr , N ) ; arr . erase ( arr . find ( i ) ) ; } } } return res ; } int main ( ) { int N = 5 ; unordered_set < int > arr ; cout << findPermutation ( arr , N ) ; return 0 ; }","['int findPermutation ( unordered_set < int > & arr , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findPermutation ( unordered_set < int > & arr , int N ) {
"
280,Check if sum Y can be obtained from the Array by the given operations | C ++ Program to implement the above approach ; Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr [ ] ; Store the difference ; Iterate over the array ; If diff reduced to 0 ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; return 0 ; }",Check if sum Y can be obtained from the Array by the given operations.,"#include <iostream> 
 using namespace std ; void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; return 0 ; }","['void solve ( int arr [ ] , int n , int X , int Y ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void solve ( int arr [ ] , int n , int X , int Y ) {
"
284,Check if a given string can be converted to another by given possible swaps | C ++ program to implement the above approach ; Stores length of str1 ; Stores length of str2 ; Stores distinct characters of str1 ; Stores distinct characters of str2 ; Stores frequency of each character of str1 ; Traverse the string str1 ; Update frequency of str1 [ i ] ; Traverse the string str1 ; Insert str1 [ i ] into st1 ; Traverse the string str2 ; Insert str1 [ i ] into st1 ; If distinct characters in str1 and str2 are not same ; Stores frequency of each character of str2 ; Traverse the string str2 ; Update frequency of str2 [ i ] ; Sort hash1 [ ] array ; Sort hash2 [ ] array ; Traverse hash1 [ ] and hash2 [ ] ; If hash1 [ i ] not equal to hash2 [ i ] ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkStr1CanConStr2 ( string & str1 , string & str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; set < int > st1 ; set < int > st2 ; int hash1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . insert ( str1 [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . insert ( str2 [ i ] ) ; } if ( st1 != st2 ) { return false ; } int hash2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] ] ++ ; } sort ( hash1 , hash1 + 256 ) ; sort ( hash2 , hash2 + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; } int main ( ) { string str1 = "" xyyzzlll "" ; string str2 = "" yllzzxxx "" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { cout << "" True "" ; } else { cout << "" False "" ; } }",Check if a given string can be converted to another by given possible swaps.,"#include <bits/stdc++.h> 
 using namespace std ; bool checkStr1CanConStr2 ( string & str1 , string & str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; set < int > st1 ; set < int > st2 ; int hash1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . insert ( str1 [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . insert ( str2 [ i ] ) ; } if ( st1 != st2 ) { return false ; } int hash2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] ] ++ ; } sort ( hash1 , hash1 + 256 ) ; sort ( hash2 , hash2 + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; } int main ( ) { string str1 = "" xyyzzlll "" ; string str2 = "" yllzzxxx "" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { cout << "" True "" ; } else { cout << "" False "" ; } }","['bool checkStr1CanConStr2 ( string & str1 , string & str2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool checkStr1CanConStr2 ( string & str1 , string & str2 ) {
"
285,Sort the array in a given index range | C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Sort the subarray from arr [ l ] to arr [ r ] ; Print the modified array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; vector < int > v ( arr , arr + N ) ; sort ( v . begin ( ) + l , v . begin ( ) + r + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) cout << v [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; }",Sort the array in a given index range.,"#include <bits/stdc++.h> 
 using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; vector < int > v ( arr , arr + N ) ; sort ( v . begin ( ) + l , v . begin ( ) + r + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) cout << v [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; }","['void partSort ( int arr [ ] , int N , int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void partSort ( int arr [ ] , int N , int a , int b ) {
"
286,Find the minimum cost to reach destination using a train | A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0. ; This function returns the smallest possible cost to reach station N - 1 from station 0. ; dist [ i ] stores minimum cost to reach station i from station 0. ; Go through every station and check if using it as an intermediate station gives better path ; Driver program to test above function,"#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE #define N  4 NEW_LINE int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; } int main ( ) { int cost [ N ] [ N ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; cout << "" The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ "" << N << "" ▁ is ▁ "" << minCost ( cost ) ; return 0 ; }",Find the minimum cost to reach destination using a train.,"#include <iostream> 
 #include <climits> 
 using namespace std ; #define INF  INT_MAX 
 #define N  4 
 int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; } int main ( ) { int cost [ N ] [ N ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; cout << "" The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ "" << N << "" ▁ is ▁ "" << minCost ( cost ) ; return 0 ; }","['int minCost ( int cost [ ] [ N ] ) {', 'int main ( ) {']","#include <iostream> 
 #include <climits> 
 using namespace std ;
 #define INF  INT_MAX 
 #define N  4 
 int minCost ( int cost [ ] [ N ] ) {
"
287,Number of loops of size k starting from a specific node | C ++ Program to find number of cycles of length k in a graph with n nodes . ; Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes ; Driven Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = -1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } int main ( ) { int n = 4 , k = 2 ; cout << numOfways ( n , k ) << endl ; return 0 ; }",Number of loops of size k starting from a specific node.,"#include <bits/stdc++.h> 
 using namespace std ; int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = -1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } int main ( ) { int n = 4 , k = 2 ; cout << numOfways ( n , k ) << endl ; return 0 ; }","['int numOfways ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int numOfways ( int n , int k ) {
"
290,"Count triples with Bitwise AND equal to Zero | C ++ program for the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A [ i ] & A [ j ] ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call","#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }",Count triples with Bitwise AND equal to Zero.,"#include <bits/stdc++.h> 
 #include <iostream> 
 using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }","['int countTriplets ( vector < int > & A ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <iostream> 
 using namespace std ;
 int countTriplets ( vector < int > & A ) {
"
293,Percentage increase in volume of the sphere if radius is increased by a given percentage | C ++ program to find percentage increase in the volume of the sphere if radius is increased by a given percentage ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void newvol ( double x ) { cout << "" percentage ▁ increase ▁ in ▁ the "" << "" ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ "" << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << "" % "" << endl ; } int main ( ) { double x = 10 ; newvol ( x ) ; return 0 ; }",Percentage increase in volume of the sphere if radius is increased by a given percentage.,"#include <bits/stdc++.h> 
 using namespace std ; void newvol ( double x ) { cout << "" percentage ▁ increase ▁ in ▁ the "" << "" ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ "" << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << "" % "" << endl ; } int main ( ) { double x = 10 ; newvol ( x ) ; return 0 ; }","['void newvol ( double x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void newvol ( double x ) {
"
294,Length of the chord of the circle whose radius and the angle subtended at the center by the chord is given | C ++ program to find the length chord of the circle whose radius and the angle subtended at the centre is also given ; Function to find the length of the chord ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void length_of_chord ( double r , double x ) { cout << "" The ▁ length ▁ of ▁ the ▁ chord "" << "" ▁ of ▁ the ▁ circle ▁ is ▁ "" << 2 * r * sin ( x * ( 3.14 / 180 ) ) << endl ; } int main ( ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; return 0 ; }",Length of the chord of the circle whose radius and the angle subtended at the center by the chord is given.,"#include <bits/stdc++.h> 
 using namespace std ; void length_of_chord ( double r , double x ) { cout << "" The ▁ length ▁ of ▁ the ▁ chord "" << "" ▁ of ▁ the ▁ circle ▁ is ▁ "" << 2 * r * sin ( x * ( 3.14 / 180 ) ) << endl ; } int main ( ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; return 0 ; }","['void length_of_chord ( double r , double x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void length_of_chord ( double r , double x ) {
"
295,Area of a square inscribed in a circle which is inscribed in an equilateral triangle | C ++ Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle ; Function to find the area of the square ; a cannot be negative ; area of the square ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = sqrt ( a ) / 6 ; return area ; } int main ( ) { float a = 10 ; cout << area ( a ) << endl ; return 0 ; },Area of a square inscribed in a circle which is inscribed in an equilateral triangle.,"#include <bits/stdc++.h> 
 using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = sqrt ( a ) / 6 ; return area ; } int main ( ) { float a = 10 ; cout << area ( a ) << endl ; return 0 ; }","['float area ( float a ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float area ( float a ) {
"
296,Length of longest rod that can fit into a cuboid | C ++ program to find the longest rod that can fit in a cuboid ; Function to find the length ; temporary variable to hold the intermediate result ; length of longest rod is calculated using square root function ; Driver code ; calling longestRodInCuboid ( ) function to get the length of longest rod,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = sqrt ( temp ) ; return result ; } int main ( ) { int length = 12 , breadth = 9 , height = 8 ; cout << longestRodInCuboid ( length , breadth , height ) ; return 0 ; }",Length of longest rod that can fit into a cuboid.,"#include <bits/stdc++.h> 
 using namespace std ; double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = sqrt ( temp ) ; return result ; } int main ( ) { int length = 12 , breadth = 9 , height = 8 ; cout << longestRodInCuboid ( length , breadth , height ) ; return 0 ; }","['double longestRodInCuboid ( int length , int breadth , int height ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double longestRodInCuboid ( int length , int breadth , int height ) {
"
297,Check whether a given point lies on or inside the rectangle | Set 3 | C ++ program to Check whether a given point lies inside or on the rectangle or not ; function to Check whether a given point lies inside or on the rectangle or not ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } int main ( ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) cout << "" Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle "" ; else cout << "" Given ▁ point ▁ does ▁ not ▁ lie ▁ on ▁ the ▁ rectangle "" ; return 0 ; }",Check whether a given point lies on or inside the rectangle.,"#include <bits/stdc++.h> 
 using namespace std ; bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } int main ( ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) cout << "" Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle "" ; else cout << "" Given ▁ point ▁ does ▁ not ▁ lie ▁ on ▁ the ▁ rectangle "" ; return 0 ; }","['bool LiesInsieRectangle ( int a , int b , int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool LiesInsieRectangle ( int a , int b , int x , int y ) {
"
298,Maximize volume of cuboid with given sum of sides | Return the maximum volume . ; Return the maximum volume . ; for length ; for breadth ; for height ; calculating maximum volume . ; Driven Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k ) ; } } return maxvalue ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; }",Maximize volume of cuboid with given sum of sides.,"#include <bits/stdc++.h> 
 using namespace std ; int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k ) ; } } return maxvalue ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; }","['int maxvolume ( int s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxvolume ( int s ) {
"
299,Maximize volume of cuboid with given sum of sides | Return the maximum volume . ; Return the maximum volume . ; finding length ; finding breadth ; finding height ; Driven Program,#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; },Maximize volume of cuboid with given sum of sides.,"#include <bits/stdc++.h> 
 using namespace std ; int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; }","['int maxvolume ( int s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxvolume ( int s ) {
"
300,Area of a Hexagon | CPP program to find area of a Hexagon ; function for calculating area of the hexagon . ; Driver Code ; Length of a side,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; } int main ( ) { double s = 4 ; cout << "" Area ▁ : ▁ "" << hexagonArea ( s ) ; return 0 ; }",Area of a Hexagon.,"#include <iostream> 
 #include <math.h> 
 using namespace std ; double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; } int main ( ) { double s = 4 ; cout << "" Area ▁ : ▁ "" << hexagonArea ( s ) ; return 0 ; }","['double hexagonArea ( double s ) {', 'int main ( ) {']","#include <iostream> 
 #include <math.h> 
 using namespace std ;
 double hexagonArea ( double s ) {
"
301,Maximum number of squares that can fit in a right angle isosceles triangle | CPP program for finding maximum squares that can fit in right angle isosceles triangle ; function for finding max squares ; return in O ( 1 ) with derived formula ; driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; } int main ( ) { int b = 10 , m = 2 ; cout << maxSquare ( b , m ) ; return 0 ; }",Maximum number of squares that can fit in a right angle isosceles triangle.,"#include <bits/stdc++.h> 
 using namespace std ; int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; } int main ( ) { int b = 10 , m = 2 ; cout << maxSquare ( b , m ) ; return 0 ; }","['int maxSquare ( int b , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxSquare ( int b , int m ) {
"
302,"Check if right triangle possible from given area and hypotenuse | C ++ program to check existence of right triangle . ; Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1. ; Descriminant of the equation ; applying the linear equation formula to find both the roots ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRightAngle ( int A , int H ) { long D = pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { long root1 = ( H * H + sqrt ( D ) ) / 2 ; long root2 = ( H * H - sqrt ( D ) ) / 2 ; long a = sqrt ( root1 ) ; long b = sqrt ( root2 ) ; if ( b >= a ) cout << a << "" ▁ "" << b << "" ▁ "" << H ; else cout << b << "" ▁ "" << a << "" ▁ "" << H ; } else cout << "" - 1"" ; } int main ( ) { findRightAngle ( 6 , 5 ) ; }",Check if right triangle possible from given area and hypotenuse.,"#include <bits/stdc++.h> 
 using namespace std ; void findRightAngle ( int A , int H ) { long D = pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { long root1 = ( H * H + sqrt ( D ) ) / 2 ; long root2 = ( H * H - sqrt ( D ) ) / 2 ; long a = sqrt ( root1 ) ; long b = sqrt ( root2 ) ; if ( b >= a ) cout << a << "" ▁ "" << b << "" ▁ "" << H ; else cout << b << "" ▁ "" << a << "" ▁ "" << H ; } else cout << "" - 1"" ; } int main ( ) { findRightAngle ( 6 , 5 ) ; }","['void findRightAngle ( int A , int H ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findRightAngle ( int A , int H ) {
"
303,Maximum number of 2 x2 squares that can be fit inside a right isosceles triangle | C ++ program to count number of 2 x 2 squares in a right isosceles triangle ; removing the extra part we would always need ; Since each square has base of length of 2 ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; } int main ( ) { int base = 8 ; cout << numberOfSquares ( base ) ; return 0 ; },Maximum number of 2 x2 squares that can be fit inside a right isosceles triangle.,"#include <bits/stdc++.h> 
 using namespace std ; int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; } int main ( ) { int base = 8 ; cout << numberOfSquares ( base ) ; return 0 ; }","['int numberOfSquares ( int base ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int numberOfSquares ( int base ) {
"
304,Bitwise OR of bitwise AND of all possible non | C ++ program for the above approach ; Function to find the Bitwise OR of Bitwise AND of all possible subarrays after performing the every query ; Traversing each pair of the query ; Stores the Bitwise OR ; Updating the array ; Find the Bitwise OR of new updated array ; Print the ans ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void performQuery ( vector < int > arr , vector < vector < int > > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int or1 = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . size ( ) ; j ++ ) { or1 = or1 | arr [ j ] ; } cout << or1 << "" ▁ "" ; } } int main ( ) { vector < int > arr ( { 1 , 2 , 3 } ) ; vector < int > v1 ( { 1 , 4 } ) ; vector < int > v2 ( { 3 , 0 } ) ; vector < vector < int > > Q ; Q . push_back ( v1 ) ; Q . push_back ( v2 ) ; performQuery ( arr , Q ) ; }",Bitwise OR of bitwise AND of all possible non.,"#include <bits/stdc++.h> 
 using namespace std ; void performQuery ( vector < int > arr , vector < vector < int > > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int or1 = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . size ( ) ; j ++ ) { or1 = or1 | arr [ j ] ; } cout << or1 << "" ▁ "" ; } } int main ( ) { vector < int > arr ( { 1 , 2 , 3 } ) ; vector < int > v1 ( { 1 , 4 } ) ; vector < int > v2 ( { 3 , 0 } ) ; vector < vector < int > > Q ; Q . push_back ( v1 ) ; Q . push_back ( v2 ) ; performQuery ( arr , Q ) ; }","['void performQuery ( vector < int > arr , vector < vector < int > > Q ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void performQuery ( vector < int > arr , vector < vector < int > > Q ) {
"
305,"Smallest length of number divisible by K formed by using D only | C ++ program for the above approach ; Function to form the smallest number possible ; Array to mark the remainders counted already ; Iterate over the range ; If that remainder is already found , return - 1 ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; vector < int > v ( k , 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return -1 ; v [ m ] = 1 ; cnt ++ ; } return -1 ; } int main ( ) { int d = 1 ; int k = 41 ; cout << smallest ( k , d ) ; return 0 ; }",Smallest length of number divisible by K formed by using D only.,"#include <bits/stdc++.h> 
 using namespace std ; int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; vector < int > v ( k , 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return -1 ; v [ m ] = 1 ; cnt ++ ; } return -1 ; } int main ( ) { int d = 1 ; int k = 41 ; cout << smallest ( k , d ) ; return 0 ; }","['int smallest ( int k , int d ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int smallest ( int k , int d ) {
"
307,Modify array such that the array does not contain any common divisors other than 1 | C ++ program for the above approach ; Function to check if it is possible to modify the array such that there is no common factor between array elements except 1 ; Stores GCD of the array ; Calculate GCD of the array ; If the current divisor is smaller than X ; Divide GCD by the current divisor ; If possible ; Print the modified array ; Otherwise ; Driver Code ; Given array ; Size of the array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCommonDivisor ( int arr [ ] , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = __gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { cout << "" Yes STRNEWLINE "" ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] / copy_G << "" ▁ "" ; cout << endl ; } else cout << "" No "" ; } int main ( ) { int arr [ ] = { 6 , 15 , 6 } , X = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkCommonDivisor ( arr , N , X ) ; }",Modify array such that the array does not contain any common divisors other than 1.,"#include <bits/stdc++.h> 
 using namespace std ; void checkCommonDivisor ( int arr [ ] , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = __gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { cout << "" Yes STRNEWLINE "" ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] / copy_G << "" ▁ "" ; cout << endl ; } else cout << "" No "" ; } int main ( ) { int arr [ ] = { 6 , 15 , 6 } , X = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkCommonDivisor ( arr , N , X ) ; }","['void checkCommonDivisor ( int arr [ ] , int N , int X ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void checkCommonDivisor ( int arr [ ] , int N , int X ) {
"
308,"Program to print Spiral Pattern | Create row and col to traverse rows and columns ; Variable to determine the movement r = right , l = left , d = down , u = upper ; Array for matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size for the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern","#include <iostream> NEW_LINE using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << "" ▁ "" ; else cout << n << "" ▁ "" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }",Program to print Spiral Pattern.,"#include <iostream> 
 using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << "" ▁ "" ; else cout << n << "" ▁ "" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }","['void printSpiral ( int size ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void printSpiral ( int size ) {
"
314,Magic Square | Even Order | C ++ Program to print Magic square of Doubly even order ; Function for calculating Magic square ; filling matrix with its count value starting from 1 ; ; change value of Array elements at fix location as per rule ( n * n + 1 ) - arr [ i ] [ j ] Top Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Top Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Centre of Matrix ( order ( n / 2 ) * ( n / 2 ) ) ; Printing the magic - square ; driver program ; Function call,"#include <iostream> NEW_LINE using namespace std ; void doublyEven ( int n ) { int arr [ n ] [ n ] , i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 3 * n / 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << arr [ i ] [ j ] << "" ▁ "" ; cout << "" STRNEWLINE "" ; } } int main ( ) { int n = 8 ; doublyEven ( n ) ; return 0 ; }",Magic Square.,"#include <iostream> 
 using namespace std ; void doublyEven ( int n ) { int arr [ n ] [ n ] , i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 3 * n / 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << arr [ i ] [ j ] << "" ▁ "" ; cout << "" STRNEWLINE "" ; } } int main ( ) { int n = 8 ; doublyEven ( n ) ; return 0 ; }","['void doublyEven ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void doublyEven ( int n ) {
"
315,Kronecker Product of two matrices | C ++ code to find the Kronecker Product of two matrices and stores it as matrix C ; rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B ; Function to computes the Kronecker Product of two matrices ; i loops till rowa ; k loops till rowb ; j loops till cola ; l loops till colb ; Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; cout << C [ i + l + 1 ] [ j + k + 1 ] << "" ▁ "" ; } } cout << endl ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; return 0 ; }",Kronecker Product of two matrices.,"#include <iostream> 
 using namespace std ; const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; cout << C [ i + l + 1 ] [ j + k + 1 ] << "" ▁ "" ; } } cout << endl ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; return 0 ; }","['void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ;
 void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) {
"
316,Program to check if matrix is lower triangular | Program to check lower triangular matrix . ; Function to check matrix is in lower triangular form or not . ; Driver function . ; Function call,"#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ; if ( isLowerTriangularMatrix ( mat ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Program to check if matrix is lower triangular.,"#include <bits/stdc++.h> 
 #define N  4 
 using namespace std ; bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ; if ( isLowerTriangularMatrix ( mat ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define N  4 
 using namespace std ;
 bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) {
"
317,Program to check if matrix is upper triangular | Program to check upper triangular matrix . ; Function to check matrix is in upper triangular form or not . ; Driver function .,"#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Program to check if matrix is upper triangular.,"#include <bits/stdc++.h> 
 #define N  4 
 using namespace std ; bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define N  4 
 using namespace std ;
 bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) {
"
318,Counting sets of 1 s and 0 s in a binary matrix | CPP program to compute number of sets in a binary matrix . ; no of columns ; no of rows ; function to calculate the number of non empty sets of cell ; stores the final answer ; traverses row - wise ; traverses column wise ; at the end subtract n * m as no of single sets have been added twice . ; driver program to test the above function .,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int m = 3 ; const int n = 2 ; long long countSets ( int a [ n ] [ m ] ) { long long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) a [ i ] [ j ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) a [ j ] [ i ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; } int main ( ) { int a [ ] [ 3 ] = { ( 1 , 0 , 1 ) , ( 0 , 1 , 0 ) } ; cout << countSets ( a ) ; return 0 ; }",Counting sets of 1 s and 0 s in a binary matrix.,"#include <bits/stdc++.h> 
 using namespace std ; const int m = 3 ; const int n = 2 ; long long countSets ( int a [ n ] [ m ] ) { long long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) a [ i ] [ j ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) a [ j ] [ i ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; } int main ( ) { int a [ ] [ 3 ] = { ( 1 , 0 , 1 ) , ( 0 , 1 , 0 ) } ; cout << countSets ( a ) ; return 0 ; }","['long countSets ( int a [ n ] [ m ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int m = 3 ;
 const int n = 2 ;
 long long countSets ( int a [ n ] [ m ] ) {
"
320,"Program to check if a matrix is symmetric | Efficient c ++ code for check a matrix is symmetric or not . ; Returns true if mat [ N ] [ N ] is symmetric , else false ; Driver code","#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Program to check if a matrix is symmetric.,"#include <iostream> 
 using namespace std ; const int MAX = 100 ; bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool isSymmetric ( int mat [ ] [ MAX ] , int N ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 const int MAX = 100 ;
 bool isSymmetric ( int mat [ ] [ MAX ] , int N ) {
"
323,Count Negative Numbers in a Column | CPP implementation of Naive method to count of negative numbers in M [ n ] [ m ] ; Follow the path shown using arrows above ; no more negative numbers in this row ; Driver program to test above functions,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }",Count Negative Numbers in a Column.,"#include <bits/stdc++.h> 
 using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }","['int countNegative ( int M [ ] [ 4 ] , int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countNegative ( int M [ ] [ 4 ] , int n , int m ) {
"
324,Count Negative Numbers in a Column | CPP implementation of Efficient method to count of negative numbers in M [ n ] [ m ] ; Function to count negative number ; initialize result ; Start with top right corner ; Follow the path shown using arrows above ; j is the index of the last negative number in this row . So there must be ( j + 1 ) ; negative numbers in this row . ; move to the left and see if we can find a negative number there ; Driver program to test above functions,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }",Count Negative Numbers in a Column.,"#include <bits/stdc++.h> 
 using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }","['int countNegative ( int M [ ] [ 4 ] , int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countNegative ( int M [ ] [ 4 ] , int n , int m ) {
"
326,"Find a specific pair in Matrix | A Naive method to find maximum value of mat [ d ] [ e ] - ma [ a ] [ b ] such that d > a and e > b ; The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b . ; stores maximum value ; Consider all possible pairs mat [ a ] [ b ] and mat [ d ] [ e ] ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << "" Maximum ▁ Value ▁ is ▁ "" << findMaxValue ( mat ) ; return 0 ; }",Find a specific pair in Matrix.,"#include <bits/stdc++.h> 
 using namespace std ; #define N  5 
 int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << "" Maximum ▁ Value ▁ is ▁ "" << findMaxValue ( mat ) ; return 0 ; }","['int findMaxValue ( int mat [ ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define N  5 
 int findMaxValue ( int mat [ ] [ N ] ) {
"
327,"Find a specific pair in Matrix | An efficient method to find maximum value of mat [ d ] - ma [ a ] [ b ] such that c > a and d > b ; The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b . ; stores maximum value ; maxArr [ i ] [ j ] stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 ) ; last element of maxArr will be same 's as of  the input matrix ; preprocess last row Initialize max ; preprocess last column Initialize max ; preprocess rest of the matrix from bottom ; Update maxValue ; set maxArr ( i , j ) ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; int maxArr [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << "" Maximum ▁ Value ▁ is ▁ "" << findMaxValue ( mat ) ; return 0 ; }",Find a specific pair in Matrix.,"#include <bits/stdc++.h> 
 using namespace std ; #define N  5 
 int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; int maxArr [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << "" Maximum ▁ Value ▁ is ▁ "" << findMaxValue ( mat ) ; return 0 ; }","['int findMaxValue ( int mat [ ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define N  5 
 int findMaxValue ( int mat [ ] [ N ] ) {
"
329,"Given an n x n square matrix , find sum of all sub | A simple C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; row number of first cell in current sub - square of size k x k ; column of first cell in current sub - square of size k x k ; Calculate and print sum of current sub - square ; Line separator for sub - squares starting with next row ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << "" ▁ "" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumSimple ( mat , k ) ; return 0 ; }","Given an n x n square matrix , find sum of all sub.","#include <iostream> 
 using namespace std ; #define n  5 
 void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << "" ▁ "" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumSimple ( mat , k ) ; return 0 ; }","['void printSumSimple ( int mat [ ] [ n ] , int k ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 #define n  5 
 void printSumSimple ( int mat [ ] [ n ] , int k ) {
"
330,"Given an n x n square matrix , find sum of all sub | An efficient C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A O ( n ^ 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; 1 : PREPROCESSING To store sums of all strips of size k x 1 ; Go column by column ; Calculate sum of first k x 1 rectangle in this column ; Calculate sum of remaining rectangles ; 2 : CALCULATE SUM of Sub - Squares using stripSum [ ] [ ] ; Calculate and print sum of first subsquare in this row ; Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumTricky ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; int stripSum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; cout << sum << "" ▁ "" ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; cout << sum << "" ▁ "" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; return 0 ; }","Given an n x n square matrix , find sum of all sub.","#include <iostream> 
 using namespace std ; #define n  5 
 void printSumTricky ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; int stripSum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; cout << sum << "" ▁ "" ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; cout << sum << "" ▁ "" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; return 0 ; }","['void printSumTricky ( int mat [ ] [ n ] , int k ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 #define n  5 
 void printSumTricky ( int mat [ ] [ n ] , int k ) {
"
331,Program to find transpose of a matrix |  ; This function stores transpose of A [ ] [ ] in B [ ] [ ] ; Driver code,"#include <stdio.h> NEW_LINE #define M  3 NEW_LINE #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } int main ( ) { int A [ M ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ N ] [ M ] , i , j ; transpose ( A , B ) ; printf ( "" Result ▁ matrix ▁ is ▁ STRNEWLINE "" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) printf ( "" % d ▁ "" , B [ i ] [ j ] ) ; printf ( "" STRNEWLINE "" ) ; } return 0 ; }",Program to find transpose of a matrix.,"#include <stdio.h> 
 #define M  3 
 #define N  4 
 void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } int main ( ) { int A [ M ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ N ] [ M ] , i , j ; transpose ( A , B ) ; printf ( "" Result ▁ matrix ▁ is ▁ STRNEWLINE "" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) printf ( "" % d ▁ "" , B [ i ] [ j ] ) ; printf ( "" STRNEWLINE "" ) ; } return 0 ; }","['void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) {', 'int main ( ) {']","#include <stdio.h> 
 #define M  3 
 #define N  4 
 void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) {
"
332,Program to find transpose of a matrix |  ; Converts A [ ] [ ] to its transpose ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; printf ( "" Modified ▁ matrix ▁ is ▁ STRNEWLINE "" ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( "" % d ▁ "" , A [ i ] [ j ] ) ; printf ( "" STRNEWLINE "" ) ; } return 0 ; }",Program to find transpose of a matrix.,"#include <bits/stdc++.h> 
 using namespace std ; #define N  4 
 void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; printf ( "" Modified ▁ matrix ▁ is ▁ STRNEWLINE "" ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( "" % d ▁ "" , A [ i ] [ j ] ) ; printf ( "" STRNEWLINE "" ) ; } return 0 ; }","['void transpose ( int A [ ] [ N ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define N  4 
 void transpose ( int A [ ] [ N ] ) {
"
339,"Coin Change | DP | Recursive C program for coin change problem . ; Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n ; If n is 0 then there is 1 solution ( do not include any coin ) ; If n is less than 0 then no solution exists ; If there are no coins and n is greater than 0 , then no solution exist ; count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ] ; Driver program to test above function","#include <stdio.h> NEW_LINE int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( "" % d ▁ "" , count ( arr , m , 4 ) ) ; getchar ( ) ; return 0 ; }",Coin Change.,"#include <stdio.h> 
 int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( "" % d ▁ "" , count ( arr , m , 4 ) ) ; getchar ( ) ; return 0 ; }","['int count ( int S [ ] , int m , int n ) {', 'int main ( ) {']","#include <stdio.h> 
 int count ( int S [ ] , int m , int n ) {
"
342,"Matrix Chain Multiplication | DP | See the Cormen book for details of the following algorithm ; Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n ; For simplicity of the program , one extra row and one extra column are allocated in m [ ] [ ] . 0 th row and 0 th column of m [ ] [ ] are not used ; cost is zero when multiplying one matrix . ; L is chain length . ; q = cost / scalar multiplications ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ "" << MatrixChainOrder ( arr , size ) ; getchar ( ) ; return 0 ; }",Matrix Chain Multiplication.,"#include <bits/stdc++.h> 
 using namespace std ; int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ "" << MatrixChainOrder ( arr , size ) ; getchar ( ) ; return 0 ; }","['int MatrixChainOrder ( int p [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MatrixChainOrder ( int p [ ] , int n ) {
"
345,"Cutting a Rod | DP | CPP program for above approach ; Global Array for the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call","#include <iostream> NEW_LINE using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << "" Maximum ▁ obtained ▁ value ▁ is ▁ "" << un_kp ( price , length , n , Max_len ) << endl ; }",Cutting a Rod.,"#include <iostream> 
 using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << "" Maximum ▁ obtained ▁ value ▁ is ▁ "" << un_kp ( price , length , n , Max_len ) << endl ; }","['int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int t [ 9 ] [ 9 ] ;
 int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) {
"
346,"Multiply two integers without using multiplication , division and bitwise operators , and no loops | C ++ program to Multiply two integers without using multiplication , division and bitwise operators , and no loops ; function to multiply two numbers x and y ; 0 multiplied with anything gives 0 ; Add x one by one ; the case where y is negative ; Driver code","#include <iostream> NEW_LINE using namespace std ; class GFG { public : int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } } ; int main ( ) { GFG g ; cout << endl << g . multiply ( 5 , -11 ) ; getchar ( ) ; return 0 ; }","Multiply two integers without using multiplication , division and bitwise operators , and no loops.","#include <iostream> 
 using namespace std ; class GFG { public : int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } } ; int main ( ) { GFG g ; cout << endl << g . multiply ( 5 , -11 ) ; getchar ( ) ; return 0 ; }","['int multiply ( int x , int y ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 class GFG {
 public : int multiply ( int x , int y ) {
"
347,"Sieve of Eratosthenes | C ++ program to print all primes smaller than or equal to n using Sieve of Eratosthenes ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked . ; Print all prime numbers ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) cout << p << "" ▁ "" ; } int main ( ) { int n = 30 ; cout << "" Following ▁ are ▁ the ▁ prime ▁ numbers ▁ smaller ▁ "" << "" ▁ than ▁ or ▁ equal ▁ to ▁ "" << n << endl ; SieveOfEratosthenes ( n ) ; return 0 ; }",Sieve of Eratosthenes.,"#include <bits/stdc++.h> 
 using namespace std ; void SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) cout << p << "" ▁ "" ; } int main ( ) { int n = 30 ; cout << "" Following ▁ are ▁ the ▁ prime ▁ numbers ▁ smaller ▁ "" << "" ▁ than ▁ or ▁ equal ▁ to ▁ "" << n << endl ; SieveOfEratosthenes ( n ) ; return 0 ; }","['void SieveOfEratosthenes ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void SieveOfEratosthenes ( int n ) {
"
349,Pascal 's Triangle | C ++ program for Pascals Triangle ; A O ( n ^ 2 ) time and O ( n ^ 2 ) extra space method for Pascal 's Triangle ; An auxiliary array to store generated pscal triangle values ; Iterate through every line and print integer ( s ) in it ; Every line has number of integers equal to line number ; First and last values in every row are 1 ; Other values are sum of values just above and left of above ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << "" ▁ "" ; } cout << "" STRNEWLINE "" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }",Pascal 's Triangle.,"#include <bits/stdc++.h> 
 using namespace std ; void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << "" ▁ "" ; } cout << "" STRNEWLINE "" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }","['void printPascal ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printPascal ( int n ) {
"
350,"Pascal 's Triangle | C ++ program for Pascals Triangle A O ( n ^ 2 ) time and O ( 1 ) extra space function for Pascal 's Triangle ; used to represent C ( line , i ) ; The first value in a line is always 1 ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << "" ▁ "" ; C = C * ( line - i ) / i ; } cout << "" STRNEWLINE "" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }",Pascal 's Triangle.,"#include <bits/stdc++.h> 
 using namespace std ; void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << "" ▁ "" ; C = C * ( line - i ) / i ; } cout << "" STRNEWLINE "" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }","['void printPascal ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printPascal ( int n ) {
"
351,Add two numbers without using arithmetic operators | C ++ Program to add two numbers without using arithmetic operator ; Iterate till there is no carry ; carry now contains common set bits of x and y ; Sum of bits of x and y where at least one of the bits is not set ; Carry is shifted by one so that adding it to x gives the required sum ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { cout << Add ( 15 , 32 ) ; return 0 ; }",Add two numbers without using arithmetic operators.,"#include <bits/stdc++.h> 
 using namespace std ; int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { cout << Add ( 15 , 32 ) ; return 0 ; }","['int Add ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Add ( int x , int y ) {
"
352,"Compute modulus division by a power |  ; This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 , ... ; Driver Code ; d must be a power of 2","#include <stdio.h> NEW_LINE unsigned int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; } int main ( ) { unsigned int n = 6 ; unsigned int d = 4 ; printf ( "" % u ▁ moduo ▁ % u ▁ is ▁ % u "" , n , d , getModulo ( n , d ) ) ; getchar ( ) ; return 0 ; }",Compute modulus division by a power.,"#include <stdio.h> 
 unsigned int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; } int main ( ) { unsigned int n = 6 ; unsigned int d = 4 ; printf ( "" % u ▁ moduo ▁ % u ▁ is ▁ % u "" , n , d , getModulo ( n , d ) ) ; getchar ( ) ; return 0 ; }","['int getModulo ( unsigned int n , unsigned int d ) {', 'int main ( ) {']","#include <stdio.h> 
 unsigned int getModulo ( unsigned int n , unsigned int d ) {
"
353,Count set bits in an integer | C ++ program to Count set bits in an integer ; Function to get no of set bits in binary representation of positive integer n ; Program to test function countSetBits,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; cout << countSetBits ( i ) ; return 0 ; },Count set bits in an integer.,"#include <bits/stdc++.h> 
 using namespace std ; unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; cout << countSetBits ( i ) ; return 0 ; }","['int countSetBits ( unsigned int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 unsigned int countSetBits ( unsigned int n ) {
"
354,Count set bits in an integer | CPP implementation for recursive approach to find the number of set bits using Brian Kernighans Algorithm ; recursive function to count set bits ; base case ; driver code ; get value from user ; function calling,#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } int main ( ) { int n = 9 ; cout << countSetBits ( n ) ; return 0 ; },Count set bits in an integer.,"#include <bits/stdc++.h> 
 using namespace std ; int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } int main ( ) { int n = 9 ; cout << countSetBits ( n ) ; return 0 ; }","['int countSetBits ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countSetBits ( int n ) {
"
357,Count set bits in an integer | C ++ program to count set bits by pre - storing count set bits in nibbles . ; Recursively get nibble of a given number and map them in the array ; Find last nibble ; Use pre - stored values to find count in last nibble plus recursively add remaining nibbles . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int num_to_bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } int main ( ) { int num = 31 ; cout << countSetBitsRec ( num ) ; return 0 ; }",Count set bits in an integer.,"#include <bits/stdc++.h> 
 using namespace std ; int num_to_bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } int main ( ) { int num = 31 ; cout << countSetBitsRec ( num ) ; return 0 ; }","['int countSetBitsRec ( unsigned int num ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int num_to_bits [ 16 ] = {
 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ;
 unsigned int countSetBitsRec ( unsigned int num ) {
"
358,"Count set bits in an integer |  ; Check each bit in a number is set or not and return the total count of the set bits . ; ( 1 << i ) = pow ( 2 , i ) ; Driver code",#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; } int main ( ) { int N = 15 ; cout << countSetBits ( N ) << endl ; return 0 ; },Count set bits in an integer.,"#include <iostream> 
 using namespace std ; int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; } int main ( ) { int N = 15 ; cout << countSetBits ( N ) << endl ; return 0 ; }","['int countSetBits ( int N ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int countSetBits ( int N ) {
"
359,"Program to find parity | C ++ program to find parity of an integer ; Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity ; Driver program to test getParity ( )","# include <bits/stdc++.h> NEW_LINE # define bool  int NEW_LINE using namespace std ; bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; cout << "" Parity ▁ of ▁ no ▁ "" << n << "" ▁ = ▁ "" << ( getParity ( n ) ? "" odd "" : "" even "" ) ; getchar ( ) ; return 0 ; }",Program to find parity.,"# include <bits/stdc++.h> 
 # define bool  int 
 using namespace std ; bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; cout << "" Parity ▁ of ▁ no ▁ "" << n << "" ▁ = ▁ "" << ( getParity ( n ) ? "" odd "" : "" even "" ) ; getchar ( ) ; return 0 ; }","['bool getParity ( unsigned int n ) {', 'int main ( ) {']","# include <bits/stdc++.h> 
 # define bool  int 
 using namespace std ;
 bool getParity ( unsigned int n ) {
"
360,Program to find whether a no is power of two | C ++ Program to find whether a no is power of two ; Function to check if x is power of 2 ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes "" << endl : cout << "" No "" << endl ; isPowerOfTwo ( 64 ) ? cout << "" Yes "" << endl : cout << "" No "" << endl ; return 0 ; }",Program to find whether a no is power of two.,"#include <bits/stdc++.h> 
 using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes "" << endl : cout << "" No "" << endl ; isPowerOfTwo ( 64 ) ? cout << "" Yes "" << endl : cout << "" No "" << endl ; return 0 ; }","['bool isPowerOfTwo ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isPowerOfTwo ( int n ) {
"
361,Program to find whether a no is power of two |  ; Function to check if x is power of 2 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerOfTwo ( 64 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }",Program to find whether a no is power of two.,"#include <bits/stdc++.h> 
 using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerOfTwo ( 64 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }","['bool isPowerOfTwo ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isPowerOfTwo ( int n ) {
"
362,Program to find whether a no is power of two | C ++ program for above approach ; Function which checks whether a number is a power of 2 ; base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 ) ; all other odd numbers are not powers of 2 ; recursive function call ; Driver Code ; True ; False,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; if ( powerOf2 ( m ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; }",Program to find whether a no is power of two.,"#include <bits/stdc++.h> 
 using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; if ( powerOf2 ( m ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; }","['bool powerOf2 ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool powerOf2 ( int n ) {
"
363,Program to find whether a no is power of two |  ; Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerOfTwo ( 64 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }",Program to find whether a no is power of two.,"#include <bits/stdc++.h> 
 using namespace std ; #define bool  int 
 bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerOfTwo ( 64 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }","['bool isPowerOfTwo ( int x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define bool  int 
 bool isPowerOfTwo ( int x ) {
"
364,"Find the maximum repeating number in O ( n ) time and O ( 1 ) extra space | C ++ program to find the maximum repeating number ; Returns maximum repeating element in arr [ 0. . n - 1 ] . The array elements are in range from 0 to k - 1 ; Iterate though input array , for every element arr [ i ] , increment arr [ arr [ i ] % k ] by k ; Find index of the maximum repeating element ; Return index of the maximum element ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; cout << "" The ▁ maximum ▁ repeating ▁ number ▁ is ▁ "" << maxRepeating ( arr , n , k ) << endl ; return 0 ; }",Find the maximum repeating number in O ( n ) time and O ( 1 ) extra space.,"#include <iostream> 
 using namespace std ; int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; cout << "" The ▁ maximum ▁ repeating ▁ number ▁ is ▁ "" << maxRepeating ( arr , n , k ) << endl ; return 0 ; }","['int maxRepeating ( int * arr , int n , int k ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int maxRepeating ( int * arr , int n , int k ) {
"
367,Minimum adjacent swaps required to Sort Binary array | C ++ code to find minimum number of swaps to sort a binary array ; Function to find minimum swaps to sort an array of 0 s and 1 s . ; Array to store count of zeroes ; Count number of zeroes on right side of every one . ; Count total number of swaps by adding number of zeroes on right side of every one . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ n ] ; memset ( noOfZeroes , 0 , sizeof ( noOfZeroes ) ) ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSwaps ( arr , n ) ; return 0 ; }",Minimum adjacent swaps required to Sort Binary array.,"#include <bits/stdc++.h> 
 using namespace std ; int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ n ] ; memset ( noOfZeroes , 0 , sizeof ( noOfZeroes ) ) ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSwaps ( arr , n ) ; return 0 ; }","['int findMinSwaps ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMinSwaps ( int arr [ ] , int n ) {
"
368,Minimum adjacent swaps required to Sort Binary array |  ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; cout << minswaps ( arr , 9 ) ; return 0 ; }",Minimum adjacent swaps required to Sort Binary array.,"#include <iostream> 
 using namespace std ; int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; cout << minswaps ( arr , 9 ) ; return 0 ; }","['int minswaps ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int minswaps ( int arr [ ] , int n ) {
"
369,Program to check if an array is sorted or not ( Iterative and Recursive ) | C ++ program to check if an Array is sorted or not ; Function that returns true if array is sorted in non - decreasing order . ; Array has one or no element ; Unsorted pair found ; No unsorted pair found ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( arraySortedOrNot ( arr , n ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; }",Program to check if an array is sorted or not ( Iterative and Recursive ).,"#include <bits/stdc++.h> 
 using namespace std ; bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( arraySortedOrNot ( arr , n ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; }","['bool arraySortedOrNot ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool arraySortedOrNot ( int arr [ ] , int n ) {
"
370,Find the two numbers with odd occurrences in an unsorted array | C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Will hold XOR of two odd occurring elements ; Will have only single set bit of xor2 ; Get the xor of all elements in arr [ ] . The xor will basically be xor of two odd occurring elements ; Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get ; Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0. ; XOR of first set is finally going to hold one odd occurring number x ; XOR of second set is finally going to hold the other odd occurring number y ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << "" The ▁ two ▁ ODD ▁ elements ▁ are ▁ "" << x << "" ▁ & ▁ "" << y ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }",Find the two numbers with odd occurrences in an unsorted array.,"#include <bits/stdc++.h> 
 using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << "" The ▁ two ▁ ODD ▁ elements ▁ are ▁ "" << x << "" ▁ & ▁ "" << y ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }","['void printTwoOdd ( int arr [ ] , int size ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printTwoOdd ( int arr [ ] , int size ) {
"
371,Find the two numbers with odd occurrences in an unsorted array | C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Create map and calculate frequency of array of * elements using array . ; Traverse through the map and check if its second element that is the frequency is odd or not . Then this is the odd occurring element . Its is clearly mentioned in problem that there are only two odd occurring elements so this will print those two elements . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) { m [ arr [ i ] ] ++ ; } cout << "" The ▁ two ▁ ODD ▁ elements ▁ are ▁ "" ; for ( auto & x : m ) { if ( x . second % 2 != 0 ) cout << x . first << "" , ▁ "" ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }",Find the two numbers with odd occurrences in an unsorted array.,"#include <bits/stdc++.h> 
 using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) { m [ arr [ i ] ] ++ ; } cout << "" The ▁ two ▁ ODD ▁ elements ▁ are ▁ "" ; for ( auto & x : m ) { if ( x . second % 2 != 0 ) cout << x . first << "" , ▁ "" ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }","['void printTwoOdd ( int arr [ ] , int size ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printTwoOdd ( int arr [ ] , int size ) {
"
372,Find a pair with the given difference | C ++ program to find a pair with the given difference ; The function assumes that the array is sorted ; Initialize positions of two elements ; Search for a pair ; Driver program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << "" Pair ▁ Found : ▁ ( "" << arr [ i ] << "" , ▁ "" << arr [ j ] << "" ) "" ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << "" No ▁ such ▁ pair "" ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 60 ; findPair ( arr , size , n ) ; return 0 ; }",Find a pair with the given difference.,"#include <bits/stdc++.h> 
 using namespace std ; bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << "" Pair ▁ Found : ▁ ( "" << arr [ i ] << "" , ▁ "" << arr [ j ] << "" ) "" ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << "" No ▁ such ▁ pair "" ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 60 ; findPair ( arr , size , n ) ; return 0 ; }","['bool findPair ( int arr [ ] , int size , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool findPair ( int arr [ ] , int size , int n ) {
"
373,Find k maximum elements of array in original order | C ++ program to find k maximum elements of array in original order ; Function to print m Maximum elements ; vector to store the copy of the original array ; Sorting the vector in descending order . Please refer below link for details www . geeksforgeeks . org / sort - c - stl / https : ; Traversing through original array and printing all those elements that are in first k of sorted vector . goo . gl / 44 Rwgt Please refer https : for details of binary_search ( ) ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMax ( int arr [ ] , int k , int n ) { vector < int > brr ( arr , arr + n ) ; sort ( brr . begin ( ) , brr . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) if ( binary_search ( brr . begin ( ) , brr . begin ( ) + k , arr [ i ] , greater < int > ( ) ) ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printMax ( arr , k , n ) ; return 0 ; }",Find k maximum elements of array in original order.,"#include <bits/stdc++.h> 
 using namespace std ; void printMax ( int arr [ ] , int k , int n ) { vector < int > brr ( arr , arr + n ) ; sort ( brr . begin ( ) , brr . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) if ( binary_search ( brr . begin ( ) , brr . begin ( ) + k , arr [ i ] , greater < int > ( ) ) ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printMax ( arr , k , n ) ; return 0 ; }","['void printMax ( int arr [ ] , int k , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printMax ( int arr [ ] , int k , int n ) {
"
374,Print n smallest elements from given array in their original order | CPP for printing smallest n number in order ; Function to print smallest n numbers ; Make copy of array ; Sort copy array ; For each arr [ i ] find whether it is a part of n - smallest with binary search ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSmall ( int arr [ ] , int asize , int n ) { vector < int > copy_arr ( arr , arr + asize ) ; sort ( copy_arr . begin ( ) , copy_arr . begin ( ) + asize ) ; for ( int i = 0 ; i < asize ; ++ i ) if ( binary_search ( copy_arr . begin ( ) , copy_arr . begin ( ) + n , arr [ i ] ) ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 5 ; printSmall ( arr , asize , n ) ; return 0 ; }",Print n smallest elements from given array in their original order.,"#include <bits/stdc++.h> 
 using namespace std ; void printSmall ( int arr [ ] , int asize , int n ) { vector < int > copy_arr ( arr , arr + asize ) ; sort ( copy_arr . begin ( ) , copy_arr . begin ( ) + asize ) ; for ( int i = 0 ; i < asize ; ++ i ) if ( binary_search ( copy_arr . begin ( ) , copy_arr . begin ( ) + n , arr [ i ] ) ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 5 ; printSmall ( arr , asize , n ) ; return 0 ; }","['void printSmall ( int arr [ ] , int asize , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printSmall ( int arr [ ] , int asize , int n ) {
"
375,"Check whether Arithmetic Progression can be formed from the given array | C ++ program to check if a given array can form arithmetic progression ; Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driven Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << "" Yes "" << endl ) : ( cout << "" No "" << endl ) ; return 0 ; }",Check whether Arithmetic Progression can be formed from the given array.,"#include <bits/stdc++.h> 
 using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << "" Yes "" << endl ) : ( cout << "" No "" << endl ) ; return 0 ; }","['bool checkIsAP ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool checkIsAP ( int arr [ ] , int n ) {
"
376,"Check whether Arithmetic Progression can be formed from the given array | C ++ program to check if a given array can form arithmetic progression ; Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Find the smallest and and update second smallest ; Find second smallest ; Check if the duplicate element found or not ; If duplicate found then return false ; Find the difference between smallest and second smallest ; As we have used smallest and second smallest , so we should now only check for n - 2 elements ; Driven Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { unordered_map < int , int > hm ; int smallest = INT_MAX , second_smallest = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < smallest ) { second_smallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] != smallest && arr [ i ] < second_smallest ) second_smallest = arr [ i ] ; if ( hm . find ( arr [ i ] ) == hm . end ( ) ) hm [ arr [ i ] ] ++ ; else return false ; } int diff = second_smallest - smallest ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( hm . find ( second_smallest ) == hm . end ( ) ) return false ; second_smallest += diff ; } return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << "" Yes "" << endl ) : ( cout << "" No "" << endl ) ; return 0 ; }",Check whether Arithmetic Progression can be formed from the given array.,"#include <bits/stdc++.h> 
 using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { unordered_map < int , int > hm ; int smallest = INT_MAX , second_smallest = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < smallest ) { second_smallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] != smallest && arr [ i ] < second_smallest ) second_smallest = arr [ i ] ; if ( hm . find ( arr [ i ] ) == hm . end ( ) ) hm [ arr [ i ] ] ++ ; else return false ; } int diff = second_smallest - smallest ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( hm . find ( second_smallest ) == hm . end ( ) ) return false ; second_smallest += diff ; } return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << "" Yes "" << endl ) : ( cout << "" No "" << endl ) ; return 0 ; }","['bool checkIsAP ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool checkIsAP ( int arr [ ] , int n ) {
"
377,Count ways of choosing a pair with maximum difference | CPP Code to find no . of Ways of choosing a pair with maximum difference ; To find minimum and maximum of the array ; to find the count of minimum and maximum elements ; Count variables ; condition for all elements equal ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { int mn = INT_MAX ; int mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( mn , a [ i ] ) ; mx = max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } int main ( ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }",Count ways of choosing a pair with maximum difference.,"#include <bits/stdc++.h> 
 using namespace std ; int countPairs ( int a [ ] , int n ) { int mn = INT_MAX ; int mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( mn , a [ i ] ) ; mx = max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } int main ( ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }","['int countPairs ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countPairs ( int a [ ] , int n ) {
"
385,Maximize count of corresponding same elements in given Arrays by Rotation | C ++ program of the above approach ; Function that prints maximum equal elements ; Vector to store the index of elements of array b ; Storing the positions of array B ; frequency array to keep count of elements with similar difference in distances ; Iterate through all element in arr1 [ ] ; Calculate number of shift required to make current element equal ; If d is less than 0 ; Store the frequency of current diff ; Compute the maximum frequency stored ; Printing the maximum number of equal elements ; Driver Code ; Given two arrays ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumEqual ( int a [ ] , int b [ ] , int n ) { vector < int > store ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } vector < int > ans ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = max ( finalans , ans [ i ] ) ; cout << finalans << "" STRNEWLINE "" ; } int main ( ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximumEqual ( A , B , size ) ; return 0 ; }",Maximize count of corresponding same elements in given Arrays by Rotation.,"#include <bits/stdc++.h> 
 using namespace std ; void maximumEqual ( int a [ ] , int b [ ] , int n ) { vector < int > store ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } vector < int > ans ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = max ( finalans , ans [ i ] ) ; cout << finalans << "" STRNEWLINE "" ; } int main ( ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximumEqual ( A , B , size ) ; return 0 ; }","['void maximumEqual ( int a [ ] , int b [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maximumEqual ( int a [ ] , int b [ ] , int n ) {
"
386,Print array after it is right rotated K times | C ++ implementation of right rotation of an array K number of times ; Function to rightRotate array ; If rotation is greater than size of array ; Printing rightmost kth elements ; Prints array after ' k ' elements ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { cout << a [ n + i - k ] << "" ▁ "" ; } else { cout << ( a [ i - k ] ) << "" ▁ "" ; } } cout << "" STRNEWLINE "" ; } int main ( ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( Array ) / sizeof ( Array [ 0 ] ) ; int K = 2 ; RightRotate ( Array , N , K ) ; }",Print array after it is right rotated K times.,"#include <bits/stdc++.h> 
 using namespace std ; void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { cout << a [ n + i - k ] << "" ▁ "" ; } else { cout << ( a [ i - k ] ) << "" ▁ "" ; } } cout << "" STRNEWLINE "" ; } int main ( ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( Array ) / sizeof ( Array [ 0 ] ) ; int K = 2 ; RightRotate ( Array , N , K ) ; }","['void RightRotate ( int a [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void RightRotate ( int a [ ] , int n , int k ) {
"
396,Find Range Value of the Expression | C ++ implementation of the approach ; Function to return the value of the given expression ; Value of the first term ; Value of the last term ; Driver code ; Get the result,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } int main ( ) { int L = 6 , R = 12 ; double ans = get ( L , R ) ; cout << fixed << setprecision ( 2 ) << ans ; return 0 ; }",Find Range Value of the Expression.,"#include <bits/stdc++.h> 
 using namespace std ; double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } int main ( ) { int L = 6 , R = 12 ; double ans = get ( L , R ) ; cout << fixed << setprecision ( 2 ) << ans ; return 0 ; }","['double get ( double L , double R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double get ( double L , double R ) {
"
399,Minimum deletions required such that any number X will occur exactly X times | C ++ implementation of the approach ; Function to return the minimum deletions required ; To store the frequency of the array elements ; Store frequency of each element ; To store the minimum deletions required ; Value ; It 's frequency ; If number less than or equal to it 's frequency ; Delete extra occurrences ; Delete every occurrence of x ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinDeletion ( int a [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ a [ i ] ] ++ ; int ans = 0 ; for ( auto i : map ) { int x = i . first ; int frequency = i . second ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } int main ( ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinDeletion ( a , n ) ; return 0 ; }",Minimum deletions required such that any number X will occur exactly X times.,"#include <bits/stdc++.h> 
 using namespace std ; int MinDeletion ( int a [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ a [ i ] ] ++ ; int ans = 0 ; for ( auto i : map ) { int x = i . first ; int frequency = i . second ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } int main ( ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinDeletion ( a , n ) ; return 0 ; }","['int MinDeletion ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MinDeletion ( int a [ ] , int n ) {
"
400,"Concatenate strings in any order to get Maximum Number of "" AB "" | C ++ implementation of above approach ; Function to find maximum number of ABs ; variable A , B , AB for count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively . ; ' AB ' is already present in string before concatenate them ; count of strings that begins with ' B ' and ends with 'A ; count of strings that begins with ' B ' but does not end with ' A ' ; count of strings that ends with ' A ' but not end with ' B ' ; updating the value of ans and add extra count of ' AB ' ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCountAB ( string s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . at ( j ) == ' A ' && S . at ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . at ( 0 ) == ' B ' && S . at ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . at ( 0 ) == ' B ' ) B ++ ; else if ( S . at ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; } int main ( ) { string s [ ] = { "" ABCA "" , "" BOOK "" , "" BAND "" } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; cout << maxCountAB ( s , n ) ; return 0 ; }","Concatenate strings in any order to get Maximum Number of "" AB "".","#include <bits/stdc++.h> 
 using namespace std ; int maxCountAB ( string s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . at ( j ) == ' A ' && S . at ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . at ( 0 ) == ' B ' && S . at ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . at ( 0 ) == ' B ' ) B ++ ; else if ( S . at ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; } int main ( ) { string s [ ] = { "" ABCA "" , "" BOOK "" , "" BAND "" } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; cout << maxCountAB ( s , n ) ; return 0 ; }","['int maxCountAB ( string s [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxCountAB ( string s [ ] , int n ) {
"
401,Minimum operations to make sum of neighbouring elements <= X | C ++ implementation of the approach ; Function to return the minimum number of operations required ; To store total operations required ; First make all elements equal to x which are currenctly greater ; Left scan the array ; Update the current element such that neighbouring sum is < x ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperations ( int n , int x , int * arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } int main ( ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << MinOperations ( N , X , arr ) ; return 0 ; }",Minimum operations to make sum of neighbouring elements <= X.,"#include <bits/stdc++.h> 
 using namespace std ; int MinOperations ( int n , int x , int * arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } int main ( ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << MinOperations ( N , X , arr ) ; return 0 ; }","['int MinOperations ( int n , int x , int * arr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MinOperations ( int n , int x , int * arr ) {
"
402,Find the repeating and the missing number using two equations | C ++ implementation of the approach ; Function to print the required numbers ; Sum of first n natural numbers ; Sum of squares of first n natural numbers ; To store the sum and sum of squares of the array elements ; Driver code,"#include <cmath> NEW_LINE #include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq = sumSq + ( pow ( arr [ i ] , 2 ) ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; cout << "" A ▁ = ▁ "" ; cout << A << endl ; cout << "" B ▁ = ▁ "" ; cout << B << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findNumbers ( arr , n ) ; return 0 ; }",Find the repeating and the missing number using two equations.,"#include <cmath> 
 #include <bits/stdc++.h> 
 #include <iostream> 
 using namespace std ; void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq = sumSq + ( pow ( arr [ i ] , 2 ) ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; cout << "" A ▁ = ▁ "" ; cout << A << endl ; cout << "" B ▁ = ▁ "" ; cout << B << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findNumbers ( arr , n ) ; return 0 ; }","['void findNumbers ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <cmath> 
 #include <bits/stdc++.h> 
 #include <iostream> 
 using namespace std ;
 void findNumbers ( int arr [ ] , int n ) {
"
405,"Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules | C ++ program for the above approach ; Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies ; Find the minimum required value of candies for the first person ; Iterate K from [ 1 , n ] ; Total number of candies ; Candies taken by Person 1 ; Candies taken by 1 st person is minimum of K and candies left ; Traverse the array arr [ ] ; Amount consumed by the person j ; Update the number of candies ; Good share of candies achieved ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumK ( vector < int > & arr , int M , int N ) { int good = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { cout << i ; return ; } } } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , M , N ) ; return 0 ; }",Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules.,"#include <bits/stdc++.h> 
 using namespace std ; void minimumK ( vector < int > & arr , int M , int N ) { int good = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { cout << i ; return ; } } } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , M , N ) ; return 0 ; }","['void minimumK ( vector < int > & arr , int M , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minimumK ( vector < int > & arr , int M , int N ) {
"
407,Total time required to travel a path denoted by a given string | C ++ code for the above approach ; Function to calculate time taken to travel the path ; Stores total time ; Initial position ; Stores visited segments ; Check whether segment is present in the set ; Increment the value of time by 2 ; Insert segment into the set ; Print the value of time ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void calcTotalTime ( string path ) { int time = 0 ; int x = 0 , y = 0 ; set < pair < int , int > > s ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { int p = x ; int q = y ; if ( path [ i ] == ' N ' ) y ++ ; else if ( path [ i ] == ' S ' ) y -- ; else if ( path [ i ] == ' E ' ) x ++ ; else if ( path [ i ] == ' W ' ) x -- ; if ( s . find ( { p + x , q + y } ) == s . end ( ) ) { time += 2 ; s . insert ( { p + x , q + y } ) ; } else time += 1 ; } cout << time << endl ; } int main ( ) { string path = "" NSE "" ; calcTotalTime ( path ) ; return 0 ; }",Total time required to travel a path denoted by a given string.,"#include <bits/stdc++.h> 
 using namespace std ; void calcTotalTime ( string path ) { int time = 0 ; int x = 0 , y = 0 ; set < pair < int , int > > s ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { int p = x ; int q = y ; if ( path [ i ] == ' N ' ) y ++ ; else if ( path [ i ] == ' S ' ) y -- ; else if ( path [ i ] == ' E ' ) x ++ ; else if ( path [ i ] == ' W ' ) x -- ; if ( s . find ( { p + x , q + y } ) == s . end ( ) ) { time += 2 ; s . insert ( { p + x , q + y } ) ; } else time += 1 ; } cout << time << endl ; } int main ( ) { string path = "" NSE "" ; calcTotalTime ( path ) ; return 0 ; }","['void calcTotalTime ( string path ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void calcTotalTime ( string path ) {
"
408,Cost required to make all array elements equal to 1 | C ++ program for the above approach ; Function to calculate the cost required to make all array elements equal to 1 ; Stores the total cost ; Traverse the array arr [ ] ; If current element is 0 ; Convert 0 to 1 ; Add the cost ; Return the total cost ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCost ( arr , N ) ; return 0 ; }",Cost required to make all array elements equal to 1.,"#include <bits/stdc++.h> 
 using namespace std ; int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCost ( arr , N ) ; return 0 ; }","['int findCost ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findCost ( int A [ ] , int N ) {
"
409,"Find the peak index of a given array | C ++ program for the above approach ; Function to find the peak index for the given array ; Base Case ; Check for strictly increasing array ; If the strictly increasing condition is violated , then break ; Stores the value of i , which is a potential peak index ; Second traversal , for strictly decreasing array ; When the strictly decreasing condition is violated , then break ; If i = N - 1 , it means that ans is the peak index ; Otherwise , peak index doesn 't exist ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int peakIndex ( int arr [ ] , int N ) { if ( N < 3 ) return -1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return -1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return -1 ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << peakIndex ( arr , N ) << "" STRNEWLINE "" ; return 0 ; }",Find the peak index of a given array.,"#include <bits/stdc++.h> 
 using namespace std ; int peakIndex ( int arr [ ] , int N ) { if ( N < 3 ) return -1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return -1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return -1 ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << peakIndex ( arr , N ) << "" STRNEWLINE "" ; return 0 ; }","['int peakIndex ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int peakIndex ( int arr [ ] , int N ) {
"
411,Smallest divisor of N closest to X | C ++ program for the above approach ; Function to find the divisor of N closest to the target ; Iterate till square root of N ; Check if divisors are equal ; Check if i is the closest ; Check if i is the closest ; Check if n / i is the closest ; Print the closest value ; Driver Code ; Given N & X ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findClosest ( int N , int target ) { int closest = -1 ; int diff = INT_MAX ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } } else { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } if ( abs ( target - N / i ) < diff ) { diff = abs ( target - N / i ) ; closest = N / i ; } } } } cout << closest ; } int main ( ) { int N = 16 , X = 5 ; findClosest ( N , X ) ; return 0 ; }",Smallest divisor of N closest to X.,"#include <bits/stdc++.h> 
 using namespace std ; int findClosest ( int N , int target ) { int closest = -1 ; int diff = INT_MAX ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } } else { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } if ( abs ( target - N / i ) < diff ) { diff = abs ( target - N / i ) ; closest = N / i ; } } } } cout << closest ; } int main ( ) { int N = 16 , X = 5 ; findClosest ( N , X ) ; return 0 ; }","['int findClosest ( int N , int target ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findClosest ( int N , int target ) {
"
414,Minimum number of coins to be collected per hour to empty N piles in at most H hours | C ++ program for the above approach ; Function to find the minimum number of coins to be collected per hour to empty N piles in H hours ; Stores the minimum coins to be removed per hour ; Find the maximum array element ; Perform Binary Search ; Store the mid value of the range in K ; Find the total time taken to empty N piles by removing K coins per hour ; If total time does not exceed H ; Otherwise ; Print the required result ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCollectingSpeed ( vector < int > & piles , int H ) { int ans = -1 ; int low = 1 , high ; high = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } cout << ans ; } int main ( ) { vector < int > arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; return 0 ; }",Minimum number of coins to be collected per hour to empty N piles in at most H hours.,"#include <bits/stdc++.h> 
 using namespace std ; int minCollectingSpeed ( vector < int > & piles , int H ) { int ans = -1 ; int low = 1 , high ; high = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } cout << ans ; } int main ( ) { vector < int > arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; return 0 ; }","['int minCollectingSpeed ( vector < int > & piles , int H ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minCollectingSpeed ( vector < int > & piles , int H ) {
"
416,Count distinct pairs with given sum | C ++ program to implement the above approach ; Function to count distinct pairs in array whose sum equal to K ; Stores count of distinct pairs whose sum equal to K ; Store frequency of each distinct element of the array ; Update frequency of arr [ i ] ; Traverse the map ; Stores key value of the map ; If i is the half of K ; If frequency of i greater than 1 ; Update cntPairs ; Update cntPairs ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; unordered_map < int , int > cntFre ; for ( int i = 0 ; i < N ; i ++ ) { cntFre [ arr [ i ] ] ++ ; } for ( auto it : cntFre ) { int i = it . first ; if ( 2 * i == K ) { if ( cntFre [ i ] > 1 ) cntPairs += 2 ; } else { if ( cntFre [ K - i ] ) { cntPairs += 1 ; } } } cntPairs = cntPairs / 2 ; return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }",Count distinct pairs with given sum.,"#include <bits/stdc++.h> 
 using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; unordered_map < int , int > cntFre ; for ( int i = 0 ; i < N ; i ++ ) { cntFre [ arr [ i ] ] ++ ; } for ( auto it : cntFre ) { int i = it . first ; if ( 2 * i == K ) { if ( cntFre [ i ] > 1 ) cntPairs += 2 ; } else { if ( cntFre [ K - i ] ) { cntPairs += 1 ; } } } cntPairs = cntPairs / 2 ; return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }","['int cntDisPairs ( int arr [ ] , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int cntDisPairs ( int arr [ ] , int N , int K ) {
"
417,"Queries to find longest subsequence having no similar adjacent elements with updates | C ++ program for the above approach ; Function to find the length of the longest subsequence such that no two adjacent elements are equal ; Replace element at index x with y ; Since x is 1 - indexed , decrement x by 1 ; Keep track of number of elements in subsequence ; If previous element is not same as current element ; Print the desired count ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } cout << count << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }",Queries to find longest subsequence having no similar adjacent elements with updates.,"#include <bits/stdc++.h> 
 using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } cout << count << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }","['void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) {
"
418,Queries to find longest subsequence having no similar adjacent elements with updates | C ++ program for the above approach ; Traverse the array arr [ ] ; If previous element is not same as current element ; Traverse the queries ; Replace element at index x with y ; Recalculate for index x ; Subtract contribution of element at index x ; Add contribution of y ; Recalculate for index x + 1 ; Subtract contribution of element at index x + 1 ; Adds contribution of y ; Replace the element ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } cout << count << ' ▁ ' ; arr [ x - 1 ] = y ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }",Queries to find longest subsequence having no similar adjacent elements with updates.,"#include <bits/stdc++.h> 
 using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } cout << count << ' ▁ ' ; arr [ x - 1 ] = y ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }","['void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) {
"
419,Sum of absolute differences of indices of occurrences of each array element | C ++ program for the above approach ; Function to find sum of differences of indices of occurrences of each unique array element ; Stores indices of each array element ; Store the indices ; Stores the sums ; Traverse the array ; Find sum for each element ; Iterate over the Map ; Calculate sum of occurrences of arr [ i ] ; Store sum for current element ; Print answer for each element ; Driver Code ; Given array ; Given size ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void sum ( int arr [ ] , int n ) { map < int , vector < int > > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] . push_back ( i ) ; } int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( auto it : mp [ arr [ i ] ] ) { sum += abs ( it - i ) ; } ans [ i ] = sum ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << "" ▁ "" ; } return ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum ( arr , n ) ; return 0 ; }",Sum of absolute differences of indices of occurrences of each array element.,"#include <bits/stdc++.h> 
 using namespace std ; void sum ( int arr [ ] , int n ) { map < int , vector < int > > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] . push_back ( i ) ; } int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( auto it : mp [ arr [ i ] ] ) { sum += abs ( it - i ) ; } ans [ i ] = sum ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << "" ▁ "" ; } return ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum ( arr , n ) ; return 0 ; }","['void sum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void sum ( int arr [ ] , int n ) {
"
420,Convert vowels into upper case character in a given string | C ++ program to implement the above approach ; Function to convert vowels into uppercase ; Stores the length of str ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string conVowUpp ( string & str ) { int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { str [ i ] = str [ i ] - ' a ' + ' A ' ; } } return str ; } int main ( ) { string str = "" eutopia "" ; cout << conVowUpp ( str ) ; }",Convert vowels into upper case character in a given string.,"#include <bits/stdc++.h> 
 using namespace std ; string conVowUpp ( string & str ) { int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { str [ i ] = str [ i ] - ' a ' + ' A ' ; } } return str ; } int main ( ) { string str = "" eutopia "" ; cout << conVowUpp ( str ) ; }","['string conVowUpp ( string & str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string conVowUpp ( string & str ) {
"
422,Count subarrays having sum modulo K same as the length of the subarray | C ++ program of the above approach ; Function that counts the subarrays having sum modulo k equal to the length of subarray ; Stores the count of subarrays ; Stores prefix sum of the array ; Calculate prefix sum array ; Generate all the subarrays ; Check if this subarray is a valid subarray or not ; Total count of subarrays ; Driver Code ; Given arr [ ] ; Size of the array ; Given K ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }",Count subarrays having sum modulo K same as the length of the subarray.,"#include <bits/stdc++.h> 
 using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }","['int countSubarrays ( int a [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long long int countSubarrays ( int a [ ] , int n , int k ) {
"
423,Count subarrays having sum modulo K same as the length of the subarray | C ++ program of the above approach ; Function that counts the subarrays s . t . sum of elements in the subarray modulo k is equal to size of subarray ; Stores the count of ( pref [ i ] - i ) % k ; Stores the count of subarray ; Stores prefix sum of the array ; Find prefix sum array ; Base Condition ; Remove the index at present after K indices from the current index ; Update the answer for subarrays ending at the i - th index ; Add the calculated value of current index to count ; Print the count of subarrays ; Driver Code ; Given arr [ ] ; Size of the array ; Given K ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { unordered_map < int , int > cnt ; long long int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; cnt [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int remIdx = i - k ; if ( remIdx >= 0 ) { cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -- ; } ans += cnt [ ( pref [ i ] - i % k + k ) % k ] ; cnt [ ( pref [ i ] - i % k + k ) % k ] ++ ; } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }",Count subarrays having sum modulo K same as the length of the subarray.,"#include <bits/stdc++.h> 
 using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { unordered_map < int , int > cnt ; long long int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; cnt [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int remIdx = i - k ; if ( remIdx >= 0 ) { cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -- ; } ans += cnt [ ( pref [ i ] - i % k + k ) % k ] ; cnt [ ( pref [ i ] - i % k + k ) % k ] ++ ; } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }","['int countSubarrays ( int a [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long long int countSubarrays ( int a [ ] , int n , int k ) {
"
424,Check if all substrings of length K of a Binary String has equal count of 0 s and 1 s | C ++ program for the above approach ; Function to check if the substring of length K has equal 0 and 1 ; Traverse the string ; Check if every K - th character is the same or not ; Traverse substring of length K ; If current character is 0 ; Increment count ; Otherwise ; Decrement count ; Check for equal 0 s and 1 s ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int check ( string & s , int k ) { int n = s . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } int main ( ) { string s = ""101010"" ; int k = 2 ; if ( check ( s , k ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; return 0 ; }",Check if all substrings of length K of a Binary String has equal count of 0 s and 1 s.,"#include <iostream> 
 using namespace std ; int check ( string & s , int k ) { int n = s . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } int main ( ) { string s = ""101010"" ; int k = 2 ; if ( check ( s , k ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; return 0 ; }","['int check ( string & s , int k ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int check ( string & s , int k ) {
"
425,Check if characters of a given string can be used to form any N equal strings | C ++ program for the above approach ; Function to check if the freq of any character is divisible by N ; Stores the frequency of characters ; If frequency of a character is not divisible by n ; If no character has frequency at least N ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSame ( string str , int n ) { map < int , int > mp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mp [ str [ i ] - ' a ' ] ++ ; } for ( auto it : mp ) { if ( ( it . second ) >= n ) { return true ; } } return false ; } int main ( ) { string str = "" ccabcba "" ; int n = 4 ; if ( isSame ( str , n ) ) { cout << "" Yes "" ; } else { cout << "" No "" ; } }",Check if characters of a given string can be used to form any N equal strings.,"#include <bits/stdc++.h> 
 using namespace std ; bool isSame ( string str , int n ) { map < int , int > mp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mp [ str [ i ] - ' a ' ] ++ ; } for ( auto it : mp ) { if ( ( it . second ) >= n ) { return true ; } } return false ; } int main ( ) { string str = "" ccabcba "" ; int n = 4 ; if ( isSame ( str , n ) ) { cout << "" Yes "" ; } else { cout << "" No "" ; } }","['bool isSame ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isSame ( string str , int n ) {
"
428,Print all Strings from array A [ ] having all strings from array B [ ] as subsequence | C ++ Program to implement the above approach ; Function to find strings from A [ ] having all strings in B [ ] as subsequence ; Calculate respective sizes ; Stores the answer ; Stores the frequency of each character in strings of A [ ] ; Compute the frequencies of characters of all strings ; Stores the frequency of each character in strings of B [ ] each character of a string in B [ ] ; If the frequency of a character in B [ ] exceeds that in A [ ] ; A string exists in B [ ] which is not a proper subset of A [ i ] ; If all strings in B [ ] are proper subset of A [ ] ; Push the string in resultant vector ; If any string is found ; Print those strings ; Otherwise ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void UniversalSubset ( vector < string > A , vector < string > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; vector < string > res ; int A_fre [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) { A_fre [ i ] [ A [ i ] [ j ] - ' a ' ] ++ ; } } int B_fre [ 26 ] = { 0 } ; for ( int i = 0 ; i < n2 ; i ++ ) { int arr [ 26 ] = { 0 } ; for ( int j = 0 ; j < B [ i ] . size ( ) ; j ++ ) { arr [ B [ i ] [ j ] - ' a ' ] ++ ; B_fre [ B [ i ] [ j ] - ' a ' ] = max ( B_fre [ B [ i ] [ j ] - ' a ' ] , arr [ B [ i ] [ j ] - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push_back ( A [ i ] ) ; } if ( res . size ( ) ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res [ i ] . size ( ) ; j ++ ) cout << res [ i ] [ j ] ; } cout << "" ▁ "" ; } else cout << "" - 1"" ; } int main ( ) { vector < string > A = { "" geeksforgeeks "" , "" topcoder "" , "" leetcode "" } ; vector < string > B = { "" geek "" , "" ee "" } ; UniversalSubset ( A , B ) ; return 0 ; }",Print all Strings from array A [ ] having all strings from array B [ ] as subsequence.,"#include <bits/stdc++.h> 
 using namespace std ; void UniversalSubset ( vector < string > A , vector < string > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; vector < string > res ; int A_fre [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) { A_fre [ i ] [ A [ i ] [ j ] - ' a ' ] ++ ; } } int B_fre [ 26 ] = { 0 } ; for ( int i = 0 ; i < n2 ; i ++ ) { int arr [ 26 ] = { 0 } ; for ( int j = 0 ; j < B [ i ] . size ( ) ; j ++ ) { arr [ B [ i ] [ j ] - ' a ' ] ++ ; B_fre [ B [ i ] [ j ] - ' a ' ] = max ( B_fre [ B [ i ] [ j ] - ' a ' ] , arr [ B [ i ] [ j ] - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push_back ( A [ i ] ) ; } if ( res . size ( ) ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res [ i ] . size ( ) ; j ++ ) cout << res [ i ] [ j ] ; } cout << "" ▁ "" ; } else cout << "" - 1"" ; } int main ( ) { vector < string > A = { "" geeksforgeeks "" , "" topcoder "" , "" leetcode "" } ; vector < string > B = { "" geek "" , "" ee "" } ; UniversalSubset ( A , B ) ; return 0 ; }","['void UniversalSubset ( vector < string > A , vector < string > B ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void UniversalSubset ( vector < string > A , vector < string > B ) {
"
429,Closest pair in an Array such that one number is multiple of the other | C ++ program for the above approach ; Function to find the minimum distance pair where one is the multiple of the other ; Initialize the variables ; Iterate for all the elements ; Loop to make pairs ; Check for minimum distance ; Check if one is a multiple of other ; Update the distance ; Store indexes ; If no such pair exists ; Print the answer ; Driver Code ; Given array arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int a [ ] , int n ) { int min_dist = INT_MAX ; int index_a = -1 , index_b = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == -1 ) { cout << ( "" - 1"" ) ; } else { cout << "" ( "" << a [ index_a ] << "" , ▁ "" << a [ index_b ] << "" ) "" ; } } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( int ) ; findPair ( a , n ) ; }",Closest pair in an Array such that one number is multiple of the other.,"#include <bits/stdc++.h> 
 using namespace std ; void findPair ( int a [ ] , int n ) { int min_dist = INT_MAX ; int index_a = -1 , index_b = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == -1 ) { cout << ( "" - 1"" ) ; } else { cout << "" ( "" << a [ index_a ] << "" , ▁ "" << a [ index_b ] << "" ) "" ; } } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( int ) ; findPair ( a , n ) ; }","['void findPair ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findPair ( int a [ ] , int n ) {
"
430,"Print all numbers in given range having digits in strictly increasing order | C ++ program for the above approach ; Function to print all numbers in the range [ L , R ] having digits in strictly increasing order ; Iterate over the range ; Iterate over the digits ; Check if the current digit is >= the previous digit ; If the digits are in ascending order ; Driver Code ; Given range L and R ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << "" ▁ "" ; } } int main ( ) { int L = 10 , R = 15 ; printNum ( L , R ) ; return 0 ; }",Print all numbers in given range having digits in strictly increasing order.,"#include <bits/stdc++.h> 
 using namespace std ; void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << "" ▁ "" ; } } int main ( ) { int L = 10 , R = 15 ; printNum ( L , R ) ; return 0 ; }","['void printNum ( int L , int R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printNum ( int L , int R ) {
"
433,Count of subsets having sum of min and max element less than K | C ++ program to print count of subsets S such that min ( S ) + max ( S ) < K ; Function that return the count of subset such that min ( S ) + max ( S ) < K ; Sorting the array ; ans stores total number of subsets ; add all possible subsets between i and j ; Decrease the sum ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_subset_count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get_subset_count ( arr , K , N ) ; return 0 ; }",Count of subsets having sum of min and max element less than K.,"#include <bits/stdc++.h> 
 using namespace std ; int get_subset_count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get_subset_count ( arr , K , N ) ; return 0 ; }","['int get_subset_count ( int arr [ ] , int K , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int get_subset_count ( int arr [ ] , int K , int N ) {
"
434,Minimize the maximum difference of adjacent elements after at most K insertions | C ++ Program to find the minimum of maximum differerence between adjacent elements after at most K insertions ; Calculate the maximum adjacent difference ; If the maximum adjacent difference is already zero ; best and worst specifies range of the maximum adjacent difference ; To store the no of insertions required for respective values of mid ; If the number of insertions required exceeds K ; Otherwise ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } int main ( ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; cout << minMaxDiff ( arr , n , k ) ; return 0 ; }",Minimize the maximum difference of adjacent elements after at most K insertions.,"#include <bits/stdc++.h> 
 using namespace std ; int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } int main ( ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; cout << minMaxDiff ( arr , n , k ) ; return 0 ; }","['int minMaxDiff ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minMaxDiff ( int arr [ ] , int n , int k ) {
"
439,Check duplicates in a stream of strings | C ++ implementation of the approach ; Function to insert the names and check whether they appear for the first time ; To store the names of the employees ; If current name is appearing for the first time ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertNames ( string arr [ ] , int n ) { unordered_set < string > set ; for ( int i = 0 ; i < n ; i ++ ) { if ( set . find ( arr [ i ] ) == set . end ( ) ) { cout << "" No STRNEWLINE "" ; set . insert ( arr [ i ] ) ; } else { cout << "" Yes STRNEWLINE "" ; } } } int main ( ) { string arr [ ] = { "" geeks "" , "" for "" , "" geeks "" } ; int n = sizeof ( arr ) / sizeof ( string ) ; insertNames ( arr , n ) ; return 0 ; }",Check duplicates in a stream of strings.,"#include <bits/stdc++.h> 
 using namespace std ; void insertNames ( string arr [ ] , int n ) { unordered_set < string > set ; for ( int i = 0 ; i < n ; i ++ ) { if ( set . find ( arr [ i ] ) == set . end ( ) ) { cout << "" No STRNEWLINE "" ; set . insert ( arr [ i ] ) ; } else { cout << "" Yes STRNEWLINE "" ; } } } int main ( ) { string arr [ ] = { "" geeks "" , "" for "" , "" geeks "" } ; int n = sizeof ( arr ) / sizeof ( string ) ; insertNames ( arr , n ) ; return 0 ; }","['void insertNames ( string arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void insertNames ( string arr [ ] , int n ) {
"
441,Cost to Balance the parentheses | CPP code to calculate the minimum cost to make the given parentheses balanced ; To store absolute count of balanced and unbalanced parenthesis ; o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ' ) ' ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) o ++ ; if ( s [ i ] == ' ) ' ) c ++ ; } if ( o != c ) return -1 ; int a [ s . size ( ) ] ; if ( s [ 0 ] == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = -1 ; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ) ; } return ans ; } int main ( ) { string s ; s = "" ) ) ) ( ( ( "" ; cout << costToBalance ( s ) << endl ; s = "" ) ) ( ( "" ; cout << costToBalance ( s ) << endl ; return 0 ; }",Cost to Balance the parentheses.,"#include <bits/stdc++.h> 
 using namespace std ; int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) o ++ ; if ( s [ i ] == ' ) ' ) c ++ ; } if ( o != c ) return -1 ; int a [ s . size ( ) ] ; if ( s [ 0 ] == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = -1 ; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ) ; } return ans ; } int main ( ) { string s ; s = "" ) ) ) ( ( ( "" ; cout << costToBalance ( s ) << endl ; s = "" ) ) ( ( "" ; cout << costToBalance ( s ) << endl ; return 0 ; }","['int costToBalance ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int costToBalance ( string s ) {
"
442,Middle of three using minimum comparisons | CPP program to find middle of three distinct numbers ; Function to find the middle of three number ; x is positive if a is greater than b . x is negative if b is greater than a . ; Similar to x ; Similar to x and y . ; Checking if b is middle ( x and y both are positive ) ; Checking if c is middle ( x and z both are positive ) ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }",Middle of three using minimum comparisons.,"#include <bits/stdc++.h> 
 using namespace std ; int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }","['int middleOfThree ( int a , int b , int c ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int middleOfThree ( int a , int b , int c ) {
"
444,"Permutation present at the middle of lexicographic ordering of permutations of at most length N made up integers up to K | C ++ program for the above approach ; Function that finds the middle the lexicographical smallest sequence ; If K is even ; First element is K / 2 ; Remaining elements of the sequence are all integer K ; Stores the sequence when K is odd ; Iterate over the range [ 0 , N / 2 ] ; Check if the sequence ends with in 1 or not ; Remove the sequence ending in 1 ; If it doesn 't end in 1 ; Decrement by 1 ; Insert K to the sequence till its size is N ; Print the sequence stored in the vector ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { cout << K / 2 << "" ▁ "" ; for ( int i = 0 ; i < N - 1 ; ++ i ) { cout << K << "" ▁ "" ; } cout << "" STRNEWLINE "" ; exit ( 0 ) ; } vector < int > a ( N , ( K + 1 ) / 2 ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . back ( ) == 1 ) { a . pop_back ( ) ; } else { -- a . back ( ) ; while ( ( int ) a . size ( ) < N ) { a . push_back ( K ) ; } } } for ( auto i : a ) { cout << i << "" ▁ "" ; } cout << "" STRNEWLINE "" ; } int main ( ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; return 0 ; }",Permutation present at the middle of lexicographic ordering of permutations of at most length N made up integers up to K.,"#include <bits/stdc++.h> 
 using namespace std ; void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { cout << K / 2 << "" ▁ "" ; for ( int i = 0 ; i < N - 1 ; ++ i ) { cout << K << "" ▁ "" ; } cout << "" STRNEWLINE "" ; exit ( 0 ) ; } vector < int > a ( N , ( K + 1 ) / 2 ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . back ( ) == 1 ) { a . pop_back ( ) ; } else { -- a . back ( ) ; while ( ( int ) a . size ( ) < N ) { a . push_back ( K ) ; } } } for ( auto i : a ) { cout << i << "" ▁ "" ; } cout << "" STRNEWLINE "" ; } int main ( ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; return 0 ; }","['void lexiMiddleSmallest ( int K , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void lexiMiddleSmallest ( int K , int N ) {
"
445,Remaining array element after repeated removal of the smallest element from pairs with absolute difference of 2 or 0 | C ++ program for the above approach ; Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0 ; Sort the given array in ascending order ; Traverse the array ; If difference between adjacent elements is not equal to 0 or 2 ; If operations can be performed ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLastElement ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { cout << "" - 1"" << endl ; return ; } } cout << arr [ N - 1 ] << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLastElement ( arr , N ) ; return 0 ; }",Remaining array element after repeated removal of the smallest element from pairs with absolute difference of 2 or 0.,"#include <bits/stdc++.h> 
 using namespace std ; void findLastElement ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { cout << "" - 1"" << endl ; return ; } } cout << arr [ N - 1 ] << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLastElement ( arr , N ) ; return 0 ; }","['void findLastElement ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findLastElement ( int arr [ ] , int N ) {
"
446,Maximize count of subsets into which the given array can be split such that it satisfies the given condition | C ++ program for the above approach ; Function to count maximum subsets into which the given array can be split such that it satisfies the given condition ; Sort the array in decreasing order ; Stores count of subsets possible ; Stores count of elements in current subset ; Traverse the array arr [ ] ; Update size ; If product of the smallest element present in the current subset and size of current subset is >= K ; Update maxSub ; Update size ; Driver Code ; Given array ; Size of the array ; Given value of X,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDivisions ( int arr [ ] , int N , int X ) { sort ( arr , arr + N , greater < int > ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } cout << maxSub << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 3 ; maxDivisions ( arr , N , X ) ; return 0 ; }",Maximize count of subsets into which the given array can be split such that it satisfies the given condition.,"#include <bits/stdc++.h> 
 using namespace std ; void maxDivisions ( int arr [ ] , int N , int X ) { sort ( arr , arr + N , greater < int > ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } cout << maxSub << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 3 ; maxDivisions ( arr , N , X ) ; return 0 ; }","['void maxDivisions ( int arr [ ] , int N , int X ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maxDivisions ( int arr [ ] , int N , int X ) {
"
447,Maximize sum of second minimums in all quadruples of a given array | C ++ program for the above approach ; Function to find maximum possible sum of second minimums in each quadruple ; Sort the array ; Add the second minimum ; Print maximum possible sum ; Driver Code ; Given array ; Size of the array,"#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPossibleSum ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } cout << sum ; } int main ( ) { int arr [ ] = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ; int N = 8 ; maxPossibleSum ( arr , N ) ; return 0 ; }",Maximize sum of second minimums in all quadruples of a given array.,"#include <iostream> 
 #include <bits/stdc++.h> 
 using namespace std ; void maxPossibleSum ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } cout << sum ; } int main ( ) { int arr [ ] = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ; int N = 8 ; maxPossibleSum ( arr , N ) ; return 0 ; }","['void maxPossibleSum ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <iostream> 
 #include <bits/stdc++.h> 
 using namespace std ;
 void maxPossibleSum ( int arr [ ] , int N ) {
"
449,"Count pairs ( i , j ) from given array such that i K * arr [ j ] | C ++ program for the above approach ; Function to find the count required pairs ; Stores count of pairs ; Traverse the array ; Check if the condition is satisfied or not ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; getPairs ( arr , N , K ) ; return 0 ; }","Count pairs ( i , j ) from given array such that i K * arr [ j ].","#include <bits/stdc++.h> 
 using namespace std ; int getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; getPairs ( arr , N , K ) ; return 0 ; }","['int getPairs ( int arr [ ] , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getPairs ( int arr [ ] , int N , int K ) {
"
451,Minimize consecutive removals of elements of the same type to empty given array | C ++ implementation of the above approach ; Function to count minimum consecutive removals of elements of the same type ; Sort the array ; Stores the maximum element present in the array ; Stores sum of the array ; Calculate sum of the array ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minRemovals ( int A [ ] , int N ) { sort ( A , A + N ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { cout << 0 << "" STRNEWLINE "" ; } else { cout << 2 * mx - sum << "" STRNEWLINE "" ; } } int main ( ) { int A [ ] = { 3 , 3 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minRemovals ( A , N ) ; return 0 ; }",Minimize consecutive removals of elements of the same type to empty given array.,"#include <bits/stdc++.h> 
 using namespace std ; void minRemovals ( int A [ ] , int N ) { sort ( A , A + N ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { cout << 0 << "" STRNEWLINE "" ; } else { cout << 2 * mx - sum << "" STRNEWLINE "" ; } } int main ( ) { int A [ ] = { 3 , 3 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minRemovals ( A , N ) ; return 0 ; }","['void minRemovals ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minRemovals ( int A [ ] , int N ) {
"
452,"Rearrange given array such that no array element is same as its index | C ++ program for the above approach ; Function to rearrange the array a [ ] such that none of the array elements is same as its index ; Sort the array ; Traverse the indices [ 0 , N - 2 ] of the given array ; Check if the current element is equal to its index ; If found to be true , swap current element with the next element ; Check if the last element is same as its index ; If found to be true , swap current element with the previous element ; Print the modified array ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int a [ ] , int n ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { swap ( a [ i ] , a [ i + 1 ] ) ; } } if ( a [ n - 1 ] == n ) { swap ( a [ n - 1 ] , a [ n - 2 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArray ( arr , N ) ; return 0 ; }",Rearrange given array such that no array element is same as its index.,"#include <bits/stdc++.h> 
 using namespace std ; void rearrangeArray ( int a [ ] , int n ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { swap ( a [ i ] , a [ i + 1 ] ) ; } } if ( a [ n - 1 ] == n ) { swap ( a [ n - 1 ] , a [ n - 2 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArray ( arr , N ) ; return 0 ; }","['void rearrangeArray ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void rearrangeArray ( int a [ ] , int n ) {
"
454,Check if a string can be transformed to another by sorting substrings | C ++ Program to implement the above approach ; Function to check if str1 can be transformed to t by sorting substrings ; Occur [ i ] stores the indices of char ( ' a ' + i ) in string s ; idx [ i ] stores the next available index of char ( ' a ' + i ) in occur [ i ] ; If this char is not available anymore ; Conversion not possible ; If one of the smaller characters is available and occurs before ; Conversion not possible ; Print the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void canTransform ( string & s , string & t ) { int n = s . length ( ) ; vector < int > occur [ 26 ] ; for ( int x = 0 ; x < n ; x ++ ) { char ch = s [ x ] - ' a ' ; occur [ ch ] . push_back ( x ) ; } vector < int > idx ( 26 , 0 ) ; bool poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = t [ x ] - ' a ' ; if ( idx [ ch ] >= occur [ ch ] . size ( ) ) { poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } } int main ( ) { string s , t ; s = "" hdecb "" ; t = "" cdheb "" ; canTransform ( s , t ) ; return 0 ; }",Check if a string can be transformed to another by sorting substrings.,"#include <bits/stdc++.h> 
 using namespace std ; void canTransform ( string & s , string & t ) { int n = s . length ( ) ; vector < int > occur [ 26 ] ; for ( int x = 0 ; x < n ; x ++ ) { char ch = s [ x ] - ' a ' ; occur [ ch ] . push_back ( x ) ; } vector < int > idx ( 26 , 0 ) ; bool poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = t [ x ] - ' a ' ; if ( idx [ ch ] >= occur [ ch ] . size ( ) ) { poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } } int main ( ) { string s , t ; s = "" hdecb "" ; t = "" cdheb "" ; canTransform ( s , t ) ; return 0 ; }","['void canTransform ( string & s , string & t ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void canTransform ( string & s , string & t ) {
"
456,Sort a Bitonic Array | C ++ program for the above approach ; Function to Sort a Bitonic array in constant space ; Initialize the value of k ; In each iteration compare elements k distance apart and swap if they are not in order ; k is reduced to half after every iteration ; Print the array elements ; Driver Code ; Given array arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArr ( int a [ ] , int n ) { int i , k ; k = ( int ) log2 ( n ) ; k = pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) swap ( a [ i ] , a [ i + k ] ) ; k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }",Sort a Bitonic Array.,"#include <bits/stdc++.h> 
 using namespace std ; void sortArr ( int a [ ] , int n ) { int i , k ; k = ( int ) log2 ( n ) ; k = pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) swap ( a [ i ] , a [ i + k ] ) ; k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }","['void sortArr ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void sortArr ( int a [ ] , int n ) {
"
457,Split array into K subsets to maximize their sum of maximums and minimums | C ++ Program to implement the above approach ; Function that prints the maximum sum possible ; Find elements in each group ; Sort all elements in non - descending order ; Add K largest elements ; For sum of minimum elements from each subset ; Printing the maximum sum ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; sort ( arr , arr + n ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } cout << sum << "" STRNEWLINE "" ; } int main ( ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; maximumSum ( Arr , size , K ) ; return 0 ; }",Split array into K subsets to maximize their sum of maximums and minimums.,"#include <bits/stdc++.h> 
 using namespace std ; void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; sort ( arr , arr + n ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } cout << sum << "" STRNEWLINE "" ; } int main ( ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; maximumSum ( Arr , size , K ) ; return 0 ; }","['void maximumSum ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maximumSum ( int arr [ ] , int n , int k ) {
"
458,Minimize sum of smallest elements from K subsequences of length L | C ++ Program to find the minimum possible sum of the smallest elements from K subsequences ; Function to find the minimum sum ; Sort the array ; Calculate sum of smallest K elements ; Return the sum ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int minsum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } int main ( ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , K , L , length ) ; return 0 ; }",Minimize sum of smallest elements from K subsequences of length L.,"#include <bits/stdc++.h> 
 using namespace std ; int findMinSum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int minsum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } int main ( ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , K , L , length ) ; return 0 ; }","['int findMinSum ( int arr [ ] , int K , int L , int size ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMinSum ( int arr [ ] , int K , int L , int size ) {
"
459,Kth smallest or largest element in unsorted Array | Set 4 | C ++ program for the above approach ; Function to find the Kth smallest element in Unsorted Array ; Initialize the max Element as 0 ; Iterate arr [ ] and find the maximum element in it ; Frequency array to store the frequencies ; Counter variable ; Counting the frequencies ; Iterate through the freq [ ] ; Check if num is present in the array ; Increment the counter with the frequency of num ; Checking if we have reached the Kth smallest element ; Return the Kth smallest element ; Driver Code ; Given array ; Function Call,"#include <iostream> NEW_LINE using namespace std ; int findKthSmallest ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int counter [ max + 1 ] = { 0 } ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } } int main ( ) { int arr [ ] = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; cout << findKthSmallest ( arr , N , K ) ; return 0 ; }",Kth smallest or largest element in unsorted Array.,"#include <iostream> 
 using namespace std ; int findKthSmallest ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int counter [ max + 1 ] = { 0 } ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } } int main ( ) { int arr [ ] = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; cout << findKthSmallest ( arr , N , K ) ; return 0 ; }","['int findKthSmallest ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int findKthSmallest ( int arr [ ] , int n , int k ) {
"
460,Generate all numbers up to N in Lexicographical Order | C ++ Program to implement the above approach ; Function to print all the numbers up to n in lexicographical order ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( stoi ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << "" ▁ "" ; } int main ( ) { int n = 15 ; lexNumbers ( n ) ; return 0 ; }",Generate all numbers up to N in Lexicographical Order.,"#include <bits/stdc++.h> 
 using namespace std ; void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( stoi ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << "" ▁ "" ; } int main ( ) { int n = 15 ; lexNumbers ( n ) ; return 0 ; }","['void lexNumbers ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void lexNumbers ( int n ) {
"
461,Sort Matrix in alternating ascending and descending order rowwise | C ++ implementation to print row of matrix in ascending or descending order alternatively ; Iterate matrix rowwise ; Sort even rows in ascending order ; compare adjacent elements ; swap adjacent element ; Sort even rows in descending order ; compare adjacent elements ; swap adjacent element ; Printing the final Output ; Driver code,"#include <stdio.h> NEW_LINE #define N  4 NEW_LINE void func ( int a [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( "" % d ▁ "" , a [ i ] [ j ] ) ; } printf ( "" STRNEWLINE "" ) ; } } int main ( ) { int a [ N ] [ N ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; return 0 ; }",Sort Matrix in alternating ascending and descending order rowwise.,"#include <stdio.h> 
 #define N  4 
 void func ( int a [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( "" % d ▁ "" , a [ i ] [ j ] ) ; } printf ( "" STRNEWLINE "" ) ; } } int main ( ) { int a [ N ] [ N ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; return 0 ; }","['void func ( int a [ ] [ N ] ) {', 'int main ( ) {']","#include <stdio.h> 
 #define N  4 
 void func ( int a [ ] [ N ] ) {
"
463,Count of distinct possible pairs such that the element from A is greater than the element from B | C ++ Program to count number of distinct pairs possible from the two arrays such that element selected from one array is always greater than the one selected from the other array ; Function to return the count of pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } int main ( ) { vector < int > A = { 30 , 28 , 45 , 22 } ; vector < int > B = { 35 , 25 , 22 , 48 } ; cout << countPairs ( A , B ) ; return 0 ; }",Count of distinct possible pairs such that the element from A is greater than the element from B.,"#include <bits/stdc++.h> 
 using namespace std ; int countPairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } int main ( ) { vector < int > A = { 30 , 28 , 45 , 22 } ; vector < int > B = { 35 , 25 , 22 , 48 } ; cout << countPairs ( A , B ) ; return 0 ; }","['int countPairs ( vector < int > A , vector < int > B ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countPairs ( vector < int > A , vector < int > B ) {
"
464,Maximum possible remainder when an element is divided by other element in the array | C ++ implementation of the approach ; Function to return the maximum mod value for any pair from the array ; Find the second maximum element from the array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMod ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxMod ( arr , n ) ; return 0 ; }",Maximum possible remainder when an element is divided by other element in the array.,"#include <bits/stdc++.h> 
 using namespace std ; int maxMod ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxMod ( arr , n ) ; return 0 ; }","['int maxMod ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxMod ( int arr [ ] , int n ) {
"
465,Choose X elements from A [ ] and Y elements from B [ ] which satisfy the given condition | C ++ implementation of the approach ; Function to that returns true if it possible to choose the elements ; If elements can 't be chosen ; Sort both the arrays ; If xth smallest element of A [ ] is smaller than the yth greatest element of B [ ] ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } int main ( ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = sizeof ( A ) / sizeof ( int ) ; int m = sizeof ( B ) / sizeof ( int ) ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Choose X elements from A [ ] and Y elements from B [ ] which satisfy the given condition.,"#include <bits/stdc++.h> 
 using namespace std ; bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } int main ( ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = sizeof ( A ) / sizeof ( int ) ; int m = sizeof ( B ) / sizeof ( int ) ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) {
"
466,Find minimum changes required in an array for it to contain k distinct elements | CPP program to minimum changes required in an array for k distinct elements . ; Function to minimum changes required in an array for k distinct elements . ; Store the frequency of each element ; Store the frequency of elements ; Sort frequencies in descending order ; To store the required answer ; Return the required answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << Min_Replace ( arr , n , k ) ; return 0 ; }",Find minimum changes required in an array for it to contain k distinct elements.,"#include <bits/stdc++.h> 
 using namespace std ; #define MAX  100005 
 int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << Min_Replace ( arr , n , k ) ; return 0 ; }","['int Min_Replace ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define MAX  100005 
 int Min_Replace ( int arr [ ] , int n , int k ) {
"
469,Minimum operations to make frequency of all characters equal K | C ++ program to convert the given string ; Function to find the minimum number of operations to convert the given string ; Check if N is divisible by K ; Array to store frequency of characters in given string ; Two arrays with number of operations required ; Checking for all possibility ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperation ( string S , int N , int K ) { if ( N % K ) { cout << "" Not ▁ Possible "" << endl ; return ; } int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ S [ i ] - 97 ] ++ ; } int E = N / K ; vector < int > greaterE ; vector < int > lessE ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push_back ( E - count [ i ] ) ; else greaterE . push_back ( count [ i ] - E ) ; } sort ( greaterE . begin ( ) , greaterE . end ( ) ) ; sort ( lessE . begin ( ) , lessE . end ( ) ) ; int mi = INT_MAX ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = min ( mi , max ( step1 , step2 ) ) ; } } cout << mi << endl ; } int main ( ) { string S = "" accb "" ; int N = S . size ( ) ; int K = 2 ; minOperation ( S , N , K ) ; return 0 ; }",Minimum operations to make frequency of all characters equal K.,"#include <bits/stdc++.h> 
 using namespace std ; void minOperation ( string S , int N , int K ) { if ( N % K ) { cout << "" Not ▁ Possible "" << endl ; return ; } int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ S [ i ] - 97 ] ++ ; } int E = N / K ; vector < int > greaterE ; vector < int > lessE ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push_back ( E - count [ i ] ) ; else greaterE . push_back ( count [ i ] - E ) ; } sort ( greaterE . begin ( ) , greaterE . end ( ) ) ; sort ( lessE . begin ( ) , lessE . end ( ) ) ; int mi = INT_MAX ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = min ( mi , max ( step1 , step2 ) ) ; } } cout << mi << endl ; } int main ( ) { string S = "" accb "" ; int N = S . size ( ) ; int K = 2 ; minOperation ( S , N , K ) ; return 0 ; }","['void minOperation ( string S , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minOperation ( string S , int N , int K ) {
"
470,Minimum range increment operations to Sort an array | C ++ program to find minimum range increments to sort an array ; Function to find minimum range increments to sort an array ; If current element is found greater than last element Increment all terms in range i + 1 to n - 1 ; mn = arr [ i ] ; Minimum in range i to n - 1 ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minMovesToSort ( arr , n ) ; return 0 ; }",Minimum range increment operations to Sort an array.,"#include <bits/stdc++.h> 
 using namespace std ; int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minMovesToSort ( arr , n ) ; return 0 ; }","['int minMovesToSort ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minMovesToSort ( int arr [ ] , int n ) {
"
472,Pair formation such that maximum pair sum is minimized | CPP Program to divide the array into N pairs such that maximum pair is minimized ; After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findOptimalPairs ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) cout << "" ( "" << arr [ i ] << "" , ▁ "" << arr [ j ] << "" ) "" << "" ▁ "" ; } int main ( ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findOptimalPairs ( arr , N ) ; return 0 ; }",Pair formation such that maximum pair sum is minimized.,"#include <bits/stdc++.h> 
 using namespace std ; void findOptimalPairs ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) cout << "" ( "" << arr [ i ] << "" , ▁ "" << arr [ j ] << "" ) "" << "" ▁ "" ; } int main ( ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findOptimalPairs ( arr , N ) ; return 0 ; }","['void findOptimalPairs ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findOptimalPairs ( int arr [ ] , int N ) {
"
475,Lexicographically smallest binary string formed by flipping bits at indices not divisible K1 or K2 such that count of 1 s is always greater than 0 s from left | C ++ program for the above approach ; Function to find lexicographically smallest string having number of 1 s greater than number of 0 s ; C1s And C0s stores the count of 1 s and 0 s at every position ; Traverse the string S ; If the position is not divisible by k1 and k2 ; If C0s >= C1s and pos [ ] is empty then the string can 't  be formed ; If pos [ ] is not empty then flip the bit of last position present in pos [ ] ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int k1 , int k2 , string s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push_back ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { cout << -1 ; flag = 1 ; break ; } else { int k = pos . back ( ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . pop_back ( ) ; } } } if ( flag == 0 ) { cout << s ; } } int main ( ) { int K1 = 2 , K2 = 4 ; string S = ""11000100"" ; generateString ( K1 , K2 , S ) ; return 0 ; }",Lexicographically smallest binary string formed by flipping bits at indices not divisible K1 or K2 such that count of 1 s is always greater than 0 s from left.,"#include <bits/stdc++.h> 
 using namespace std ; void generateString ( int k1 , int k2 , string s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push_back ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { cout << -1 ; flag = 1 ; break ; } else { int k = pos . back ( ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . pop_back ( ) ; } } } if ( flag == 0 ) { cout << s ; } } int main ( ) { int K1 = 2 , K2 = 4 ; string S = ""11000100"" ; generateString ( K1 , K2 , S ) ; return 0 ; }","['void generateString ( int k1 , int k2 , string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void generateString ( int k1 , int k2 , string s ) {
"
476,"Find a pair of numbers with set bit count as at most that of N and whose Bitwise XOR is N | C ++ program for the above approach ; Function to find the pair ( X , Y ) such that X xor Y = N and the count of set bits in X and Y is less than count of set bit in N ; Stores MSB ( Most Significant Bit ) ; Stores the value of X ; Stores the value of Y ; Traversing over all bits of N ; If ith bit of N is 0 ; Set ith bit of X to 1 ; Set ith bit of Y to 1 ; Print Answer ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximizeProduct ( int N ) { int MSB = ( int ) log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << "" ▁ "" << Y ; } int main ( ) { int N = 45 ; maximizeProduct ( N ) ; return 0 ; }",Find a pair of numbers with set bit count as at most that of N and whose Bitwise XOR is N.,"#include <bits/stdc++.h> 
 using namespace std ; void maximizeProduct ( int N ) { int MSB = ( int ) log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << "" ▁ "" << Y ; } int main ( ) { int N = 45 ; maximizeProduct ( N ) ; return 0 ; }","['void maximizeProduct ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maximizeProduct ( int N ) {
"
478,Convert X into Y by repeatedly multiplying X with 2 or appending 1 at the end | C ++ program for the above approach ; Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end ; Iterate until Y is at least X ; If Y is even ; If the last digit of Y is 1 ; Otherwise ; Check if X is equal to Y ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; return 0 ; }",Convert X into Y by repeatedly multiplying X with 2 or appending 1 at the end.,"#include <bits/stdc++.h> 
 using namespace std ; void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; return 0 ; }","['void convertXintoY ( int X , int Y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void convertXintoY ( int X , int Y ) {
"
479,Lexicographically smallest string of maximum length made up of first K alphabets that does not contain any repeating substring | C ++ program for the above approach ; Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings ; Stores the resultant string ; Iterate through all the characters ; Inner Loop for making pairs and adding them into string ; Adding first character so that substring consisting of the last the first alphabet is present ; Print the resultant string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int K ) { string s = "" "" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + char ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += char ( i ) ; s += char ( j ) ; } } s += char ( 97 ) ; cout << s ; } int main ( ) { int K = 4 ; generateString ( K ) ; return 0 ; }",Lexicographically smallest string of maximum length made up of first K alphabets that does not contain any repeating substring.,"#include <bits/stdc++.h> 
 using namespace std ; void generateString ( int K ) { string s = "" "" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + char ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += char ( i ) ; s += char ( j ) ; } } s += char ( 97 ) ; cout << s ; } int main ( ) { int K = 4 ; generateString ( K ) ; return 0 ; }","['void generateString ( int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void generateString ( int K ) {
"
480,Generate Quadratic Equation having given sum and product of roots | C ++ program for the above approach ; Function to find the quadratic equation from the given sum and products of roots ; Print the coefficients ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int S , int M ) { cout << ""1 ▁ "" << ( -1 ) * S << "" ▁ "" << M << endl ; } int main ( ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; return 0 ; }",Generate Quadratic Equation having given sum and product of roots.,"#include <bits/stdc++.h> 
 using namespace std ; void findEquation ( int S , int M ) { cout << ""1 ▁ "" << ( -1 ) * S << "" ▁ "" << M << endl ; } int main ( ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; return 0 ; }","['void findEquation ( int S , int M ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findEquation ( int S , int M ) {
"
483,Maximize count of sheets possible by repeatedly reducing its area to half | C ++ program for the above approach ; Function to calculate the maximum number of sheets possible by given operations ; Initial count of sheets ; Keep dividing the sheets into half ; Reduce area by half ; Increase count by twice ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } int main ( ) { int A = 5 , B = 10 ; cout << maxSheets ( A , B ) ; return 0 ; }",Maximize count of sheets possible by repeatedly reducing its area to half.,"#include <bits/stdc++.h> 
 using namespace std ; int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } int main ( ) { int A = 5 , B = 10 ; cout << maxSheets ( A , B ) ; return 0 ; }","['int maxSheets ( int A , int B ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxSheets ( int A , int B ) {
"
484,"Minimum number of steps required to reach origin from a given point | C ++ program for the above approach ; Function to find the minimum moves required to reach origin from ( a , b ) ; Stores the minimum number of moves ; Check if the absolute difference is 1 or 0 ; Store the minimum of a , b ; Store the maximum of a , b ; Print the answer ; Driver Code ; Given co - ordinates ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; } int main ( ) { int a = 3 , b = 5 ; findMinMoves ( a , b ) ; return 0 ; }",Minimum number of steps required to reach origin from a given point.,"#include <bits/stdc++.h> 
 using namespace std ; void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; } int main ( ) { int a = 3 , b = 5 ; findMinMoves ( a , b ) ; return 0 ; }","['void findMinMoves ( int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findMinMoves ( int a , int b ) {
"
485,Count even sum pairs possible by selecting two integers from two given ranges respectively | C ++ program to implement the above approach ; Function to count even sum pairs in the given range ; Stores the count of even numbers between 1 to X ; Stores the count of odd numbers between 1 to X ; Stores the count of even numbers between 1 to Y ; Stores the count of odd numbers between 1 to Y ; Stores the count of pairs having even sum ; Retuens the count of pairs having even sum ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long cntEvenSumPairs ( long long X , long long Y ) { long long cntXEvenNums = X / 2 ; long long cntXOddNums = ( X + 1 ) / 2 ; long long cntYEvenNums = Y / 2 ; long long cntYOddNums = ( Y + 1 ) / 2 ; long long cntPairs = ( cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums ) ; return cntPairs ; } int main ( ) { long long X = 2 ; long long Y = 3 ; cout << cntEvenSumPairs ( X , Y ) ; return 0 ; }",Count even sum pairs possible by selecting two integers from two given ranges respectively.,"#include <bits/stdc++.h> 
 using namespace std ; long long cntEvenSumPairs ( long long X , long long Y ) { long long cntXEvenNums = X / 2 ; long long cntXOddNums = ( X + 1 ) / 2 ; long long cntYEvenNums = Y / 2 ; long long cntYOddNums = ( Y + 1 ) / 2 ; long long cntPairs = ( cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums ) ; return cntPairs ; } int main ( ) { long long X = 2 ; long long Y = 3 ; cout << cntEvenSumPairs ( X , Y ) ; return 0 ; }","['long cntEvenSumPairs ( long long X , long long Y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long long cntEvenSumPairs ( long long X , long long Y ) {
"
486,Minimize array elements required to be incremented or decremented to convert given array into a Fibonacci Series | C ++ program for the above approach ; Function to calculate minimum number of moves to make the sequence a Fibonacci series ; If number of elements is less than 3 ; Initialize the value of the result ; Try all permutations of the first two elements ; Value of first element after operation ; Value of second element after operation ; Calculate number of moves for rest of the elements of the array ; Element at idx index ; If it is not possible to change the element in atmost one move ; Otherwise ; Update the answer ; Return the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMoves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { vector < int > arr = { 4 , 8 , 9 , 17 , 27 } ; cout << minMoves ( arr ) << endl ; return 0 ; }",Minimize array elements required to be incremented or decremented to convert given array into a Fibonacci Series.,"#include <bits/stdc++.h> 
 using namespace std ; int minMoves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { vector < int > arr = { 4 , 8 , 9 , 17 , 27 } ; cout << minMoves ( arr ) << endl ; return 0 ; }","['int minMoves ( vector < int > arr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minMoves ( vector < int > arr ) {
"
487,Queries to calculate sum of array elements present at every Yth index starting from the index X | C ++ program for the above approach ; Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries ; Iterate over each query ; Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... ; Traverse the array and calculate the sum of the expression ; Update sum ; Update x ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ 2 ] = { { 2 , 1 } , { 3 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; querySum ( arr , N , Q , M ) ; return 0 ; }",Queries to calculate sum of array elements present at every Yth index starting from the index X.,"#include <bits/stdc++.h> 
 using namespace std ; void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ 2 ] = { { 2 , 1 } , { 3 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; querySum ( arr , N , Q , M ) ; return 0 ; }","['void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) {
"
488,Calculate Bitwise OR of two integers from their given Bitwise AND and Bitwise XOR values | C ++ program to implement the above approach ; Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } int main ( ) { int X = 5 , Y = 2 ; cout << findBitwiseORGivenXORAND ( X , Y ) ; }",Calculate Bitwise OR of two integers from their given Bitwise AND and Bitwise XOR values.,"#include <bits/stdc++.h> 
 using namespace std ; int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } int main ( ) { int X = 5 , Y = 2 ; cout << findBitwiseORGivenXORAND ( X , Y ) ; }","['int findBitwiseORGivenXORAND ( int X , int Y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findBitwiseORGivenXORAND ( int X , int Y ) {
"
490,Count of subarrays having sum equal to its length | Set 2 | C ++ program for the above approach ; Function that counts the subarrays with sum of its elements as its length ; Store count of elements upto current element with length i ; Stores the final count of subarray ; Stores the prefix sum ; If size of subarray is 1 ; Iterate the array ; Find the sum ; Update frequency in map ; Print the total count ; Driver Code ; Given array arr [ ] ; Size of array ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubarray ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , -2 , 2 , 4 } ; int N = sizeof arr / sizeof arr [ 0 ] ; countOfSubarray ( arr , N ) ; return 0 ; }",Count of subarrays having sum equal to its length.,"#include <bits/stdc++.h> 
 using namespace std ; int countOfSubarray ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , -2 , 2 , 4 } ; int N = sizeof arr / sizeof arr [ 0 ] ; countOfSubarray ( arr , N ) ; return 0 ; }","['int countOfSubarray ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countOfSubarray ( int arr [ ] , int N ) {
"
491,Split first N natural numbers into two sets with minimum absolute difference of their sums | C ++ program to implement the above approach ; Function to split the first N natural numbers into two sets having minimum absolute difference of their sums ; Stores the sum of elements of set1 ; Stores the sum of elements of set2 ; Traverse first N natural numbers ; Check if sum of elements of set1 is less than or equal to sum of elements of set2 ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return abs ( sumSet1 - sumSet2 ) ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; },Split first N natural numbers into two sets with minimum absolute difference of their sums.,"#include <bits/stdc++.h> 
 using namespace std ; int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return abs ( sumSet1 - sumSet2 ) ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }","['int minAbsDiff ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minAbsDiff ( int N ) {
"
493,Minimum Cost required to generate a balanced Bracket Sequence | C ++ Program to implement the above approach ; Function to calculate the minimum cost required to generate a balanced bracket sequence ; Stores the count of unbalanced open brackets ; Stores the count of unbalanced closed brackets ; Stores the count of open brackets ; Stores the count of closed brackets ; If open brace is encountered ; Otherwise ; If no unbalanced open brackets are present ; Increase count of unbalanced closed brackets ; Otherwise ; Reduce count of unbalanced open brackets ; Increase count of closed brackets ; Calculate lower bound of minimum cost ; Reduce excess open or closed brackets to prevent counting them twice ; Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of string ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; cout << result << endl ; } int main ( ) { string str = "" ) ) ( ) ( ( ) ( ) ( "" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; return 0 ; }",Minimum Cost required to generate a balanced Bracket Sequence.,"#include <bits/stdc++.h> 
 using namespace std ; void minCost ( string str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; cout << result << endl ; } int main ( ) { string str = "" ) ) ( ) ( ( ) ( ) ( "" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; return 0 ; }","['void minCost ( string str , int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minCost ( string str , int a , int b ) {
"
494,Count of permutations such that sum of K numbers from given range is even | C ++ program for the above approach ; Function to return the number of all permutations such that sum of K numbers in range is even ; Find total count of even and odd number in given range ; Iterate loop k times and update even_sum & odd_sum using previous values ; Update the prev_even and odd_sum ; Even sum ; Odd sum ; Return even_sum ; Driver Code ; Given ranges ; Length of permutation ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << ( even_sum ) ; } int main ( ) { int low = 4 ; int high = 5 ; int K = 3 ; countEvenSum ( low , high , K ) ; }",Count of permutations such that sum of K numbers from given range is even.,"#include <bits/stdc++.h> 
 using namespace std ; int countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << ( even_sum ) ; } int main ( ) { int low = 4 ; int high = 5 ; int K = 3 ; countEvenSum ( low , high , K ) ; }","['int countEvenSum ( int low , int high , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countEvenSum ( int low , int high , int k ) {
"
495,Count of N digit Numbers whose sum of every K consecutive digits is equal | Set 2 | C ++ Program to implement the above approach ; Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal ; Print the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void count ( int n , int k ) { long count = ( long ) ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; cout << ( count ) ; } int main ( ) { int n = 2 , k = 1 ; count ( n , k ) ; }",Count of N digit Numbers whose sum of every K consecutive digits is equal.,"#include <bits/stdc++.h> 
 using namespace std ; void count ( int n , int k ) { long count = ( long ) ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; cout << ( count ) ; } int main ( ) { int n = 2 , k = 1 ; count ( n , k ) ; }","['void count ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void count ( int n , int k ) {
"
497,Count of right shifts for each array element to be in its sorted position | C ++ Program to implement the approach ; Function to find the right shifts required for each element to reach its sorted array position in A [ ] ; Stores required number of shifts for each element ; If the element is at sorted position ; Otherwise ; Calculate right shift ; Print the respective shifts ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findShifts ( int A [ ] , int N ) { int shift [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) cout << shift [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findShifts ( arr , N ) ; return 0 ; }",Count of right shifts for each array element to be in its sorted position.,"#include <bits/stdc++.h> 
 using namespace std ; void findShifts ( int A [ ] , int N ) { int shift [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) cout << shift [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findShifts ( arr , N ) ; return 0 ; }","['void findShifts ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findShifts ( int A [ ] , int N ) {
"
500,Minimum number of points required to cover all blocks of a 2 | C ++ program for the above approach ; Function to find the minimum number of Points required to cover a grid ; If number of block is even ; Return the minimum points ; Driver Code ; Given size of grid ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } int main ( ) { int N = 5 , M = 7 ; cout << minPoints ( N , M ) ; return 0 ; }",Minimum number of points required to cover all blocks of a 2.,"#include <bits/stdc++.h> 
 using namespace std ; int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } int main ( ) { int N = 5 , M = 7 ; cout << minPoints ( N , M ) ; return 0 ; }","['int minPoints ( int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minPoints ( int n , int m ) {
"
502,Minimum operations to make all elements equal using the second array | C ++ implementation to find the minimum operations make all elements equal using the second array ; Function to find the minimum operations required to make all elements of the array equal ; Minimum element of A [ ] ; Traverse through all final values ; Variable indicating whether all elements can be converted to x or not ; Total operations ; Traverse through all array elements ; All elements can 't  be converted to x ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = * min_element ( a , a + n ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = 1 ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = 0 ; break ; } } if ( check ) return operations ; } return -1 ; } int main ( ) { int N = 5 ; int A [ N ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ N ] = { 2 , 2 , 1 , 3 , 5 } ; cout << minOperations ( A , B , N ) ; return 0 ; }",Minimum operations to make all elements equal using the second array.,"#include <bits/stdc++.h> 
 using namespace std ; int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = * min_element ( a , a + n ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = 1 ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = 0 ; break ; } } if ( check ) return operations ; } return -1 ; } int main ( ) { int N = 5 ; int A [ N ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ N ] = { 2 , 2 , 1 , 3 , 5 } ; cout << minOperations ( A , B , N ) ; return 0 ; }","['int minOperations ( int a [ ] , int b [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minOperations ( int a [ ] , int b [ ] , int n ) {
"
503,Find the maximum sum ( a + b ) for a given input integer N satisfying the given condition | C ++ implementation to find the largest value of a + b satisfying the given condition ; Function to return the maximum sum of a + b satisfying the given condition ; Initialize max_sum ; Consider all the possible pairs ; Check if the product is divisible by the sum ; Storing the maximum sum in the max_sum variable ; Return the max_sum value ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = max ( max_sum , i + j ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }",Find the maximum sum ( a + b ) for a given input integer N satisfying the given condition.,"#include <bits/stdc++.h> 
 using namespace std ; int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = max ( max_sum , i + j ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }","['int getLargestSum ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getLargestSum ( int N ) {
"
507,Find the subsequence with given sum in a superincreasing sequence | C ++ implementation of the approach ; Function to find the required subsequence ; Current element cannot be a part of the required subsequence ; Include current element in the required subsequence So update the sum ; Print the elements of the required subsequence ; If the current element was included in the subsequence ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = -1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != -1 ) cout << arr [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; return 0 ; }",Find the subsequence with given sum in a superincreasing sequence.,"#include <bits/stdc++.h> 
 using namespace std ; void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = -1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != -1 ) cout << arr [ i ] << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; return 0 ; }","['void findSubSeq ( int arr [ ] , int n , int sum ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findSubSeq ( int arr [ ] , int n , int sum ) {
"
508,Find the most valued alphabet in the String | C ++ implementation of the approach ; Function to return the maximum valued alphabet ; To store the first and the last occurrence of all the characters ; Set the first and the last occurrence of all the characters to - 1 ; Update the occurrences of the characters ; Only set the first occurrence if it hasn 't already been set ; To store the result ; For every alphabet ; If current alphabet doesn 't appear  in the given string ; If the current character has the highest value so far ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; char maxAlpha ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int ans = -1 , maxVal = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } int main ( ) { string str = "" abbba "" ; int len = str . length ( ) ; cout << maxAlpha ( str , len ) ; return 0 ; }",Find the most valued alphabet in the String.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX = 26 ; char maxAlpha ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int ans = -1 , maxVal = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } int main ( ) { string str = "" abbba "" ; int len = str . length ( ) ; cout << maxAlpha ( str , len ) ; return 0 ; }","['char maxAlpha ( string str , int len ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX = 26 ;
 char maxAlpha ( string str , int len ) {
"
509,Queries for number of distinct elements from a given index till last index in an array | C ++ implementation of the approach ; Function to perform queries to find number of distinct elements from a given index till last index in an array ; Check if current element already visited or not ; If not visited store current counter and increment it and mark check as 1 ; Otherwise if visited simply store current counter ; Perform queries ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int check [ MAX ] = { 0 } ; int idx [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; cout << idx [ m ] << "" ▁ "" ; } } int main ( ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = sizeof ( queries ) / sizeof ( int ) ; find_distinct ( a , n , q , queries ) ; return 0 ; }",Queries for number of distinct elements from a given index till last index in an array.,"#include <bits/stdc++.h> 
 using namespace std ; #define MAX  100001 
 void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int check [ MAX ] = { 0 } ; int idx [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; cout << idx [ m ] << "" ▁ "" ; } } int main ( ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = sizeof ( queries ) / sizeof ( int ) ; find_distinct ( a , n , q , queries ) ; return 0 ; }","['void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define MAX  100001 
 void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) {
"
510,Convert given integer X to the form 2 ^ N | C ++ implementation of the approach ; Function to return the count of operations required ; To store the powers of 2 ; Temporary variable to store x ; To store the index of smaller number larger than x ; To store the count of operations ; Stores the index of number in the form of 2 ^ n - 1 ; If x is already in the form 2 ^ n - 1 then no operation is required ; If number is less than x increase the index ; Calculate all the values ( x xor 2 ^ n - 1 ) for all possible n ; Only take value which is closer to the number ; If number is in the form of 2 ^ n - 1 then break ; Return the count of operations required to obtain the number ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 24 ; int countOp ( int x ) { int arr [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } int main ( ) { int x = 39 ; cout << countOp ( x ) ; return 0 ; },Convert given integer X to the form 2 ^ N.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX = 24 ; int countOp ( int x ) { int arr [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } int main ( ) { int x = 39 ; cout << countOp ( x ) ; return 0 ; }","['int countOp ( int x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX = 24 ;
 int countOp ( int x ) {
"
511,Minimum number of given operations required to reduce the array to 0 element | C ++ implementation of the approach ; Function to return the minimum operations required ; Count the frequency of each element ; Maximum element from the array ; Find all the multiples of i ; Delete the multiples ; Increment the operations ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int * arr , int n ) { int maxi , result = 0 ; vector < int > freq ( 1000001 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = * ( max_element ( arr , arr + n ) ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }",Minimum number of given operations required to reduce the array to 0 element.,"#include <bits/stdc++.h> 
 using namespace std ; int minOperations ( int * arr , int n ) { int maxi , result = 0 ; vector < int > freq ( 1000001 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = * ( max_element ( arr , arr + n ) ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }","['int minOperations ( int * arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minOperations ( int * arr , int n ) {
"
514,"Minimum number of adjacent swaps for arranging similar elements together | C ++ Program to find the minimum number of adjacent swaps to arrange similar items together ; Function to find minimum swaps ; visited array to check if value is seen already ; If the arr [ i ] is seen first time ; stores the number of swaps required to find the correct position of current element 's partner ; Increment count only if the current element has not been visited yet ( if is visited , means it has already been placed at its correct position ) ; If current element 's partner is found ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimumSwaps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; N /= 2 ; cout << findMinimumAdjacentSwaps ( arr , N ) << endl ; return 0 ; }",Minimum number of adjacent swaps for arranging similar elements together.,"#include <bits/stdc++.h> 
 using namespace std ; int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimumSwaps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; N /= 2 ; cout << findMinimumAdjacentSwaps ( arr , N ) << endl ; return 0 ; }","['int findMinimumAdjacentSwaps ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMinimumAdjacentSwaps ( int arr [ ] , int N ) {
"
516,Minimum Swaps for Bracket Balancing | C ++ program to count swaps required to balance string ; Function to calculate swaps required ; Keep track of ' [ ' ; To count number of encountered ' [ ' ; To track position of next ' [ ' in pos ; To store result ; Increment count and move p to next position ; We have encountered an unbalanced part of string ; Increment sum by number of swaps required i . e . position of next ' [ ' - current position ; Reset count to 1 ; Driver code,"#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; long swapCount ( string s ) { vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s [ i ] == ' [ ' ) pos . push_back ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( s [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos [ p ] - i ; swap ( s [ i ] , s [ pos [ p ] ] ) ; ++ p ; count = 1 ; } } return sum ; } int main ( ) { string s = "" [ ] ] [ ] [ "" ; cout << swapCount ( s ) << "" STRNEWLINE "" ; s = "" [ [ ] [ ] ] "" ; cout << swapCount ( s ) << "" STRNEWLINE "" ; return 0 ; }",Minimum Swaps for Bracket Balancing.,"#include <iostream> 
 #include <vector> 
 #include <algorithm> 
 using namespace std ; long swapCount ( string s ) { vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s [ i ] == ' [ ' ) pos . push_back ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( s [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos [ p ] - i ; swap ( s [ i ] , s [ pos [ p ] ] ) ; ++ p ; count = 1 ; } } return sum ; } int main ( ) { string s = "" [ ] ] [ ] [ "" ; cout << swapCount ( s ) << "" STRNEWLINE "" ; s = "" [ [ ] [ ] ] "" ; cout << swapCount ( s ) << "" STRNEWLINE "" ; return 0 ; }","['long swapCount ( string s ) {', 'int main ( ) {']","#include <iostream> 
 #include <vector> 
 #include <algorithm> 
 using namespace std ;
 long swapCount ( string s ) {
"
517,"Minimum Cost to cut a board into squares | C ++ program to divide a board into m * n squares ; method returns minimum cost to break board into m * n squares ; sort the horizontal cost in reverse order ; sort the vertical cost in reverse order ; initialize current width as 1 ; loop until one or both cost array are processed ; increase current horizontal part count by 1 ; increase current vertical part count by 1 ; loop for horizontal array , if remains ; loop for vertical array , if remains ; Driver code to test above methods","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } int main ( ) { int m = 6 , n = 4 ; int X [ m - 1 ] = { 2 , 1 , 3 , 1 , 4 } ; int Y [ n - 1 ] = { 4 , 1 , 2 } ; cout << minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ; return 0 ; }",Minimum Cost to cut a board into squares.,"#include <bits/stdc++.h> 
 using namespace std ; int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } int main ( ) { int m = 6 , n = 4 ; int X [ m - 1 ] = { 2 , 1 , 3 , 1 , 4 } ; int Y [ n - 1 ] = { 4 , 1 , 2 } ; cout << minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ; return 0 ; }","['int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) {
"
519,"Minimize operations to reduce N to 2 by repeatedly reducing by 3 or dividing by 5 | C ++ program for the above approach ; Function to find the minimum number of operations to reduce N to 2 by dividing N by 5 or decrementing by 3 ; Initialize the dp array ; Initialize the array dp [ ] ; For N = 2 number of operations needed is zero ; Iterating over the range [ 1 , N ] ; If it 's not possible to  create current N ; Multiply with 5 ; Adding the value 3 ; Checking if not possible to make the number as 2 ; Return the minimum number of operations ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperations ( int N ) { int dp [ N + 1 ] ; int i ; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return -1 ; return dp [ N ] ; } int main ( ) { int N = 25 ; cout << minimumOperations ( N ) ; return 0 ; }",Minimize operations to reduce N to 2 by repeatedly reducing by 3 or dividing by 5.,"#include <bits/stdc++.h> 
 using namespace std ; int minimumOperations ( int N ) { int dp [ N + 1 ] ; int i ; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return -1 ; return dp [ N ] ; } int main ( ) { int N = 25 ; cout << minimumOperations ( N ) ; return 0 ; }","['int minimumOperations ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minimumOperations ( int N ) {
"
520,Maximum profit after buying and selling the stocks with transaction fees | Set 2 | C ++ program for the above approach ; Function to find the maximum profit with transaction fee ; Traversing the stocks for each day ; Update buy and sell ; Return the maximum profit ; Driver code ; Given Input ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = max ( buy , sell - arr [ i ] ) ; sell = max ( sell , temp + arr [ i ] - transactionFee ) ; } return max ( sell , buy ) ; } int main ( ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int transactionFee = 2 ; cout << MaxProfit ( arr , n , transactionFee ) ; return 0 ; }",Maximum profit after buying and selling the stocks with transaction fees.,"#include <bits/stdc++.h> 
 using namespace std ; int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = max ( buy , sell - arr [ i ] ) ; sell = max ( sell , temp + arr [ i ] - transactionFee ) ; } return max ( sell , buy ) ; } int main ( ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int transactionFee = 2 ; cout << MaxProfit ( arr , n , transactionFee ) ; return 0 ; }","['int MaxProfit ( int arr [ ] , int n , int transactionFee ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MaxProfit ( int arr [ ] , int n , int transactionFee ) {
"
522,"Length of longest subset consisting of A 0 s and B 1 s from an array of strings | Set 2 | C ++ program for the above approach ; Function to find the length of the longest subset of an array of strings with at most A 0 s and B 1 s ; Initialize a 2D array with its entries as 0 ; Traverse the given array ; Store the count of 0 s and 1 s in the current string ; Iterate in the range [ A , zeros ] ; Iterate in the range [ B , ones ] ; Update the value of dp [ i ] [ j ] ; Print the result ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxSubsetlength ( vector < string > arr , int A , int B ) { int dp [ A + 1 ] [ B + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( auto & str : arr ) { int zeros = count ( str . begin ( ) , str . end ( ) , '0' ) ; int ones = count ( str . begin ( ) , str . end ( ) , '1' ) ; for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; } int main ( ) { vector < string > arr = { ""1"" , ""0"" , ""0001"" , ""10"" , ""111001"" } ; int A = 5 , B = 3 ; cout << MaxSubsetlength ( arr , A , B ) ; return 0 ; }",Length of longest subset consisting of A 0 s and B 1 s from an array of strings.,"#include <bits/stdc++.h> 
 using namespace std ; int MaxSubsetlength ( vector < string > arr , int A , int B ) { int dp [ A + 1 ] [ B + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( auto & str : arr ) { int zeros = count ( str . begin ( ) , str . end ( ) , '0' ) ; int ones = count ( str . begin ( ) , str . end ( ) , '1' ) ; for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; } int main ( ) { vector < string > arr = { ""1"" , ""0"" , ""0001"" , ""10"" , ""111001"" } ; int A = 5 , B = 3 ; cout << MaxSubsetlength ( arr , A , B ) ; return 0 ; }","['int MaxSubsetlength ( vector < string > arr , int A , int B ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MaxSubsetlength ( vector < string > arr , int A , int B ) {
"
523,"Count ways to select N pairs of candies of distinct colors ( Dynamic Programming + Bitmasking ) | C ++ 14 program to implement the above approach ; Function to count ways to select N distinct pairs of candies with different colours ; If n pairs are selected ; Stores count of ways to select the i - th pair ; Iterate over the range [ 0 , n ] ; If pair ( i , j ) is not included ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && blue . find ( j ) == blue . end ( ) ) { blue . insert ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . erase ( j ) ; } } return count ; } int main ( ) { int n = 3 ; vector < vector < int > > mat = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; set < int > mpp ; cout << ( numOfWays ( mat , n , 0 , mpp ) ) ; }",Count ways to select N pairs of candies of distinct colors ( Dynamic Programming + Bitmasking ).,"#include <bits/stdc++.h> 
 using namespace std ; int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && blue . find ( j ) == blue . end ( ) ) { blue . insert ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . erase ( j ) ; } } return count ; } int main ( ) { int n = 3 ; vector < vector < int > > mat = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; set < int > mpp ; cout << ( numOfWays ( mat , n , 0 , mpp ) ) ; }","['int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) {
"
524,"Minimize cost to reach end of an array by two forward jumps or one backward jump in each move | C ++ program for the above approach ; Function to find the minimum cost to reach the end of an array ; Base Case : When N < 3 ; Store the results in table ; Initialize base cases ; Iterate over the range [ 2 , N - 2 ] to construct the dp array ; Handle case for the last index , i . e . N - 1 ; Print the answer ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int * dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; } int main ( ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minCost ( arr , N ) ; return 0 ; }",Minimize cost to reach end of an array by two forward jumps or one backward jump in each move.,"#include <bits/stdc++.h> 
 using namespace std ; void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int * dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; } int main ( ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minCost ( arr , N ) ; return 0 ; }","['void minCost ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minCost ( int arr [ ] , int n ) {
"
527,Count ways to obtain given sum by repeated throws of a dice | C ++ program for the above approach ; Function to find the number of ways to get the sum N with throw of dice ; Base Case ; Stores the count of total number of ways to get sum N ; Recur for all 6 states ; Return answer ; Driver Code ; Function call,#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } int main ( ) { int N = 4 ; cout << findWays ( N ) ; return 0 ; },Count ways to obtain given sum by repeated throws of a dice.,"#include <bits/stdc++.h> 
 using namespace std ; int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } int main ( ) { int N = 4 ; cout << findWays ( N ) ; return 0 ; }","['int findWays ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findWays ( int N ) {
"
531,Count number of ways to convert string S to T by performing K cyclic shifts | C ++ program for the above approach ; Function to count number of ways to convert string S to string T by performing K cyclic shifts ; Calculate length of string ; ' a ' is no of good cyclic shifts ' b ' is no of bad cyclic shifts ; Iterate in the string ; Precompute the number of good and bad cyclic shifts ; dp2 [ i ] to store the no of ways to get to a bad shift in i moves ; Calculate good and bad shifts ; Return the required number of ways ; Driver Code ; Given Strings ; Given K shifts required ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  10000000007 NEW_LINE long long countWays ( string s , string t , int k ) { int n = s . size ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } vector < long long > dp1 ( k + 1 ) , dp2 ( k + 1 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } int main ( ) { string S = "" ab "" , T = "" ab "" ; int K = 2 ; cout << countWays ( S , T , K ) ; return 0 ; }",Count number of ways to convert string S to T by performing K cyclic shifts.,"#include <bits/stdc++.h> 
 using namespace std ; #define mod  10000000007 
 long long countWays ( string s , string t , int k ) { int n = s . size ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } vector < long long > dp1 ( k + 1 ) , dp2 ( k + 1 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } int main ( ) { string S = "" ab "" , T = "" ab "" ; int K = 2 ; cout << countWays ( S , T , K ) ; return 0 ; }","['long countWays ( string s , string t , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define mod  10000000007 
 long long countWays ( string s , string t , int k ) {
"
532,Minimize steps to reach K from 0 by adding 1 or doubling at each step | C ++ program to implement the above approach ; Function to find minimum operations ; vector dp is initialised to store the steps ; For all even numbers ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( int k ) { vector < int > dp ( k + 1 , 0 ) ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } int main ( ) { int K = 12 ; cout << minOperation ( k ) ; }",Minimize steps to reach K from 0 by adding 1 or doubling at each step.,"#include <bits/stdc++.h> 
 using namespace std ; int minOperation ( int k ) { vector < int > dp ( k + 1 , 0 ) ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } int main ( ) { int K = 12 ; cout << minOperation ( k ) ; }","['int minOperation ( int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minOperation ( int k ) {
"
533,Find maximum subset sum formed by partitioning any subset of array into 2 partitions with equal sum | CPP implementation for the above mentioned recursive approach ; Function to find the maximum subset sum ; Ignore the current element ; including element in partition 1 ; including element in partition 2 ; Driver code ; size of the array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( 0 , 0 , a , 0 , n ) ; return 0 ; }",Find maximum subset sum formed by partitioning any subset of array into 2 partitions with equal sum.,"#include <bits/stdc++.h> 
 using namespace std ; int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( 0 , 0 , a , 0 , n ) ; return 0 ; }","['int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) {
"
534,"Find maximum subset sum formed by partitioning any subset of array into 2 partitions with equal sum | CPP implementation for the above mentioned Dynamic Programming approach ; Function to find the maximum subset sum ; sum of all elements ; bottom up lookup table ; ; initialising dp table with INT_MIN where , INT_MIN means no solution ; Case when diff is 0 ; Putting ith element in g0 ; Putting ith element in g1 ; Ignoring ith element ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int dp [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( a , n ) ; return 0 ; }",Find maximum subset sum formed by partitioning any subset of array into 2 partitions with equal sum.,"#include <bits/stdc++.h> 
 using namespace std ; int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int dp [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( a , n ) ; return 0 ; }","['int maxSum ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxSum ( int a [ ] , int n ) {
"
536,"Golomb Sequence | Set 2 | C ++ program to find the first N terms of Golomb Sequence ; Function to print the Golomb Sequence ; Initialise the array ; Initialise the cnt to 0 ; First and second element of Golomb Sequence is 0 , 1 ; Map to store the count of current element in Golomb Sequence ; Store the count of 2 ; Iterate over 2 to N ; If cnt is equals to 0 then we have new number for Golomb Sequence which is 1 + previous element ; Else the current element is the previous element in this Sequence ; Map the current index to current value in arr [ ] ; Print the Golomb Sequence ; Driver Code","#include "" bits / stdc + + . h "" NEW_LINE #define MAX  100001 NEW_LINE using namespace std ; void printGolombSequence ( int N ) { int arr [ MAX ] ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; map < int , int > M ; M [ 2 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M [ i ] = arr [ i ] ; } for ( int i = 1 ; i <= N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } int main ( ) { int N = 11 ; printGolombSequence ( N ) ; return 0 ; }",Golomb Sequence.,"#include "" bits / stdc + + . h "" 
 #define MAX  100001 
 using namespace std ; void printGolombSequence ( int N ) { int arr [ MAX ] ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; map < int , int > M ; M [ 2 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M [ i ] = arr [ i ] ; } for ( int i = 1 ; i <= N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } int main ( ) { int N = 11 ; printGolombSequence ( N ) ; return 0 ; }","['void printGolombSequence ( int N ) {', 'int main ( ) {']","#include "" bits / stdc + + . h "" 
 #define MAX  100001 
 using namespace std ;
 void printGolombSequence ( int N ) {
"
537,"Count ways to reach Nth Stairs by taking 1 and 2 steps with exactly one 3 step | C ++ implementation to find the number the number of ways to reach Nth stair by taking 1 , 2 step at a time and 3 Steps at a time exactly once . ; Function to find the number the number of ways to reach Nth stair ; Array including number of ways that includes 3 ; Array including number of ways that doesn 't includes 3 ; Initially to reach 3 stairs by taking 3 steps can be reached by 1 way ; Loop to find the number the number of ways to reach Nth stair ; Driver Code",#include <iostream> NEW_LINE using namespace std ; int number_of_ways ( int n ) { int includes_3 [ n + 1 ] = { } ; int not_includes_3 [ n + 1 ] = { } ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } int main ( ) { int n = 7 ; cout << number_of_ways ( n ) ; return 0 ; },Count ways to reach Nth Stairs by taking 1 and 2 steps with exactly one 3 step.,"#include <iostream> 
 using namespace std ; int number_of_ways ( int n ) { int includes_3 [ n + 1 ] = { } ; int not_includes_3 [ n + 1 ] = { } ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } int main ( ) { int n = 7 ; cout << number_of_ways ( n ) ; return 0 ; }","['int number_of_ways ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int number_of_ways ( int n ) {
"
539,Number of ways to reach the end of matrix with non | C ++ implementation of the approach ; 3d array to store states of dp ; Array to determine whether a state has been solved before ; Function to return the count of required paths ; Base cases ; If a state has been solved before it won 't be evaluated again ; Recurrence relation ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE #define maxV  20 NEW_LINE using namespace std ; int dp [ n ] [ n ] [ maxV ] ; int v [ n ] [ n ] [ maxV ] ; int countWays ( int i , int j , int x , int arr [ ] [ n ] ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; cout << countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ; return 0 ; }",Number of ways to reach the end of matrix with non.,"#include <bits/stdc++.h> 
 #define n  3 
 #define maxV  20 
 using namespace std ; int dp [ n ] [ n ] [ maxV ] ; int v [ n ] [ n ] [ maxV ] ; int countWays ( int i , int j , int x , int arr [ ] [ n ] ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; cout << countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ; return 0 ; }","['int countWays ( int i , int j , int x , int arr [ ] [ n ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define n  3 
 #define maxV  20 
 using namespace std ;
 int dp [ n ] [ n ] [ maxV ] ;
 int v [ n ] [ n ] [ maxV ] ;
 int countWays ( int i , int j , int x , int arr [ ] [ n ] ) {
"
541,Number of ways to make binary string of length N such that 0 s always occur together in groups of size K | C ++ implementation of the above approach ; Function to return no of ways to build a binary string of length N such that 0 s always occur in groups of size K ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int noOfBinaryStrings ( int N , int k ) { int dp [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } int main ( ) { int N = 4 ; int K = 2 ; cout << noOfBinaryStrings ( N , K ) ; return 0 ; }",Number of ways to make binary string of length N such that 0 s always occur together in groups of size K.,"#include <bits/stdc++.h> 
 using namespace std ; const int mod = 1000000007 ; int noOfBinaryStrings ( int N , int k ) { int dp [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } int main ( ) { int N = 4 ; int K = 2 ; cout << noOfBinaryStrings ( N , K ) ; return 0 ; }","['int noOfBinaryStrings ( int N , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int mod = 1000000007 ;
 int noOfBinaryStrings ( int N , int k ) {
"
542,Number of ways to pair people | CPP program to find number of ways to pair people in party ; Function to find number of ways to pair people in party ; To store count of number of ways . ; Using the recurrence defined find count for different values of p . ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWaysToPair ( int p ) { int dp [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } int main ( ) { int p = 3 ; cout << findWaysToPair ( p ) ; return 0 ; },Number of ways to pair people.,"#include <bits/stdc++.h> 
 using namespace std ; int findWaysToPair ( int p ) { int dp [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } int main ( ) { int p = 3 ; cout << findWaysToPair ( p ) ; return 0 ; }","['int findWaysToPair ( int p ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findWaysToPair ( int p ) {
"
543,Count ways to reach a score using 1 and 2 with no consecutive 2 s | A simple recursive implementation for counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; base cases ; For cases n > 2 ; Driver code,#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } int main ( ) { int n = 10 ; cout << CountWays ( n ) ; return 0 ; },Count ways to reach a score using 1 and 2 with no consecutive 2 s.,"#include <iostream> 
 using namespace std ; int CountWays ( int n ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } int main ( ) { int n = 10 ; cout << CountWays ( n ) ; return 0 ; }","['int CountWays ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int CountWays ( int n ) {
"
545,Maximum subarray sum in an array created after repeated concatenation | C ++ program to print largest contiguous array sum when array is created after concatenating a small array k times . ; Returns sum of maximum sum subarray created after concatenating a [ 0. . n - 1 ] k times . ; This is where it differs from Kadane 's  algorithm. We use modular arithmetic to  find next element. ; Driver program to test maxSubArraySum,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int main ( ) { int a [ ] = { 10 , 20 , -30 , -1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << "" Maximum ▁ contiguous ▁ sum ▁ is ▁ "" << maxSubArraySumRepeated ( a , n , k ) ; return 0 ; }",Maximum subarray sum in an array created after repeated concatenation.,"#include <bits/stdc++.h> 
 using namespace std ; int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int main ( ) { int a [ ] = { 10 , 20 , -30 , -1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << "" Maximum ▁ contiguous ▁ sum ▁ is ▁ "" << maxSubArraySumRepeated ( a , n , k ) ; return 0 ; }","['int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {
"
546,Longest Increasing Odd Even Subsequence | C ++ implementation to find the longest increasing odd even subsequence ; function to find the longest increasing odd even subsequence ; lioes [ i ] stores longest increasing odd even subsequence ending at arr [ i ] ; to store the length of longest increasing odd even subsequence ; Initialize LIOES values for all indexes ; Compute optimized LIOES values in bottom up manner ; Pick maximum of all LIOES values ; required maximum length ; Driver program to test above,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } int main ( ) { int arr [ ] = { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = sizeof ( arr ) / sizeof ( n ) ; cout << "" Longest ▁ Increasing ▁ Odd ▁ Even ▁ "" << "" Subsequence : ▁ "" << longOddEvenIncSeq ( arr , n ) ; return 0 ; }",Longest Increasing Odd Even Subsequence.,"#include <bits/stdc++.h> 
 using namespace std ; int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } int main ( ) { int arr [ ] = { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = sizeof ( arr ) / sizeof ( n ) ; cout << "" Longest ▁ Increasing ▁ Odd ▁ Even ▁ "" << "" Subsequence : ▁ "" << longOddEvenIncSeq ( arr , n ) ; return 0 ; }","['int longOddEvenIncSeq ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int longOddEvenIncSeq ( int arr [ ] , int n ) {
"
548,"Matrix Chain Multiplication | DP | A naive recursive implementation that simply follows the above optimal substructure property ; Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n ; place parenthesis at different places between first and last matrix , recursively calculate count of multiplications for each parenthesis placement and return the minimum count ; Return minimum count ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ "" << MatrixChainOrder ( arr , 1 , n - 1 ) ; }",Matrix Chain Multiplication.,"#include <bits/stdc++.h> 
 using namespace std ; int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ "" << MatrixChainOrder ( arr , 1 , n - 1 ) ; }","['int MatrixChainOrder ( int p [ ] , int i , int j ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MatrixChainOrder ( int p [ ] , int i , int j ) {
"
550,Numbers formed by flipping common set bits in two given integers | C ++ program to implement the above approach ; Function to flip bits of A and B which are set in both of them ; Clear the bits of A which are set in both A and B ; Clear the bits of B which are set in both A and B ; Print updated A and B ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << "" ▁ "" << B ; } int main ( ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; return 0 ; }",Numbers formed by flipping common set bits in two given integers.,"#include <bits/stdc++.h> 
 using namespace std ; void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << "" ▁ "" << B ; } int main ( ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; return 0 ; }","['void flipBitsOfAandB ( int A , int B ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void flipBitsOfAandB ( int A , int B ) {
"
551,Sum of Hamming difference of consecutive numbers from 0 to N | Set 2 | C ++ Program to implement the above approach ; Function to calculate and return the hamming distance between all consecutive numbers from 0 to N ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } int main ( ) { int N = 9 ; cout << TotalHammingDistance ( N ) ; return 0 ; }",Sum of Hamming difference of consecutive numbers from 0 to N.,"#include <bits/stdc++.h> 
 using namespace std ; int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } int main ( ) { int N = 9 ; cout << TotalHammingDistance ( N ) ; return 0 ; }","['int TotalHammingDistance ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int TotalHammingDistance ( int n ) {
"
552,Sum of all divisors from 1 to N | Set 3 | C ++ Program to implement the above approach ; Function to find the sum of all divisors of all numbers from 1 to N ; Stores the sum ; Marks the last point of occurence with same count ; Calculate the sum ; Return the result ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE #define m  1000000007 NEW_LINE void solve ( long long n ) { long long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = n / floor ( n / l ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } cout << ( s + m ) % m ; } signed main ( ) { long long n = 12 ; solve ( n ) ; return 0 ; },Sum of all divisors from 1 to N.,"#include <bits/stdc++.h> 
 using namespace std ; #define int  long long int 
 #define m  1000000007 
 void solve ( long long n ) { long long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = n / floor ( n / l ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } cout << ( s + m ) % m ; } signed main ( ) { long long n = 12 ; solve ( n ) ; return 0 ; }","['void solve ( long long n ) {', 'signed main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define int  long long int 
 #define m  1000000007 
 void solve ( long long n ) {
"
553,Minimize number of cuts required to break N length stick into N unit length sticks | C ++ program to find minimum time required to split a stick of N length into unit pieces ; Function to return the minimum time required to split stick of N into length into unit pieces ; Return the minimum unit of time required ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ceil ( log2 ( N ) ) ; } int main ( ) { int N = 100 ; cout << min_time_to_cut ( N ) ; return 0 ; },Minimize number of cuts required to break N length stick into N unit length sticks.,"#include <bits/stdc++.h> 
 using namespace std ; int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ceil ( log2 ( N ) ) ; } int main ( ) { int N = 100 ; cout << min_time_to_cut ( N ) ; return 0 ; }","['int min_time_to_cut ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int min_time_to_cut ( int N ) {
"
554,Count of distinct pair sum between two 1 to N value Arrays | C ++ implementation to count of distinct pair sum between two Array with values 1 to N ; Function to find the distinct sums ; Set to store distinct sums ; Inserting every sum ; returning distinct sums ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int n ) { set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . insert ( i + j ) ; } } return s . size ( ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; },Count of distinct pair sum between two 1 to N value Arrays.,"#include <bits/stdc++.h> 
 using namespace std ; int findDistinctSums ( int n ) { set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . insert ( i + j ) ; } } return s . size ( ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }","['int findDistinctSums ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findDistinctSums ( int n ) {
"
555,Print Triangle separated pattern | C ++ program to print the triangle separated pattern using star and slash character ; Function to print pattern recursively ; Base Case ; Conditions to print slash ; Condition to print forword slash ; Condition to print backward slash ; Else print ' * ' ; Recursive call for rows ; Recursive call for changing the rows ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { cout << "" / "" ; } else { cout << "" \ \"" ; } } else { cout << "" * "" ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } cout << endl ; return printPattern ( i + 1 , 0 , n ) ; } int main ( ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; return 0 ; }",Print Triangle separated pattern.,"#include <bits/stdc++.h> 
 using namespace std ; int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { cout << "" / "" ; } else { cout << "" \ \"" ; } } else { cout << "" * "" ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } cout << endl ; return printPattern ( i + 1 , 0 , n ) ; } int main ( ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; return 0 ; }","['int printPattern ( int i , int j , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int printPattern ( int i , int j , int n ) {
"
556,Find starting index for every occurrence of given array B in array A using Z | CPP implementation for pattern searching in an array using Z - Algorithm ; Function to calculate Z - Array ; Loop to calculate Z - Array ; Outside the Z - box ; Inside Z - box ; Helper function to merge two arrays and create a single array ; Array to store merged array ; Copying array B ; Adding a separator ; Copying array A ; Calling Z - function ; Function to help compute the Z array ; Printing indexes where array B occur ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > zArray ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > z ( n ) ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } vector < int > mergeArray ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; int m = B . size ( ) ; vector < int > z ; vector < int > c ( n + m + 1 ) ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } void findZArray ( vector < int > A , vector < int > B , int n ) { int flag = 0 ; vector < int > z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . size ( ) ; i ++ ) { if ( z [ i ] == n ) { cout << ( i - n - 1 ) << "" ▁ "" ; flag = 1 ; } } if ( flag == 0 ) { cout << ( "" Not ▁ Found "" ) ; } } int main ( ) { vector < int > A { 1 , 2 , 3 , 2 , 3 , 2 } ; vector < int > B { 2 , 3 } ; int n = B . size ( ) ; findZArray ( A , B , n ) ; }",Find starting index for every occurrence of given array B in array A using Z.,"#include <bits/stdc++.h> 
 using namespace std ; vector < int > zArray ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > z ( n ) ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } vector < int > mergeArray ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; int m = B . size ( ) ; vector < int > z ; vector < int > c ( n + m + 1 ) ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } void findZArray ( vector < int > A , vector < int > B , int n ) { int flag = 0 ; vector < int > z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . size ( ) ; i ++ ) { if ( z [ i ] == n ) { cout << ( i - n - 1 ) << "" ▁ "" ; flag = 1 ; } } if ( flag == 0 ) { cout << ( "" Not ▁ Found "" ) ; } } int main ( ) { vector < int > A { 1 , 2 , 3 , 2 , 3 , 2 } ; vector < int > B { 2 , 3 } ; int n = B . size ( ) ; findZArray ( A , B , n ) ; }","['void findZArray ( vector < int > A , vector < int > B , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 vector < int > zArray ( vector < int > arr ) {
 int n = arr . size ( ) ;
 vector < int > z ( n ) ;
 int r = 0 , l = 0 ;
 for ( int k = 1 ;
 k < n ;
 k ++ ) {
 if ( k > r ) {
 r = l = k ;
 while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ;
 z [ k ] = r - l ;
 r -- ;
 } else {
 int k1 = k - l ;
 if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ;
 else {
 l = k ;
 while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ;
 z [ k ] = r - l ;
 r -- ;
 } } } return z ;
 } vector < int > mergeArray ( vector < int > A , vector < int > B ) {
 int n = A . size ( ) ;
 int m = B . size ( ) ;
 vector < int > z ;
 vector < int > c ( n + m + 1 ) ;
 for ( int i = 0 ;
 i < m ;
 i ++ ) c [ i ] = B [ i ] ;
 c [ m ] = INT_MAX ;
 for ( int i = 0 ;
 i < n ;
 i ++ ) c [ m + i + 1 ] = A [ i ] ;
 z = zArray ( c ) ;
 return z ;
 } void findZArray ( vector < int > A , vector < int > B , int n ) {
"
557,Check if a string can be repeated to make another string | CPP implementation of the approach ; Function to return the count of repetitions of string a to generate string b ; If b cannot be generated by repeating a ; Repeat a count number of times ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = "" "" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == b ) return count ; return -1 ; } int main ( ) { string a = "" geeks "" ; string b = "" geeksgeeks "" ; cout << ( getCount ( a , b ) ) ; return 0 ; }",Check if a string can be repeated to make another string.,"#include <bits/stdc++.h> 
 using namespace std ; int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = "" "" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == b ) return count ; return -1 ; } int main ( ) { string a = "" geeks "" ; string b = "" geeksgeeks "" ; cout << ( getCount ( a , b ) ) ; return 0 ; }","['int getCount ( string a , string b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getCount ( string a , string b ) {
"
559,"Count of occurrences of a ""1(0 + ) 1"" pattern in a string | C ++ program to calculate number of times the pattern occurred in given string ; Returns count of occurrences of ""1(0 + ) 1"" int str . ; int count = 0 ; Initialize result ; Check if encountered '1' forms a valid pattern as specified ; if 1 encountered for first time set oneSeen to 1 ; Check if there is any other character other than '0' or '1' . If so then set oneSeen to 0 to search again for new pattern ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; int countPattern ( string str ) { int len = str . size ( ) ; bool oneSeen = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0 ; } return count ; } int main ( ) { string str = ""100001abc101"" ; cout << countPattern ( str ) ; return 0 ; }","Count of occurrences of a ""1(0 + ) 1"" pattern in a string.","#include <iostream> 
 using namespace std ; int countPattern ( string str ) { int len = str . size ( ) ; bool oneSeen = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0 ; } return count ; } int main ( ) { string str = ""100001abc101"" ; cout << countPattern ( str ) ; return 0 ; }","['int countPattern ( string str ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int countPattern ( string str ) {
"
561,Count of groups of consecutive 1 s in a given Binary String | C ++ program for the above approach ; Function to find the number of the groups of 1 s only in the binary string ; Stores number of groups of 1 s ; Initialization of the stack ; Traverse the string S ; If S [ i ] is '1' ; Otherwise ; If st is empty ; If st is not empty ; Return answer ; Driver code ; Input ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int groupsOfOnes ( string S , int N ) { int count = 0 ; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } int main ( ) { string S = ""100110111"" ; int N = S . length ( ) ; cout << groupsOfOnes ( S , N ) << endl ; return 0 ; }",Count of groups of consecutive 1 s in a given Binary String.,"#include <bits/stdc++.h> 
 using namespace std ; int groupsOfOnes ( string S , int N ) { int count = 0 ; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } int main ( ) { string S = ""100110111"" ; int N = S . length ( ) ; cout << groupsOfOnes ( S , N ) << endl ; return 0 ; }","['int groupsOfOnes ( string S , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int groupsOfOnes ( string S , int N ) {
"
562,"Palindromic strings of length 3 possible by using characters of a given string | C ++ program for the above approach ; Function to print all palindromic strings of length 3 that can be formed using characters of string S ; Stores the count of character ; Traverse the string S ; Stores all palindromic strings ; Iterate over the charchaters over the range [ ' a ' , ' z ' ] ; If Hash [ ch ] is equal to 2 ; Iterate over the characters over the range [ ' a ' , ' z ' ] ; Stores all the palindromic string ; Push the s into the set st ; If Hash [ i ] is greater than or equal to 3 ; Iterate over charchaters over the range [ ' a ' , ' z ' ] ; Stores all the palindromic string ; If Hash [ j ] is positive ; Push s into the set st ; Iterate over the set ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void generatePalindrome ( string S ) { unordered_map < char , int > Hash ; for ( auto ch : S ) { Hash [ ch ] ++ ; } set < string > st ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( Hash [ i ] == 2 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = "" "" ; if ( Hash [ j ] && i != j ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } if ( Hash [ i ] >= 3 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = "" "" ; if ( Hash [ j ] ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } } for ( auto ans : st ) { cout << ans << "" STRNEWLINE "" ; } } int main ( ) { string S = "" ddabdac "" ; generatePalindrome ( S ) ; return 0 ; }",Palindromic strings of length 3 possible by using characters of a given string.,"#include <bits/stdc++.h> 
 using namespace std ; void generatePalindrome ( string S ) { unordered_map < char , int > Hash ; for ( auto ch : S ) { Hash [ ch ] ++ ; } set < string > st ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( Hash [ i ] == 2 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = "" "" ; if ( Hash [ j ] && i != j ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } if ( Hash [ i ] >= 3 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = "" "" ; if ( Hash [ j ] ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } } for ( auto ans : st ) { cout << ans << "" STRNEWLINE "" ; } } int main ( ) { string S = "" ddabdac "" ; generatePalindrome ( S ) ; return 0 ; }","['void generatePalindrome ( string S ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void generatePalindrome ( string S ) {
"
563,"Count occurrences of substring X before every occurrence of substring Y in a given string | C ++ program for the above approach ; Function to count occurrences of the string Y in the string S for every occurrence of X in S ; Stores the count of occurrences of X ; Stores the lengths of the three strings ; Traverse the string S ; If the current substring is Y , then increment the value of count by 1 ; If the current substring is X , then print the count ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << "" ▁ "" ; } } int main ( ) { string S = "" abcdefdefabc "" ; string X = "" abc "" ; string Y = "" def "" ; countOccurrences ( S , X , Y ) ; return 0 ; }",Count occurrences of substring X before every occurrence of substring Y in a given string.,"#include <bits/stdc++.h> 
 using namespace std ; void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << "" ▁ "" ; } } int main ( ) { string S = "" abcdefdefabc "" ; string X = "" abc "" ; string Y = "" def "" ; countOccurrences ( S , X , Y ) ; return 0 ; }","['void countOccurrences ( string S , string X , string Y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countOccurrences ( string S , string X , string Y ) {
"
564,"Program to construct DFA for Regular Expression C ( A + B ) + | C ++ program for the above approach ; Function to find whether the given string is Accepted by the DFA ; If n <= 1 , then print No ; To count the matched characters ; Check if the first character is C ; Traverse the rest of string ; If character is A or B , increment count by 1 ; If the first character is not C , print - 1 ; If all characters matches ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void DFA ( string str , int N ) { if ( N <= 1 ) { cout << "" No "" ; return ; } int count = 0 ; if ( str [ 0 ] == ' C ' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == ' A ' str [ i ] == ' B ' ) count ++ ; else break ; } } else { cout << "" No "" ; return ; } if ( count == N ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { string str = "" CAABBAAB "" ; int N = str . size ( ) ; DFA ( str , N ) ; return 0 ; }",Program to construct DFA for Regular Expression C ( A + B ) +.,"#include <bits/stdc++.h> 
 using namespace std ; void DFA ( string str , int N ) { if ( N <= 1 ) { cout << "" No "" ; return ; } int count = 0 ; if ( str [ 0 ] == ' C ' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == ' A ' str [ i ] == ' B ' ) count ++ ; else break ; } } else { cout << "" No "" ; return ; } if ( count == N ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { string str = "" CAABBAAB "" ; int N = str . size ( ) ; DFA ( str , N ) ; return 0 ; }","['void DFA ( string str , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void DFA ( string str , int N ) {
"
565,"Minimum and maximum number of digits required to be removed to make a given number divisible by 3 | C ++ program for the above approach ; Function to find the maximum and minimum number of digits to be removed to make str divisible by 3 ; Convert the string into array of digits ; Count of 0 s , 1 s , and 2 s ; Traverse the array ; Find the sum of digits % 3 ; Cases to find minimum number of digits to be removed ; Cases to find maximum number of digits to be removed ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMaxDigits ( string str , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { cout << 0 << ' ▁ ' ; } if ( sum == 1 ) { if ( one && N > 1 ) cout << 1 << ' ▁ ' ; else if ( two > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( sum == 2 ) { if ( two && N > 1 ) cout << 1 << ' ▁ ' ; else if ( one > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( zero > 0 ) cout << N - 1 << ' ▁ ' ; else if ( one > 0 && two > 0 ) cout << N - 2 << ' ▁ ' ; else if ( one > 2 two > 2 ) cout << N - 3 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } int main ( ) { string str = ""12345"" ; int N = str . length ( ) ; minMaxDigits ( str , N ) ; return 0 ; }",Minimum and maximum number of digits required to be removed to make a given number divisible by 3.,"#include <bits/stdc++.h> 
 using namespace std ; void minMaxDigits ( string str , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { cout << 0 << ' ▁ ' ; } if ( sum == 1 ) { if ( one && N > 1 ) cout << 1 << ' ▁ ' ; else if ( two > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( sum == 2 ) { if ( two && N > 1 ) cout << 1 << ' ▁ ' ; else if ( one > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( zero > 0 ) cout << N - 1 << ' ▁ ' ; else if ( one > 0 && two > 0 ) cout << N - 2 << ' ▁ ' ; else if ( one > 2 two > 2 ) cout << N - 3 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } int main ( ) { string str = ""12345"" ; int N = str . length ( ) ; minMaxDigits ( str , N ) ; return 0 ; }","['void minMaxDigits ( string str , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minMaxDigits ( string str , int N ) {
"
566,"Minimum replacements required to obtain a K | C ++ program for the above approach ; Function to find the minimum number of changes to make the string K - periodic and palindrome ; Initialize ans with 0 ; Iterate from 0 to ( K + 1 ) / 2 ; Store frequency of character ; Iterate through all indices , i , i + K , i + 2 k ... . and store the frequency of character ; Increase the frequency of current character ; Iterate through all indices K - i , 2 K - i , 3 K - i ... . and store the frequency of character ; If K is odd & i is samw as K / 2 , break the loop ; Increase the frequency of current character ; Find the maximum frequency of a character among all visited characters ; If K is odd and i is same as K / 2 then , only N / K characters is visited ; Otherwise N / K * 2 characters has visited ; Return the result ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumChanges ( int N , int K , string S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { map < char , int > mp ; for ( int j = i ; j < N ; j += K ) { mp [ S [ j ] ] ++ ; } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K & 1 and i == K / 2 ) break ; mp [ S [ j ] ] ++ ; } int curr_max = INT_MIN ; for ( auto p : mp ) curr_max = max ( curr_max , p . second ) ; if ( K & 1 and i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; } int main ( ) { string S = "" aabbcbbcb "" ; int N = S . length ( ) ; int K = 3 ; cout << findMinimumChanges ( N , K , S ) ; return 0 ; }",Minimum replacements required to obtain a K.,"#include <bits/stdc++.h> 
 using namespace std ; int findMinimumChanges ( int N , int K , string S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { map < char , int > mp ; for ( int j = i ; j < N ; j += K ) { mp [ S [ j ] ] ++ ; } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K & 1 and i == K / 2 ) break ; mp [ S [ j ] ] ++ ; } int curr_max = INT_MIN ; for ( auto p : mp ) curr_max = max ( curr_max , p . second ) ; if ( K & 1 and i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; } int main ( ) { string S = "" aabbcbbcb "" ; int N = S . length ( ) ; int K = 3 ; cout << findMinimumChanges ( N , K , S ) ; return 0 ; }","['int findMinimumChanges ( int N , int K , string S ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMinimumChanges ( int N , int K , string S ) {
"
567,Check if a String contains any index with more than K active characters | C ++ Program to implement the above approach ; Function to check if any index contains more than K active characters ; Store the last occurrence of each character in the map . ; Stores the active characters ; Insert the character ; If the size of set exceeds K ; Remove the character from set if i is the last index of the current character ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkString ( string s , int K ) { int n = s . length ( ) ; unordered_map < char , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] = i ; } int cnt = 0 , f = 0 ; unordered_set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { st . insert ( s [ i ] ) ; if ( st . size ( ) > K ) { f = 1 ; break ; } if ( mp [ s [ i ] ] == i ) st . erase ( s [ i ] ) ; } return ( f == 1 ? "" Yes "" : "" No "" ) ; } int main ( ) { string s = "" aabbcdca "" ; int k = 2 ; cout << checkString ( s , k ) ; return 0 ; }",Check if a String contains any index with more than K active characters.,"#include <bits/stdc++.h> 
 using namespace std ; string checkString ( string s , int K ) { int n = s . length ( ) ; unordered_map < char , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] = i ; } int cnt = 0 , f = 0 ; unordered_set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { st . insert ( s [ i ] ) ; if ( st . size ( ) > K ) { f = 1 ; break ; } if ( mp [ s [ i ] ] == i ) st . erase ( s [ i ] ) ; } return ( f == 1 ? "" Yes "" : "" No "" ) ; } int main ( ) { string s = "" aabbcdca "" ; int k = 2 ; cout << checkString ( s , k ) ; return 0 ; }","['string checkString ( string s , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string checkString ( string s , int K ) {
"
568,Count the number of strings in an array whose distinct characters are less than equal to M | C ++ implementation to count the number of strings in the array whose distinct characters is less than or equal to M ; Function to count the strings whose distinct characters count is less than M ; Loop to iterate over all the strings of the array ; Distinct characters in the String with the help of set ; Checking if its less than or equal to M ; Driver Code,"#include <bits/stdc++.h> NEW_LINE #include <set> NEW_LINE using namespace std ; void distinct ( string S [ ] , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < char > set1 ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S [ ] = { "" HERBIVORES "" , "" AEROPLANE "" , "" GEEKSFORGEEKS "" } ; int M = 7 ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; distinct ( S , M , n ) ; return 0 ; }",Count the number of strings in an array whose distinct characters are less than equal to M.,"#include <bits/stdc++.h> 
 #include <set> 
 using namespace std ; void distinct ( string S [ ] , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < char > set1 ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S [ ] = { "" HERBIVORES "" , "" AEROPLANE "" , "" GEEKSFORGEEKS "" } ; int M = 7 ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; distinct ( S , M , n ) ; return 0 ; }","['void distinct ( string S [ ] , int M , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <set> 
 using namespace std ;
 void distinct ( string S [ ] , int M , int n ) {
"
569,Remove odd frequency characters from the string | C ++ program to remove the characters having odd frequencies in the string ; Function to remove the characters which have odd frequencies in the string ; Create a map to store the frequency of each character ; To store the new string ; Remove the characters which have odd frequencies ; If the character has odd frequency then skip ; Else concatenate the character to the new string ; Return the modified string ; Driver code ; Remove the characters which have odd frequencies,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOddFrequencyCharacters ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] & 1 ) continue ; new_string += s [ i ] ; } return new_string ; } int main ( ) { string str = "" geeksforgeeks "" ; str = removeOddFrequencyCharacters ( str ) ; cout << str << "" STRNEWLINE "" ; return 0 ; }",Remove odd frequency characters from the string.,"#include <bits/stdc++.h> 
 using namespace std ; string removeOddFrequencyCharacters ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] & 1 ) continue ; new_string += s [ i ] ; } return new_string ; } int main ( ) { string str = "" geeksforgeeks "" ; str = removeOddFrequencyCharacters ( str ) ; cout << str << "" STRNEWLINE "" ; return 0 ; }","['string removeOddFrequencyCharacters ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string removeOddFrequencyCharacters ( string s ) {
"
570,"Product of nodes at k | C ++ implementation to find product of elements at k - th level ; Recursive Function to find product of elements at k - th level ; if subtree is null , just like if root == NULL ; Consider only level k node to be part of the product ; Recur for Left Subtree ; Recur for Right Subtree ; Taking care of ' ) ' after left and right subtree ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int productAtKthLevel ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; int leftproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } } int main ( ) { string tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) "" "" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" ; int k = 2 ; int i = 0 ; cout << productAtKthLevel ( tree , k , i , 0 ) ; return 0 ; }",Product of nodes at k.,"#include <bits/stdc++.h> 
 using namespace std ; int productAtKthLevel ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; int leftproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } } int main ( ) { string tree = "" ( 0(5(6 ( ) ( ) ) ( 4 ( ) "" "" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) "" ; int k = 2 ; int i = 0 ; cout << productAtKthLevel ( tree , k , i , 0 ) ; return 0 ; }","['int productAtKthLevel ( string tree , int k , int & i , int level ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int productAtKthLevel ( string tree , int k , int & i , int level ) {
"
571,Print the most occurring character in an array of strings | C ++ program to print the most occurring character in an array of strings ; Function to print the most occurring character ; Creating a hash of size 26 ; For loop to iterate through every string of the array ; For loop to iterate through every character of the string ; Incrementing the count of the character in the hash ; Finding the character with the maximum count ; Driver code ; Declaring Vector of String type,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMostOccurringChar ( vector < string > str ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { hash [ str [ i ] [ j ] ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } cout << ( char ) ( max + 97 ) << endl ; } int main ( ) { vector < string > str ; str . push_back ( "" animal "" ) ; str . push_back ( "" zebra "" ) ; str . push_back ( "" lion "" ) ; str . push_back ( "" giraffe "" ) ; findMostOccurringChar ( str ) ; return 0 ; }",Print the most occurring character in an array of strings.,"#include <bits/stdc++.h> 
 using namespace std ; void findMostOccurringChar ( vector < string > str ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { hash [ str [ i ] [ j ] ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } cout << ( char ) ( max + 97 ) << endl ; } int main ( ) { vector < string > str ; str . push_back ( "" animal "" ) ; str . push_back ( "" zebra "" ) ; str . push_back ( "" lion "" ) ; str . push_back ( "" giraffe "" ) ; findMostOccurringChar ( str ) ; return 0 ; }","['void findMostOccurringChar ( vector < string > str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findMostOccurringChar ( vector < string > str ) {
"
572,Check whether the given floating point number is a palindrome | C ++ implementation of the approach ; Function that returns true if num is palindrome ; Convert the given floating point number into a string ; Pointers pointing to the first and the last character of the string ; Not a palindrome ; Update the pointers ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( float num ) { stringstream ss ; ss << num ; string s ; ss >> s ; int low = 0 ; int high = s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; } int main ( ) { float n = 123.321f ; if ( isPalindrome ( n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check whether the given floating point number is a palindrome.,"#include <bits/stdc++.h> 
 using namespace std ; bool isPalindrome ( float num ) { stringstream ss ; ss << num ; string s ; ss >> s ; int low = 0 ; int high = s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; } int main ( ) { float n = 123.321f ; if ( isPalindrome ( n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool isPalindrome ( float num ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isPalindrome ( float num ) {
"
573,Maximum number of times str1 appears as a non | C ++ implementation of the approach ; Function to return the maximum number of times str1 can appear as a non - overlapping substring in str2 ; str1 cannot never be substring of str2 ; Store the frequency of the characters of str1 ; Store the frequency of the characters of str2 ; To store the required count of substrings ; Current character doesn 't appear in str1 ; Frequency of the current character in str1 is greater than its frequency in str2 ; Update the count of possible substrings ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int freq2 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; } int main ( ) { string str1 = "" geeks "" , str2 = "" gskefrgoekees "" ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; cout << maxSubStr ( str1 , len1 , str2 , len2 ) ; return 0 ; }",Maximum number of times str1 appears as a non.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX = 26 ; int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int freq2 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; } int main ( ) { string str1 = "" geeks "" , str2 = "" gskefrgoekees "" ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; cout << maxSubStr ( str1 , len1 , str2 , len2 ) ; return 0 ; }","['int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX = 26 ;
 int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) {
"
574,Number of ways to insert two pairs of parentheses into a string of N characters | C ++ implementation of the approach ; Function to return the number of ways to insert the bracket pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } int main ( ) { string str = "" ab "" ; int n = str . length ( ) ; cout << cntWays ( str , n ) ; return 0 ; }",Number of ways to insert two pairs of parentheses into a string of N characters.,"#include <bits/stdc++.h> 
 using namespace std ; int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } int main ( ) { string str = "" ab "" ; int n = str . length ( ) ; cout << cntWays ( str , n ) ; return 0 ; }","['int cntWays ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int cntWays ( string str , int n ) {
"
576,"Number of substrings that start with "" geeks "" and end with "" for "" | C ++ implementation of the approach ; Function to return the count of required substrings ; For every index of the string ; If the substring starting at the current index is "" geeks "" ; If the substring is "" for "" ; Driver code","#include <iostream> NEW_LINE using namespace std ; int countSubStr ( string s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . substr ( i , 5 ) == "" geeks "" ) c1 ++ ; if ( s . substr ( i , 3 ) == "" for "" ) c2 = c2 + c1 ; } return c2 ; } int main ( ) { string s = "" geeksforgeeksisforgeeks "" ; int n = s . size ( ) ; cout << countSubStr ( s , n ) ; return 0 ; }","Number of substrings that start with "" geeks "" and end with "" for "".","#include <iostream> 
 using namespace std ; int countSubStr ( string s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . substr ( i , 5 ) == "" geeks "" ) c1 ++ ; if ( s . substr ( i , 3 ) == "" for "" ) c2 = c2 + c1 ; } return c2 ; } int main ( ) { string s = "" geeksforgeeksisforgeeks "" ; int n = s . size ( ) ; cout << countSubStr ( s , n ) ; return 0 ; }","['int countSubStr ( string s , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int countSubStr ( string s , int n ) {
"
578,Encrypt the given string with the following operations | C ++ implementation of the above approach : ; Function to return the encrypted string ; Reduce x because rotation of length 26 is unnecessary ; Calculate the frequency of characters ; If the frequency of current character is even then increment it by x ; Else decrement it by x ; Return the count ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define MAX  26 NEW_LINE using namespace std ; string encryptStr ( string str , int n , int x ) { x = x % MAX ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( str [ i ] - ' a ' + x ) % MAX ; str [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( str [ i ] - ' a ' - x ) ; if ( pos < 0 ) { pos += MAX ; } str [ i ] = ( char ) ( pos + ' a ' ) ; } } return str ; } int main ( ) { string s = "" abcda "" ; int n = s . size ( ) ; int x = 3 ; cout << encryptStr ( s , n , x ) << endl ; return 0 ; }",Encrypt the given string with the following operations.,"#include <bits/stdc++.h> 
 #define MAX  26 
 using namespace std ; string encryptStr ( string str , int n , int x ) { x = x % MAX ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( str [ i ] - ' a ' + x ) % MAX ; str [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( str [ i ] - ' a ' - x ) ; if ( pos < 0 ) { pos += MAX ; } str [ i ] = ( char ) ( pos + ' a ' ) ; } } return str ; } int main ( ) { string s = "" abcda "" ; int n = s . size ( ) ; int x = 3 ; cout << encryptStr ( s , n , x ) << endl ; return 0 ; }","['string encryptStr ( string str , int n , int x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define MAX  26 
 using namespace std ;
 string encryptStr ( string str , int n , int x ) {
"
579,Rearrange characters in a string such that no two adjacent are same using hashing | C ++ implementation of the approach ; Function that returns true if it is possible to rearrange the characters of the string such that no two consecutive characters are same ; To store the frequency of each of the character ; To store the maximum frequency so far ; If possible ; Driver code,"#include <bits/stdc++.h> NEW_LINE #include <time.h> NEW_LINE using namespace std ; int isPossible ( string str ) { unordered_map < char , int > freq ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } if ( max_freq <= ( str . length ( ) - max_freq + 1 ) ) return true ; return false ; } int main ( ) { string str = "" geeksforgeeks "" ; if ( isPossible ( str ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Rearrange characters in a string such that no two adjacent are same using hashing.,"#include <bits/stdc++.h> 
 #include <time.h> 
 using namespace std ; int isPossible ( string str ) { unordered_map < char , int > freq ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } if ( max_freq <= ( str . length ( ) - max_freq + 1 ) ) return true ; return false ; } int main ( ) { string str = "" geeksforgeeks "" ; if ( isPossible ( str ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['int isPossible ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <time.h> 
 using namespace std ;
 int isPossible ( string str ) {
"
580,Find uncommon characters of the two strings | Set 2 | C ++ implementation of the approach ; Function to print the uncommon characters in the given string in sorted order ; Converting character to ASCII code ; Bit operation ; Converting character to ASCII code ; Bit operation ; XOR operation leaves only uncommon characters in the ans variable ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = int ( str1 [ i ] ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = int ( str2 [ i ] ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { cout << char ( ' a ' + i ) ; } ans = ans / 2 ; i ++ ; } } int main ( ) { string str1 = "" geeksforgeeks "" ; string str2 = "" geeksquiz "" ; printUncommon ( str1 , str2 ) ; return 0 ; }",Find uncommon characters of the two strings.,"#include <bits/stdc++.h> 
 using namespace std ; void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = int ( str1 [ i ] ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = int ( str2 [ i ] ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { cout << char ( ' a ' + i ) ; } ans = ans / 2 ; i ++ ; } } int main ( ) { string str1 = "" geeksforgeeks "" ; string str2 = "" geeksquiz "" ; printUncommon ( str1 , str2 ) ; return 0 ; }","['void printUncommon ( string str1 , string str2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printUncommon ( string str1 , string str2 ) {
"
581,"Minimum number of bracket reversals needed to make an expression balanced | Set | C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced . ; length of expression must be even to make it balanced by using reversals . ; To store number of reversals required . ; To store number of unbalanced opening brackets . ; To store number of unbalanced closing brackets . ; If current bracket is open then increment open count . ; If current bracket is close , check if it balances opening bracket . If yes then decrement count of unbalanced opening bracket else increment count of closing bracket . ; For the case : "" } { "" or when one closing and one opening bracket remains for pairing , then both need to be reversed . ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; } int main ( ) { string expr = "" } } { { "" ; cout << countMinReversals ( expr ) ; return 0 ; }",Minimum number of bracket reversals needed to make an expression balanced.,"#include <bits/stdc++.h> 
 using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; } int main ( ) { string expr = "" } } { { "" ; cout << countMinReversals ( expr ) ; return 0 ; }","['int countMinReversals ( string expr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countMinReversals ( string expr ) {
"
582,Character pairs from two strings with even sum | C ++ implementation of the approach ; Function to return the total number of valid pairs ; Count total number of even and odd ascii values for string s1 ; Count total number of even and odd ascii values for string s2 ; Return total valid pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( string s1 , string s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( int ( s1 [ i ] ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( int ( s2 [ i ] ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } int main ( ) { string s1 = "" geeks "" , s2 = "" for "" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }",Character pairs from two strings with even sum.,"#include <bits/stdc++.h> 
 using namespace std ; int totalPairs ( string s1 , string s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( int ( s1 [ i ] ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( int ( s2 [ i ] ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } int main ( ) { string s1 = "" geeks "" , s2 = "" for "" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }","['int totalPairs ( string s1 , string s2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int totalPairs ( string s1 , string s2 ) {
"
583,Maximum occurrence of prefix in the Array | CPP program to find the number of occurrences of prefix which occurs maximum no . of time ; Function to return the count of the required prefix ; Find the frequency of first character of string ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; } int main ( ) { string str = "" abbcdabbcd "" ; cout << prefixOccurrences ( str ) ; return 0 ; }",Maximum occurrence of prefix in the Array.,"#include <bits/stdc++.h> 
 using namespace std ; int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; } int main ( ) { string str = "" abbcdabbcd "" ; cout << prefixOccurrences ( str ) ; return 0 ; }","['int prefixOccurrences ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int prefixOccurrences ( string str ) {
"
584,Minimum number of given operations required to convert a string to another string | C ++ implementation of the approach ; Function to return the minimum operations of the given type required to convert string s to string t ; Characters are already equal ; Increment count of 0 s ; Increment count of 1 s ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; } int main ( ) { string s = ""010"" , t = ""101"" ; int n = s . length ( ) ; cout << minOperations ( s , t , n ) ; return 0 ; }",Minimum number of given operations required to convert a string to another string.,"#include <bits/stdc++.h> 
 using namespace std ; int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; } int main ( ) { string s = ""010"" , t = ""101"" ; int n = s . length ( ) ; cout << minOperations ( s , t , n ) ; return 0 ; }","['int minOperations ( string s , string t , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minOperations ( string s , string t , int n ) {
"
585,Decrypt a string encrypted by repeating i | C ++ implementation of the approach ; Function to return the decrypted string ; Initial jump will be 1 ; Increment jump by 1 with every character ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = "" "" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; } int main ( ) { string str = "" geeeeekkkksssss "" ; int n = str . length ( ) ; cout << decryptString ( str , n ) ; return 0 ; }",Decrypt a string encrypted by repeating i.,"#include <bits/stdc++.h> 
 using namespace std ; string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = "" "" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; } int main ( ) { string str = "" geeeeekkkksssss "" ; int n = str . length ( ) ; cout << decryptString ( str , n ) ; return 0 ; }","['string decryptString ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string decryptString ( string str , int n ) {
"
588,"Check if frequency of character in one string is a factor or multiple of frequency of same character in other string | C ++ implementation of above approach ; Function that checks if the frequency of character are a factor or multiple of each other ; map store frequency of each character ; if any frequency is 0 , then continue as condition is satisfied ; if factor or multiple , then condition satisfied ; if condition not satisfied ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool multipleOrFactor ( string s1 , string s2 ) { map < char , int > m1 , m2 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) m1 [ s1 [ i ] ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) m2 [ s2 [ i ] ] ++ ; map < char , int > :: iterator it ; for ( it = m1 . begin ( ) ; it != m1 . end ( ) ; it ++ ) { if ( m2 . find ( ( * it ) . first ) == m2 . end ( ) ) continue ; if ( m2 [ ( * it ) . first ] % ( * it ) . second == 0 || ( * it ) . second % m2 [ ( * it ) . first ] == 0 ) continue ; else return false ; } } int main ( ) { string s1 = "" geeksforgeeks "" ; string s2 = "" geeks "" ; multipleOrFactor ( s1 , s2 ) ? cout << "" YES "" : cout << "" NO "" ; return 0 ; }",Check if frequency of character in one string is a factor or multiple of frequency of same character in other string.,"#include <bits/stdc++.h> 
 using namespace std ; bool multipleOrFactor ( string s1 , string s2 ) { map < char , int > m1 , m2 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) m1 [ s1 [ i ] ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) m2 [ s2 [ i ] ] ++ ; map < char , int > :: iterator it ; for ( it = m1 . begin ( ) ; it != m1 . end ( ) ; it ++ ) { if ( m2 . find ( ( * it ) . first ) == m2 . end ( ) ) continue ; if ( m2 [ ( * it ) . first ] % ( * it ) . second == 0 || ( * it ) . second % m2 [ ( * it ) . first ] == 0 ) continue ; else return false ; } } int main ( ) { string s1 = "" geeksforgeeks "" ; string s2 = "" geeks "" ; multipleOrFactor ( s1 , s2 ) ? cout << "" YES "" : cout << "" NO "" ; return 0 ; }","['bool multipleOrFactor ( string s1 , string s2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool multipleOrFactor ( string s1 , string s2 ) {
"
589,Remove even frequency characters from the string | C ++ implementation of the approach ; Function that removes the characters which have even frequencies in the string ; create a map to store the frequency of each character ; to store the new string ; remove the characters which have even frequencies ; if the character has even frequency then skip ; else concatenate the character to the new string ; display the modified string ; Driver code ; remove the characters which have even frequencies,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string += s [ i ] ; } cout << new_string << endl ; } int main ( ) { string s = "" aabbbddeeecc "" ; solve ( s ) ; return 0 ; }",Remove even frequency characters from the string.,"#include <bits/stdc++.h> 
 using namespace std ; void solve ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string += s [ i ] ; } cout << new_string << endl ; } int main ( ) { string s = "" aabbbddeeecc "" ; solve ( s ) ; return 0 ; }","['void solve ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void solve ( string s ) {
"
592,Longest subsequence where each character occurs at least k times | CPP Program to find the subsequence with each character occurring at least k times in string s ; Function to find the subsequence ; Taking an extra array to keep record for character count in s ; Counting occurrences of all characters in str [ ] ; Printing characters with count >= k in same order as they appear in str . ; Driver code,"#include <iostream> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; } int main ( ) { int k = 2 ; findSubsequence ( "" geeksforgeeks "" , k ) ; return 0 ; }",Longest subsequence where each character occurs at least k times.,"#include <iostream> 
 using namespace std ; #define MAX_CHAR  26 
 void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; } int main ( ) { int k = 2 ; findSubsequence ( "" geeksforgeeks "" , k ) ; return 0 ; }","['void findSubsequence ( string str , int k ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 #define MAX_CHAR  26 
 void findSubsequence ( string str , int k ) {
"
593,gOOGLE cASE of a given sentence | C ++ program to convert a sentence to gOOGLE cASE . ; Empty strings ; Convert input string to upper case ; Check if character is not a space and adding it to string w ; Converting first character to lower case and subsequent initial letter of another word to lower case ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string str ) { string w = "" "" , z = "" "" ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += "" ▁ "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + "" ▁ "" ; w = "" "" ; } } return z ; } int main ( ) { string str = "" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks "" ; cout << convert ( str ) << endl ; return 0 ; }",gOOGLE cASE of a given sentence.,"#include <bits/stdc++.h> 
 using namespace std ; string convert ( string str ) { string w = "" "" , z = "" "" ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += "" ▁ "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + "" ▁ "" ; w = "" "" ; } } return z ; } int main ( ) { string str = "" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks "" ; cout << convert ( str ) << endl ; return 0 ; }","['string convert ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string convert ( string str ) {
"
595,Count occurrences of a word in string | C ++ program to count the number of occurrence of a word in the given string ; split the string by spaces in a ; search for pattern in a ; if match found increase count ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , "" ▁ "" ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , "" ▁ "" ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; } int main ( ) { char str [ ] = "" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ "" ; string word = "" portal "" ; cout << countOccurrences ( str , word ) ; return 0 ; }",Count occurrences of a word in string.,"#include <bits/stdc++.h> 
 using namespace std ; int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , "" ▁ "" ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , "" ▁ "" ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; } int main ( ) { char str [ ] = "" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ "" ; string word = "" portal "" ; cout << countOccurrences ( str , word ) ; return 0 ; }","['int countOccurrences ( char * str , string word ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countOccurrences ( char * str , string word ) {
"
596,"Permute a string by changing case | CPP code to print all permutations with respect to cases ; Function to generate permutations ; Number of permutations is 2 ^ n ; Converting string to lower case ; Using all subsequences and permuting them ; If j - th bit is set , we convert it to upper case ; Printing current combination ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void permute ( string input ) { int n = input . length ( ) ; int max = 1 << n ; transform ( input . begin ( ) , input . end ( ) , input . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < max ; i ++ ) { string combination = input ; for ( int j = 0 ; j < n ; j ++ ) if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = toupper ( input . at ( j ) ) ; cout << combination << "" ▁ "" ; } } int main ( ) { permute ( "" ABC "" ) ; return 0 ; }",Permute a string by changing case.,"#include <bits/stdc++.h> 
 using namespace std ; void permute ( string input ) { int n = input . length ( ) ; int max = 1 << n ; transform ( input . begin ( ) , input . end ( ) , input . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < max ; i ++ ) { string combination = input ; for ( int j = 0 ; j < n ; j ++ ) if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = toupper ( input . at ( j ) ) ; cout << combination << "" ▁ "" ; } } int main ( ) { permute ( "" ABC "" ) ; return 0 ; }","['void permute ( string input ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void permute ( string input ) {
"
597,Print the string after the specified character has occurred given no . of times | C ++ program for above implementation ; Function to print the string ; If given count is 0 print the given string and return ; Start traversing the string ; Increment occ if current char is equal to given character ; Break the loop if given character has been occurred given no . of times ; Print the string after the occurrence of given character given no . of times ; Otherwise string is empty ; Drivers code,"#include <iostream> NEW_LINE using namespace std ; void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { cout << str ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1 , str . length ( ) - ( i + 1 ) ) ; else cout << "" Empty ▁ string "" ; } int main ( ) { string str = "" geeks ▁ for ▁ geeks "" ; printString ( str , ' e ' , 2 ) ; return 0 ; }",Print the string after the specified character has occurred given no . of times.,"#include <iostream> 
 using namespace std ; void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { cout << str ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1 , str . length ( ) - ( i + 1 ) ) ; else cout << "" Empty ▁ string "" ; } int main ( ) { string str = "" geeks ▁ for ▁ geeks "" ; printString ( str , ' e ' , 2 ) ; return 0 ; }","['void printString ( string str , char ch , int count ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void printString ( string str , char ch , int count ) {
"
602,Program to find the Eccentricity of a Hyperbola | C ++ program for the above approach ; Function to find the eccentricity of a hyperbola ; Stores the squared ratio of major axis to minor axis ; Increment r by 1 ; Return the square root of r ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << eccHyperbola ( A , B ) ; return 0 ; }",Program to find the Eccentricity of a Hyperbola.,"#include <bits/stdc++.h> 
 using namespace std ; double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << eccHyperbola ( A , B ) ; return 0 ; }","['double eccHyperbola ( double A , double B ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double eccHyperbola ( double A , double B ) {
"
603,Calculate area of a cyclic quadrilateral with given side lengths | C ++ program for the above approach ; Function to find the area of cyclic quadrilateral ; Stores the value of half of the perimeter ; Stores area of cyclic quadrilateral ; Return the resultant area ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } int main ( ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; cout << calculateArea ( A , B , C , D ) ; return 0 ; }",Calculate area of a cyclic quadrilateral with given side lengths.,"#include <bits/stdc++.h> 
 using namespace std ; float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } int main ( ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; cout << calculateArea ( A , B , C , D ) ; return 0 ; }","['float calculateArea ( float A , float B , float C , float D ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float calculateArea ( float A , float B , float C , float D ) {
"
604,Calculate ratio of area of a triangle inscribed in an Ellipse and the triangle formed by corresponding points on auxiliary circle | C ++ program for the above approach ; Function to calculate ratio of a triangle inscribed in an ellipse to the triangle on the auxiliary circle ; Stores the ratio of the semi - major to semi - minor axes ; Print the ratio ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; cout << ratio ; } int main ( ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; return 0 ; }",Calculate ratio of area of a triangle inscribed in an Ellipse and the triangle formed by corresponding points on auxiliary circle.,"#include <bits/stdc++.h> 
 using namespace std ; void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; cout << ratio ; } int main ( ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; return 0 ; }","['void triangleArea ( int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void triangleArea ( int a , int b ) {
"
606,"Program to find height of a Trapezoid | C ++ program for the above approach ; Function to calculate height of the trapezoid ; Apply Heron 's formula ; Calculate the area ; Calculate height of trapezoid ; Print the height ; Driver Code ; Given a , b , p1 and p2","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findHeight ( float p1 , float p2 , float b , float c ) { float a = max ( p1 , p2 ) - min ( p1 , p2 ) ; float s = ( a + b + c ) / 2 ; float area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; float height = ( area * 2 ) / a ; cout << "" Height ▁ is : ▁ "" << height ; } int main ( ) { float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; return 0 ; }",Program to find height of a Trapezoid.,"#include <bits/stdc++.h> 
 using namespace std ; void findHeight ( float p1 , float p2 , float b , float c ) { float a = max ( p1 , p2 ) - min ( p1 , p2 ) ; float s = ( a + b + c ) / 2 ; float area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; float height = ( area * 2 ) / a ; cout << "" Height ▁ is : ▁ "" << height ; } int main ( ) { float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; return 0 ; }","['void findHeight ( float p1 , float p2 , float b , float c ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findHeight ( float p1 , float p2 , float b , float c ) {
"
607,Icositetragonal Number | C ++ program to find nth Icositetragonal number ; Function to find Icositetragonal number ; Formula to calculate nth Icositetragonal number ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icositetragonal_num ( n ) << endl ; n = 10 ; cout << Icositetragonal_num ( n ) ; return 0 ; },Icositetragonal Number.,"#include <bits/stdc++.h> 
 using namespace std ; int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icositetragonal_num ( n ) << endl ; n = 10 ; cout << Icositetragonal_num ( n ) ; return 0 ; }","['int Icositetragonal_num ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Icositetragonal_num ( int n ) {
"
608,"Area of circle inscribed in a Isosceles Trapezoid | CPP implementation to find the rea of the circle inscribed in a trapezoid having non - parallel sides m , n ; Function to find area of circle inscribed in a trapezoid having non - parallel sides m , n ; radius of circle by the formula i . e . root ( m * n ) / 2 area of circle = ( 3.141 ) * ( R * * 2 ) ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; } int main ( ) { int n = 10 ; int m = 30 ; cout << ( area_of_circle ( m , n ) ) ; }",Area of circle inscribed in a Isosceles Trapezoid.,"#include <bits/stdc++.h> 
 using namespace std ; double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; } int main ( ) { int n = 10 ; int m = 30 ; cout << ( area_of_circle ( m , n ) ) ; }","['double area_of_circle ( int m , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double area_of_circle ( int m , int n ) {
"
609,Area of Equilateral triangle inscribed in a Circle of radius R | C ++ implementation to find the area of the equilateral triangle inscribed in a circle of radius R ; Function to find the area of equilateral triangle inscribed in a circle of radius R ; Base and Height of equilateral triangle ; Area using Base and Height ; Driver Code,#include <iostream> NEW_LINE using namespace std ; double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } int main ( ) { int R = 7 ; cout << ( area ( R ) ) ; return 0 ; },Area of Equilateral triangle inscribed in a Circle of radius R.,"#include <iostream> 
 using namespace std ; double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } int main ( ) { int R = 7 ; cout << ( area ( R ) ) ; return 0 ; }","['double area ( int R ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 double area ( int R ) {
"
610,Area of largest Circle that can be inscribed in a SemiCircle | C ++ Program to find the biggest circle which can be inscribed within the semicircle ; Function to find the area of the circle ; Radius cannot be negative ; Area of the largest circle ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = 3.14 * R * R / 4 ; return a ; } int main ( ) { float R = 2 ; cout << circlearea ( R ) << endl ; return 0 ; },Area of largest Circle that can be inscribed in a SemiCircle.,"#include <bits/stdc++.h> 
 using namespace std ; float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = 3.14 * R * R / 4 ; return a ; } int main ( ) { float R = 2 ; cout << circlearea ( R ) << endl ; return 0 ; }","['float circlearea ( float R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float circlearea ( float R ) {
"
611,Number of pairs of lines having integer intersection points | C ++ program to Number of pairs of lines having integer intersection points ; Count number of pairs of lines having integer intersection point ; Initialize arrays to store counts ; Count number of odd and even Pi ; Count number of odd and even Qi ; Return the count of pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } int main ( ) { int P [ ] = { 1 , 3 , 2 } , Q [ ] = { 3 , 0 } ; int N = sizeof ( P ) / sizeof ( P [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << countPairs ( P , Q , N , M ) ; return 0 ; }",Number of pairs of lines having integer intersection points.,"#include <bits/stdc++.h> 
 using namespace std ; int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } int main ( ) { int P [ ] = { 1 , 3 , 2 } , Q [ ] = { 3 , 0 } ; int N = sizeof ( P ) / sizeof ( P [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << countPairs ( P , Q , N , M ) ; return 0 ; }","['int countPairs ( int * P , int * Q , int N , int M ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countPairs ( int * P , int * Q , int N , int M ) {
"
612,Maximum number of line intersections formed through intersection of N planes | C ++ implementation of the above pproach ; Function to count maximum number of intersections possible ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << countIntersections ( n ) ; return 0 ; },Maximum number of line intersections formed through intersection of N planes.,"#include <bits/stdc++.h> 
 using namespace std ; int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << countIntersections ( n ) ; return 0 ; }","['int countIntersections ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countIntersections ( int n ) {
"
614,Angle subtended by the chord to center of the circle when the angle subtended by the another equal chord of a congruent circle is given | C ++ program to find the angle subtended by the chord to the centre of the circle when the angle subtended by another equal chord of a congruent circle is given ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void anglequichord ( int z ) { cout << "" The ▁ angle ▁ is ▁ "" << z << "" ▁ degrees "" << endl ; } int main ( ) { int z = 48 ; anglequichord ( z ) ; return 0 ; }",Angle subtended by the chord to center of the circle when the angle subtended by the another equal chord of a congruent circle is given.,"#include <bits/stdc++.h> 
 using namespace std ; void anglequichord ( int z ) { cout << "" The ▁ angle ▁ is ▁ "" << z << "" ▁ degrees "" << endl ; } int main ( ) { int z = 48 ; anglequichord ( z ) ; return 0 ; }","['void anglequichord ( int z ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void anglequichord ( int z ) {
"
615,Program to print ASCII Value of all digits of a given number | C ++ program to convert the digits of a number to its ASCII values ; Function to convert digits of N to respective ASCII values ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int convertToASCII ( int N ) { string num = to_string ( N ) ; for ( char ch : num ) { cout << ch << "" ▁ ( "" << ( int ) ch << "" ) STRNEWLINE "" ; } } int main ( ) { int N = 36 ; convertToASCII ( N ) ; return 0 ; }",Program to print ASCII Value of all digits of a given number.,"#include <bits/stdc++.h> 
 using namespace std ; int convertToASCII ( int N ) { string num = to_string ( N ) ; for ( char ch : num ) { cout << ch << "" ▁ ( "" << ( int ) ch << "" ) STRNEWLINE "" ; } } int main ( ) { int N = 36 ; convertToASCII ( N ) ; return 0 ; }","['int convertToASCII ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int convertToASCII ( int N ) {
"
617,Count subarrays made up of single | C ++ program for the above approach ; Function to count of subarrays made up of single digit integers only ; Stores count of subarrays ; Stores the count of consecutive single digit numbers in the array ; Traverse the array ; Increment size of block by 1 ; Increment res by count ; Assign count = 0 ; Driver Code ; Given array ; Size of the array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; } int main ( ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; singleDigitSubarrayCount ( arr , N ) ; return 0 ; }",Count subarrays made up of single.,"#include <bits/stdc++.h> 
 using namespace std ; int singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; } int main ( ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; singleDigitSubarrayCount ( arr , N ) ; return 0 ; }","['int singleDigitSubarrayCount ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int singleDigitSubarrayCount ( int arr [ ] , int N ) {
"
619,"Count integers up to N which can be represented as sum of two or more consecutive numbers | C ++ implementation of the above approach ; Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers ; Count powers of 2 up to N ; Increment count ; Update current power of 2 ; Driver Code",#include <bits/stdc++.h> NEW_LINE using namespace std ; void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } cout << N - Count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; },Count integers up to N which can be represented as sum of two or more consecutive numbers.,"#include <bits/stdc++.h> 
 using namespace std ; void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } cout << N - Count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; }","['void countElements ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countElements ( int N ) {
"
620,Maximum difference between a pair of adjacent elements by excluding every element once | C ++ program for the above approach ; Function to calculate maximum difference between adjacent elements excluding every array element once ; Compute maximum adjacent difference for whole array ; Store the maximum between arr_max and curr_max ; Append the result into a vector ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; int arr_max = INT_MIN ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = max ( curr_max , arr_max ) ; res . push_back ( ans ) ; } for ( auto x : res ) cout << x << "" ▁ "" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }",Maximum difference between a pair of adjacent elements by excluding every element once.,"#include <bits/stdc++.h> 
 using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; int arr_max = INT_MIN ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = max ( curr_max , arr_max ) ; res . push_back ( ans ) ; } for ( auto x : res ) cout << x << "" ▁ "" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }","['void maxAdjacent ( int * arr , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maxAdjacent ( int * arr , int N ) {
"
621,Minimize increments required to make count of even and odd array elements equal | C ++ program for the above approach ; Function to find min operations to make even and odd count equal ; Odd size will never make odd and even counts equal ; Stores the count of even numbers in the array arr [ ] ; Stores count of odd numbers in the array arr [ ] ; Traverse the array arr [ ] ; If arr [ i ] is an even number ; Update cntEven ; Odd numbers in arr [ ] ; Return absolute difference divided by 2 ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { cout << "" - 1"" ; exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return abs ( cntEven - cntOdd ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumIncrement ( arr , N ) ; return 0 ; }",Minimize increments required to make count of even and odd array elements equal.,"#include <bits/stdc++.h> 
 using namespace std ; int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { cout << "" - 1"" ; exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return abs ( cntEven - cntOdd ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumIncrement ( arr , N ) ; return 0 ; }","['int minimumIncrement ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minimumIncrement ( int arr [ ] , int N ) {
"
622,"Count ways to construct array with even product from given array such that absolute difference of same indexed elements is at most 1 | C ++ program to implement the above approach ; Function to find count the ways to construct an array , B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 and product of elements of B [ ] is even ; Stores count of arrays B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 ; Stores count of arrays B [ ] whose product of elements is not even ; Traverse the array ; Update total ; If A [ i ] is an even number ; Update oddArray ; Print 3 ^ N - 2 ^ X ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray << "" STRNEWLINE "" ; } int main ( ) { int A [ ] = { 2 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cntWaysConsArray ( A , N ) ; return 0 ; }",Count ways to construct array with even product from given array such that absolute difference of same indexed elements is at most 1.,"#include <bits/stdc++.h> 
 using namespace std ; void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray << "" STRNEWLINE "" ; } int main ( ) { int A [ ] = { 2 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cntWaysConsArray ( A , N ) ; return 0 ; }","['void cntWaysConsArray ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void cntWaysConsArray ( int A [ ] , int N ) {
"
623,"Count numbers up to N whose rightmost set bit is K | C ++ program for the above approach ; Function to count the numbers in the range [ 1 , N ] whose rightmost set bit is K ; Stores the number whose rightmost set bit is K ; Numbers whose rightmost set bit is i ; Subtracting the number whose rightmost set bit is i , from N ; Since i = k , then the number whose rightmost set bit is K is stored ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } cout << numbers_rightmost_setbit_K ; } int main ( ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; return 0 ; }",Count numbers up to N whose rightmost set bit is K.,"#include <bits/stdc++.h> 
 using namespace std ; int countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } cout << numbers_rightmost_setbit_K ; } int main ( ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; return 0 ; }","['int countNumberHavingKthBitSet ( int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countNumberHavingKthBitSet ( int N , int K ) {
"
624,Count odd and even Binomial Coefficients of N | C ++ program for the above approach ; Function to count set bits in binary representation of number N ; Count set bits in N ; Return the final count ; Driver Code ; Print odd Binomial coefficients ; Print even Binomial coefficients,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; while ( N ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } int main ( ) { int N = 4 ; int bits = countSetBits ( N ) ; cout << "" Odd ▁ "" << "" : ▁ "" << pow ( 2 , bits ) << "" STRNEWLINE "" ; cout << "" Even ▁ "" << "" : ▁ "" << N + 1 - pow ( 2 , bits ) << "" STRNEWLINE "" ; return 0 ; }",Count odd and even Binomial Coefficients of N.,"#include <iostream> 
 #include <math.h> 
 using namespace std ; int countSetBits ( int N ) { int count = 0 ; while ( N ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } int main ( ) { int N = 4 ; int bits = countSetBits ( N ) ; cout << "" Odd ▁ "" << "" : ▁ "" << pow ( 2 , bits ) << "" STRNEWLINE "" ; cout << "" Even ▁ "" << "" : ▁ "" << N + 1 - pow ( 2 , bits ) << "" STRNEWLINE "" ; return 0 ; }","['int countSetBits ( int N ) {', 'int main ( ) {']","#include <iostream> 
 #include <math.h> 
 using namespace std ;
 int countSetBits ( int N ) {
"
625,Make all array elements even by replacing any pair of array elements with their sum | C ++ program for the above approach ; Function to find the minimum number of replacements required to make all array elements even ; Stores the count of odd elements ; Traverse the array ; Increase count of odd elements ; Store number of replacements required ; Two extra moves will be required to make the last odd element even ; Print the minimum replacements ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; cout << moves ; } int main ( ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minMoves ( arr , N ) ; return 0 ; }",Make all array elements even by replacing any pair of array elements with their sum.,"#include <bits/stdc++.h> 
 using namespace std ; void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; cout << moves ; } int main ( ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minMoves ( arr , N ) ; return 0 ; }","['void minMoves ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minMoves ( int arr [ ] , int N ) {
"
626,Split squares of first N natural numbers into two sets with minimum absolute difference of their sums | C ++ program for the above approach ; Function to partition squares of N natural number in two subset ; Store the count of blocks of size 8 ; Partition of block of 8 element ; Store the minimum subset difference ; Partition of N elements to minimize their subset sum difference ; Store elements of subset A and B ; If element is of type A ; If the element is of type B ; Print the minimum subset difference ; Print the first subset ; Print the second subset ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSubsetDifference ( int N ) { int blockOfSize8 = N / 8 ; string str = "" ABBABAAB "" ; int subsetDifference = 0 ; string partition = "" "" ; while ( blockOfSize8 -- ) { partition += str ; } vector < int > A , B ; for ( int i = 0 ; i < N ; i ++ ) { if ( partition [ i ] == ' A ' ) { A . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } else { B . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } } cout << subsetDifference << "" STRNEWLINE "" ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) cout << A [ i ] << "" ▁ "" ; cout << "" STRNEWLINE "" ; for ( int i = 0 ; i < B . size ( ) ; i ++ ) cout << B [ i ] << "" ▁ "" ; } int main ( ) { int N = 8 ; minimumSubsetDifference ( N ) ; return 0 ; }",Split squares of first N natural numbers into two sets with minimum absolute difference of their sums.,"#include <bits/stdc++.h> 
 using namespace std ; void minimumSubsetDifference ( int N ) { int blockOfSize8 = N / 8 ; string str = "" ABBABAAB "" ; int subsetDifference = 0 ; string partition = "" "" ; while ( blockOfSize8 -- ) { partition += str ; } vector < int > A , B ; for ( int i = 0 ; i < N ; i ++ ) { if ( partition [ i ] == ' A ' ) { A . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } else { B . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } } cout << subsetDifference << "" STRNEWLINE "" ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) cout << A [ i ] << "" ▁ "" ; cout << "" STRNEWLINE "" ; for ( int i = 0 ; i < B . size ( ) ; i ++ ) cout << B [ i ] << "" ▁ "" ; } int main ( ) { int N = 8 ; minimumSubsetDifference ( N ) ; return 0 ; }","['void minimumSubsetDifference ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minimumSubsetDifference ( int N ) {
"
627,Largest divisor of a number not divisible by another given number | C ++ program to implement the above approach ; Function to find the largest number X such that it divides P but is not divisible by Q ; Stores the frequency count of of all Prime Factors ; Increment the frequency of the current prime factor ; If Q is a prime factor ; Stores the desired result ; Iterate through all divisors of Q ; Stores the frequency count of current prime divisor on dividing P ; Count the frequency of the current prime factor ; If cur is less than frequency then P is the final result ; Iterate to get temporary answer ; Update current answer ; Print the desired result ; Driver Code ; Given P and Q ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTheGreatestX ( int P , int Q ) { map < int , int > divisiors ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 and Q > 1 ) { Q /= i ; divisiors [ i ] ++ ; } } if ( Q > 1 ) divisiors [ Q ] ++ ; int ans = 0 ; for ( auto i : divisiors ) { int frequency = i . second ; int temp = P ; int cur = 0 ; while ( temp % i . first == 0 ) { temp /= i . first ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . first ; } ans = max ( temp , ans ) ; } cout << ans ; } int main ( ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; return 0 ; }",Largest divisor of a number not divisible by another given number.,"#include <bits/stdc++.h> 
 using namespace std ; void findTheGreatestX ( int P , int Q ) { map < int , int > divisiors ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 and Q > 1 ) { Q /= i ; divisiors [ i ] ++ ; } } if ( Q > 1 ) divisiors [ Q ] ++ ; int ans = 0 ; for ( auto i : divisiors ) { int frequency = i . second ; int temp = P ; int cur = 0 ; while ( temp % i . first == 0 ) { temp /= i . first ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . first ; } ans = max ( temp , ans ) ; } cout << ans ; } int main ( ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; return 0 ; }","['void findTheGreatestX ( int P , int Q ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findTheGreatestX ( int P , int Q ) {
"
629,Maximize Bitwise AND of first element with complement of remaining elements for any permutation of given Array | C ++ Program to implement the above approach ; Function to maximize the value for the given function and the array elements ; Vector array to maintain which bit is set for which integer in the given array by saving index of that integer ; Check if j - th bit is set for i - th integer ; Push the index of that integer in setBit [ j ] ; Find the element having highest significant set bit unset in other elements ; Place that integer at 0 - th index ; Store the maximum AND value ; Return the answer ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size_int  32 NEW_LINE int functionMax ( int arr [ ] , int n ) { vector < int > setBit [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push_back ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << functionMax ( arr , n ) ; return 0 ; }",Maximize Bitwise AND of first element with complement of remaining elements for any permutation of given Array.,"#include <bits/stdc++.h> 
 using namespace std ; #define size_int  32 
 int functionMax ( int arr [ ] , int n ) { vector < int > setBit [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push_back ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << functionMax ( arr , n ) ; return 0 ; }","['int functionMax ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define size_int  32 
 int functionMax ( int arr [ ] , int n ) {
"
631,Fast Exponention using Bit Manipulation | C ++ Program to implement the above approach ; Function to return a ^ n ; Stores final answer ; Check if current LSB is set ; Right shift ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } int main ( ) { int a = 3 , n = 5 ; cout << powerOptimised ( a , n ) ; return 0 ; }",Fast Exponention using Bit Manipulation.,"#include <iostream> 
 using namespace std ; int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } int main ( ) { int a = 3 , n = 5 ; cout << powerOptimised ( a , n ) ; return 0 ; }","['int powerOptimised ( int a , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int powerOptimised ( int a , int n ) {
"
632,"Find M such that GCD of M and given number N is maximum | C ++ program for the above approach ; Function to find the integer M such that gcd ( N , M ) is maximum ; Initialize a variable ; Find all the divisors of N and return the maximum divisor ; Check if i is divisible by N ; Update max_gcd ; Return the maximum value ; Driver Code ; Given Number ; Function Call",#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } int main ( ) { int N = 10 ; cout << findMaximumGcd ( N ) ; return 0 ; },Find M such that GCD of M and given number N is maximum.,"#include <bits/stdc++.h> 
 using namespace std ; int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } int main ( ) { int N = 10 ; cout << findMaximumGcd ( N ) ; return 0 ; }","['int findMaximumGcd ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMaximumGcd ( int n ) {
"
634,"Product of Complex Numbers using three Multiplication Operation | C ++ program for the above approach ; Function to multiply Complex Numbers with just three multiplications ; Find value of prod1 , prod2 and prod3 ; Real Part ; Imaginary Part ; Print the result ; Driver Code ; Given four Numbers ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; cout << real << "" ▁ + ▁ "" << imag << "" i "" ; } int main ( ) { int a , b , c , d ; a = 2 ; b = 3 ; c = 4 ; d = 5 ; print_product ( a , b , c , d ) ; return 0 ; }",Product of Complex Numbers using three Multiplication Operation.,"#include <bits/stdc++.h> 
 using namespace std ; void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; cout << real << "" ▁ + ▁ "" << imag << "" i "" ; } int main ( ) { int a , b , c , d ; a = 2 ; b = 3 ; c = 4 ; d = 5 ; print_product ( a , b , c , d ) ; return 0 ; }","['void print_product ( int a , int b , int c , int d ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void print_product ( int a , int b , int c , int d ) {
"
635,Insolite Numbers | C ++ implementation for the above approach ; Function to check if a number is an Insolite numbers ; To store sum of squares of digits ; To store product of squares of digits ; extracting digit ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } int main ( ) { int N = 111 ; if ( isInsolite ( N ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Insolite Numbers.,"#include <bits/stdc++.h> 
 using namespace std ; bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } int main ( ) { int N = 111 ; if ( isInsolite ( N ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool isInsolite ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isInsolite ( int n ) {
"
637,D Numbers | C ++ implementation for the above approach ; Function to find the N - th icosikaipentagon number ; number should be greater than 3 ; Check every k in range 2 to n - 1 ; condition for D - Number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int isDNum ( int n ) { if ( n < 4 ) return false ; int numerator , hcf ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = pow ( k , n - 2 ) - k ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } int main ( ) { int n = 15 ; int a = isDNum ( n ) ; if ( a ) cout << "" Yes "" ; else cout << "" No "" ; }",D Numbers.,"#include <bits/stdc++.h> 
 using namespace std ; int isDNum ( int n ) { if ( n < 4 ) return false ; int numerator , hcf ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = pow ( k , n - 2 ) - k ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } int main ( ) { int n = 15 ; int a = isDNum ( n ) ; if ( a ) cout << "" Yes "" ; else cout << "" No "" ; }","['int isDNum ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int isDNum ( int n ) {
"
639,Maximize sum of absolute difference between adjacent elements in Array with sum K | C ++ program to maximize the sum of absolute differences between adjacent elements ; Function for maximizing the sum ; Difference is 0 when only one element is present in array ; Difference is K when two elements are present in array ; Otherwise ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } int main ( ) { int N = 6 ; int K = 11 ; cout << maxAdjacentDifference ( N , K ) ; return 0 ; }",Maximize sum of absolute difference between adjacent elements in Array with sum K.,"#include <bits/stdc++.h> 
 using namespace std ; int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } int main ( ) { int N = 6 ; int K = 11 ; cout << maxAdjacentDifference ( N , K ) ; return 0 ; }","['int maxAdjacentDifference ( int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxAdjacentDifference ( int N , int K ) {
"
642,Megagon number | C ++ implementation for the above approach ; Function to find the nth Megagon Number ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << MegagonNum ( n ) ; return 0 ; },Megagon number.,"#include <bits/stdc++.h> 
 using namespace std ; int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << MegagonNum ( n ) ; return 0 ; }","['int MegagonNum ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int MegagonNum ( int n ) {
"
643,Product of all the pairs from the given array | C ++ implementation to find the product of all the pairs from the given array ; Function to return the product of the elements of all possible pairs from the array ; To store the required product ; Nested loop to calculate all possible pairs ; Multiply the product of the elements of the current pair ; Return the final result ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }",Product of all the pairs from the given array.,"#include <bits/stdc++.h> 
 using namespace std ; #define mod  1000000007 
 int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }","['int productPairs ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define mod  1000000007 
 int productPairs ( int arr [ ] , int n ) {
"
645,Construct an Array such that cube sum of all element is a perfect square | C ++ program to construct an array that cube sum of all element is a perfect square ; Function to create and print the array ; initialise the array of size N ; Print the array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int N ) { int arr [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { int N = 6 ; constructArray ( N ) ; return 0 ; }",Construct an Array such that cube sum of all element is a perfect square.,"#include <bits/stdc++.h> 
 using namespace std ; void constructArray ( int N ) { int arr [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { int N = 6 ; constructArray ( N ) ; return 0 ; }","['void constructArray ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void constructArray ( int N ) {
"
647,Find K consecutive integers such that their sum is N | C ++ implementation to check if a number can be expressed as sum of K consecutive integer ; Function to check if a number can be expressed as the sum of k consecutive ; Finding the first term of AP ; Checking if first term is an integer ; Loop to print the K consecutive integers ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksum ( int n , int k ) { float first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ; if ( first_term - int ( first_term ) == 0 ) { for ( int i = first_term ; i <= first_term + k - 1 ; i ++ ) { cout << i << "" ▁ "" ; } } else cout << "" - 1"" ; } int main ( ) { int n = 33 , k = 6 ; checksum ( n , k ) ; return 0 ; }",Find K consecutive integers such that their sum is N.,"#include <bits/stdc++.h> 
 using namespace std ; void checksum ( int n , int k ) { float first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ; if ( first_term - int ( first_term ) == 0 ) { for ( int i = first_term ; i <= first_term + k - 1 ; i ++ ) { cout << i << "" ▁ "" ; } } else cout << "" - 1"" ; } int main ( ) { int n = 33 , k = 6 ; checksum ( n , k ) ; return 0 ; }","['void checksum ( int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void checksum ( int n , int k ) {
"
648,Represent N as sum of K even numbers | C ++ implementation to represent N as sum of K even numbers ; Function to print the representation ; N must be greater than equal to 2 * K and must be even ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << ""2 ▁ "" ; } cout << check ; } else { cout << "" - 1"" ; } } int main ( ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; return 0 ; }",Represent N as sum of K even numbers.,"#include <bits/stdc++.h> 
 using namespace std ; void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << ""2 ▁ "" ; } cout << check ; } else { cout << "" - 1"" ; } } int main ( ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; return 0 ; }","['void sumEvenNumbers ( int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void sumEvenNumbers ( int N , int K ) {
"
649,Count of contiguous subarrays possible for every index by including the element at that index | C ++ program to find the number of contiguous subarrays including the element at every index of the array of size N ; Function to find the number of subarrays including the element at every index of the array ; Creating an array of size N ; The loop is iterated till half the length of the array ; Condition to avoid overwriting the middle element for the array with even length . ; Computing the number of subarrays ; The ith element from the beginning and the ending have the same number of possible subarrays ; Function to print the vector ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > calculateWays ( int N ) { int x = 0 ; vector < int > v ; for ( int i = 0 ; i < N ; i ++ ) v . push_back ( 0 ) ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; } void printArray ( vector < int > v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << "" ▁ "" ; } int main ( ) { vector < int > v ; v = calculateWays ( 4 ) ; printArray ( v ) ; return 0 ; }",Count of contiguous subarrays possible for every index by including the element at that index.,"#include <bits/stdc++.h> 
 using namespace std ; vector < int > calculateWays ( int N ) { int x = 0 ; vector < int > v ; for ( int i = 0 ; i < N ; i ++ ) v . push_back ( 0 ) ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; } void printArray ( vector < int > v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << "" ▁ "" ; } int main ( ) { vector < int > v ; v = calculateWays ( 4 ) ; printArray ( v ) ; return 0 ; }","['void printArray ( vector < int > v ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 vector < int > calculateWays ( int N ) {
 int x = 0 ;
 vector < int > v ;
 for ( int i = 0 ;
 i < N ;
 i ++ ) v . push_back ( 0 ) ;
 for ( int i = 0 ;
 i <= N / 2 ;
 i ++ ) {
 if ( N % 2 == 0 && i == N / 2 ) break ;
 x = N * ( i + 1 ) - ( i + 1 ) * i ;
 v [ i ] = x ;
 v [ N - i - 1 ] = x ;
 } return v ;
 } void printArray ( vector < int > v ) {
"
651,Count the numbers which can convert N to 1 using given operation | C ++ program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Store all the divisors of N ; If i is a divisor ; If i is not equal to N / i ; Iterate through all the divisors of N - 1 and count them in answer ; Check if N - 1 is a divisor or not ; Iterate through all divisors and check for N mod d = 1 or ( N - 1 ) mod d = 0 ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int N ) { vector < int > div ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push_back ( i ) ; if ( N != i * i ) { div . push_back ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( auto d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; },Count the numbers which can convert N to 1 using given operation.,"#include <bits/stdc++.h> 
 using namespace std ; int countValues ( int N ) { vector < int > div ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push_back ( i ) ; if ( N != i * i ) { div . push_back ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( auto d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }","['int countValues ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countValues ( int N ) {
"
652,Maximum possible prime divisors that can exist in numbers having exactly N divisors | C ++ implementation to find the maximum possible prime divisor of a number can have N divisors ; Function to find the maximum possible prime divisors of a number can have with N divisors ; Number of time number divided by 2 ; Divide by other prime numbers ; If the last number of also prime then also include it ; Driver Code ; Function Call,"#include <iostream> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } } if ( n > 2 ) { max_possible_prime ++ ; } cout << max_possible_prime << "" STRNEWLINE "" ; } int main ( ) { int n = 4 ; findMaxPrimeDivisor ( n ) ; return 0 ; }",Maximum possible prime divisors that can exist in numbers having exactly N divisors.,"#include <iostream> 
 using namespace std ; #define ll  long long int 
 void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } } if ( n > 2 ) { max_possible_prime ++ ; } cout << max_possible_prime << "" STRNEWLINE "" ; } int main ( ) { int n = 4 ; findMaxPrimeDivisor ( n ) ; return 0 ; }","['void findMaxPrimeDivisor ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 #define ll  long long int 
 void findMaxPrimeDivisor ( int n ) {
"
653,Count ways to express a number as sum of exactly two numbers | C ++ program to Count ways to express a number as sum of two numbers . ; Function returns the count of ways express a number as sum of two numbers . ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; } int main ( ) { int N = 8 ; cout << CountWays ( N ) ; },Count ways to express a number as sum of exactly two numbers.,"#include <bits/stdc++.h> 
 using namespace std ; int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; } int main ( ) { int N = 8 ; cout << CountWays ( N ) ; }","['int CountWays ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int CountWays ( int n ) {
"
654,Divide array in two maximum equal length arrays of similar and dissimilar elements | C ++ program to find the max - size to which an array can be divided into 2 equal parts such that one part contains unique elements while another contains similar elements ; Function to find the max - size to which an array can be divided into 2 equal parts ; Vector to find the frequency of each element of array ; Find the maximum frequency element present in array arr [ ] ; Find total unique elements present in array arr [ ] ; Find the Max - Size to which an array arr [ ] can be splitted ; Find the first array containing same elements ; Find the second array containing unique elements ; Driver code ; initialise n ; array declaration ; size of array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void Solve ( int arr [ ] , int size , int n ) { vector < int > v ( n + 1 ) ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = ( max_element ( v . begin ( ) , v . end ( ) ) - v . begin ( ) ) ; int diff1 = n + 1 - count ( v . begin ( ) , v . end ( ) , 0 ) ; int max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) ; cout << "" Maximum ▁ size ▁ is ▁ : "" << max_size << "" STRNEWLINE "" ; cout << "" The ▁ First ▁ Array ▁ Is ▁ : ▁ STRNEWLINE "" ; for ( int i = 0 ; i < max_size ; i ++ ) { cout << max1 << "" ▁ "" ; v [ max1 ] -= 1 ; } cout << "" STRNEWLINE "" ; cout << "" The ▁ Second ▁ Array ▁ Is ▁ : ▁ STRNEWLINE "" ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { cout << i << "" ▁ "" ; max_size -- ; } if ( max_size < 1 ) break ; } cout << "" STRNEWLINE "" ; } int main ( ) { int n = 7 ; int arr [ ] = { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Solve ( arr , size , n ) ; return 0 ; }",Divide array in two maximum equal length arrays of similar and dissimilar elements.,"#include <bits/stdc++.h> 
 using namespace std ; void Solve ( int arr [ ] , int size , int n ) { vector < int > v ( n + 1 ) ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = ( max_element ( v . begin ( ) , v . end ( ) ) - v . begin ( ) ) ; int diff1 = n + 1 - count ( v . begin ( ) , v . end ( ) , 0 ) ; int max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) ; cout << "" Maximum ▁ size ▁ is ▁ : "" << max_size << "" STRNEWLINE "" ; cout << "" The ▁ First ▁ Array ▁ Is ▁ : ▁ STRNEWLINE "" ; for ( int i = 0 ; i < max_size ; i ++ ) { cout << max1 << "" ▁ "" ; v [ max1 ] -= 1 ; } cout << "" STRNEWLINE "" ; cout << "" The ▁ Second ▁ Array ▁ Is ▁ : ▁ STRNEWLINE "" ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { cout << i << "" ▁ "" ; max_size -- ; } if ( max_size < 1 ) break ; } cout << "" STRNEWLINE "" ; } int main ( ) { int n = 7 ; int arr [ ] = { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Solve ( arr , size , n ) ; return 0 ; }","['void Solve ( int arr [ ] , int size , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void Solve ( int arr [ ] , int size , int n ) {
"
658,"Largest number in given Array formed by repeatedly combining two same elements | C ++ implementation of the above approach ; Function to return the largest sum ; Variable to store the largest sum ; Map to store the frequencies of each element ; Store the Frequencies ; Loop to combine duplicate elements and update the sum in the map ; If j is a duplicate element ; Update the frequency of 2 * j ; If the new sum is greater than maximum value , Update the maximum ; Returns the largest sum ; Driver Code ; Function Calling","#include <bits/stdc++.h> NEW_LINE using namespace std ; int largest_sum ( int arr [ ] , int n ) { int maximum = -1 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { if ( j . second > 1 ) { m [ 2 * j . first ] = m [ 2 * j . first ] + j . second / 2 ; if ( 2 * j . first > maximum ) maximum = 2 * j . first ; } } return maximum ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest_sum ( arr , n ) ; return 0 ; }",Largest number in given Array formed by repeatedly combining two same elements.,"#include <bits/stdc++.h> 
 using namespace std ; int largest_sum ( int arr [ ] , int n ) { int maximum = -1 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { if ( j . second > 1 ) { m [ 2 * j . first ] = m [ 2 * j . first ] + j . second / 2 ; if ( 2 * j . first > maximum ) maximum = 2 * j . first ; } } return maximum ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest_sum ( arr , n ) ; return 0 ; }","['int largest_sum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int largest_sum ( int arr [ ] , int n ) {
"
659,Check if it is possible to make x and y zero at same time with given operation | C ++ program of the above approach ; Function to check if it is possible to make x and y can become 0 at same time ; Check the given conditions ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBeReduced ( int x , int y ) { int maxi = max ( x , y ) ; int mini = min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; } int main ( ) { int x = 6 , y = 9 ; canBeReduced ( x , y ) ; return 0 ; }",Check if it is possible to make x and y zero at same time with given operation.,"#include <bits/stdc++.h> 
 using namespace std ; void canBeReduced ( int x , int y ) { int maxi = max ( x , y ) ; int mini = min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; } int main ( ) { int x = 6 , y = 9 ; canBeReduced ( x , y ) ; return 0 ; }","['void canBeReduced ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void canBeReduced ( int x , int y ) {
"
660,"Wheel Factorization Algorithm | C ++ program to check if the given number is prime using Wheel Factorization Method ; Function to check if a given number x is prime or not ; The Wheel for checking prime number ; Base Case ; Check for the number taken as basis ; Check for Wheel Here i , acts as the layer of the wheel ; Check for the list of Sieve in arr [ ] ; If number is greater than sqrt ( N ) break ; Check if N is a multiple of prime number in the wheel ; If at any iteration isPrime is false , break from the loop ; Driver 's Code ; Function call for primality check","#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; void isPrime ( int N ) { bool isPrime = true ; int arr [ 8 ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) cout << "" Prime ▁ Number "" ; else cout << "" Not ▁ a ▁ Prime ▁ Number "" ; } int main ( ) { int N = 121 ; isPrime ( N ) ; return 0 ; }",Wheel Factorization Algorithm.,"#include "" bits / stdc + + . h "" 
 using namespace std ; void isPrime ( int N ) { bool isPrime = true ; int arr [ 8 ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) cout << "" Prime ▁ Number "" ; else cout << "" Not ▁ a ▁ Prime ▁ Number "" ; } int main ( ) { int N = 121 ; isPrime ( N ) ; return 0 ; }","['void isPrime ( int N ) {', 'int main ( ) {']","#include "" bits / stdc + + . h "" 
 using namespace std ;
 void isPrime ( int N ) {
"
661,Find all Pairs possible from the given Array | C ++ implementation to find all Pairs possible from the given Array ; Function to print all possible pairs from the array ; Nested loop for all possible pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << "" ( "" << arr [ i ] << "" , ▁ "" << arr [ j ] << "" ) "" << "" , ▁ "" ; } } } int main ( ) { int arr [ ] = { 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPairs ( arr , n ) ; return 0 ; }",Find all Pairs possible from the given Array.,"#include <bits/stdc++.h> 
 using namespace std ; void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << "" ( "" << arr [ i ] << "" , ▁ "" << arr [ j ] << "" ) "" << "" , ▁ "" ; } } } int main ( ) { int arr [ ] = { 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPairs ( arr , n ) ; return 0 ; }","['void printPairs ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printPairs ( int arr [ ] , int n ) {
"
663,Least number to be added to or subtracted from N to make it a Perfect Cube | C ++ implementation of the approach ; Function to return the Least number ; Get the perfect cube before and after N ; Check which is nearest to N ; return the result ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevCube = cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ; int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ; return ans ; } int main ( ) { int n = 25 ; cout << nearest ( n ) << endl ; n = 27 ; cout << nearest ( n ) << endl ; n = 40 ; cout << nearest ( n ) << endl ; return 0 ; },Least number to be added to or subtracted from N to make it a Perfect Cube.,"#include <bits/stdc++.h> 
 using namespace std ; int nearest ( int n ) { int prevCube = cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ; int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ; return ans ; } int main ( ) { int n = 25 ; cout << nearest ( n ) << endl ; n = 27 ; cout << nearest ( n ) << endl ; n = 40 ; cout << nearest ( n ) << endl ; return 0 ; }","['int nearest ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int nearest ( int n ) {
"
664,Check if a circle lies inside another circle or not | C ++ program to check if one circle lies inside another circle or not . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) cout << "" The ▁ smaller ▁ circle ▁ lies ▁ completely "" << "" ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ "" << "" touching ▁ each ▁ other ▁ "" << "" at ▁ a ▁ point ▁ of ▁ circumference . ▁ "" << endl ; else if ( distSq + r2 < r1 ) cout << "" The ▁ smaller ▁ circle ▁ lies ▁ completely "" << "" ▁ inside ▁ the ▁ bigger ▁ circle ▁ without "" << "" ▁ touching ▁ each ▁ other ▁ "" << "" at ▁ a ▁ point ▁ of ▁ circumference . ▁ "" << endl ; else cout << "" The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside "" << "" ▁ the ▁ bigger ▁ circle ▁ completely . "" << endl ; } int main ( ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; return 0 ; }",Check if a circle lies inside another circle or not.,"#include <bits/stdc++.h> 
 using namespace std ; void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) cout << "" The ▁ smaller ▁ circle ▁ lies ▁ completely "" << "" ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ "" << "" touching ▁ each ▁ other ▁ "" << "" at ▁ a ▁ point ▁ of ▁ circumference . ▁ "" << endl ; else if ( distSq + r2 < r1 ) cout << "" The ▁ smaller ▁ circle ▁ lies ▁ completely "" << "" ▁ inside ▁ the ▁ bigger ▁ circle ▁ without "" << "" ▁ touching ▁ each ▁ other ▁ "" << "" at ▁ a ▁ point ▁ of ▁ circumference . ▁ "" << endl ; else cout << "" The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside "" << "" ▁ the ▁ bigger ▁ circle ▁ completely . "" << endl ; } int main ( ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; return 0 ; }","['void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) {
"
665,Length of direct common tangent between two intersecting Circles | C ++ program to find the length of the direct common tangent between two circles which intersect each other ; Function to find the length of the direct common tangent ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << "" The ▁ length ▁ of ▁ the ▁ direct "" << "" ▁ common ▁ tangent ▁ is ▁ "" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; return 0 ; }",Length of direct common tangent between two intersecting Circles.,"#include <bits/stdc++.h> 
 using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << "" The ▁ length ▁ of ▁ the ▁ direct "" << "" ▁ common ▁ tangent ▁ is ▁ "" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; return 0 ; }","['void lengtang ( double r1 , double r2 , double d ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void lengtang ( double r1 , double r2 , double d ) {
"
666,Radius of the circle when the width and height of an arc is given | C ++ program to find radius of the circle when the width and height of an arc is given ; Function to find the radius ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void rad ( double d , double h ) { cout << "" The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ "" << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; } int main ( ) { double d = 4 , h = 1 ; rad ( d , h ) ; return 0 ; }",Radius of the circle when the width and height of an arc is given.,"#include <bits/stdc++.h> 
 using namespace std ; void rad ( double d , double h ) { cout << "" The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ "" << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; } int main ( ) { double d = 4 , h = 1 ; rad ( d , h ) ; return 0 ; }","['void rad ( double d , double h ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void rad ( double d , double h ) {
"
667,Shortest distance from the centre of a circle to a chord | C ++ program to find the shortest distance from chord to the centre of circle ; Function to find the shortest distance ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void shortdis ( double r , double d ) { cout << "" The ▁ shortest ▁ distance ▁ "" << "" from ▁ the ▁ chord ▁ to ▁ centre ▁ "" << sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) << endl ; } int main ( ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; return 0 ; }",Shortest distance from the centre of a circle to a chord.,"#include <bits/stdc++.h> 
 using namespace std ; void shortdis ( double r , double d ) { cout << "" The ▁ shortest ▁ distance ▁ "" << "" from ▁ the ▁ chord ▁ to ▁ centre ▁ "" << sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) << endl ; } int main ( ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; return 0 ; }","['void shortdis ( double r , double d ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void shortdis ( double r , double d ) {
"
668,Length of direct common tangent between the two non | C ++ program to find the length of the direct common tangent between two circles which donot touch each other ; Function to find the length of the direct common tangent ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << "" The ▁ length ▁ of ▁ the ▁ direct "" << "" ▁ common ▁ tangent ▁ is ▁ "" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; return 0 ; }",Length of direct common tangent between the two non.,"#include <bits/stdc++.h> 
 using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << "" The ▁ length ▁ of ▁ the ▁ direct "" << "" ▁ common ▁ tangent ▁ is ▁ "" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; return 0 ; }","['void lengtang ( double r1 , double r2 , double d ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void lengtang ( double r1 , double r2 , double d ) {
"
669,Biggest Square that can be inscribed within an Equilateral triangle | C ++ Program to find the biggest square which can be inscribed within the equilateral triangle ; Function to find the side of the square ; the side cannot be negative ; side of the square ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; } int main ( ) { float a = 5 ; cout << square ( a ) << endl ; return 0 ; },Biggest Square that can be inscribed within an Equilateral triangle.,"#include <bits/stdc++.h> 
 using namespace std ; float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; } int main ( ) { float a = 5 ; cout << square ( a ) << endl ; return 0 ; }","['float square ( float a ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float square ( float a ) {
"
670,Apothem of a n | C ++ Program to find the apothem of a regular polygon with given side length ; Function to find the apothem of a regular polygon ; Side and side length cannot be negative ; Degree converted to radians ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; } int main ( ) { float a = 9 , n = 6 ; cout << polyapothem ( n , a ) << endl ; return 0 ; }",Apothem of a n.,"#include <bits/stdc++.h> 
 using namespace std ; float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; } int main ( ) { float a = 9 , n = 6 ; cout << polyapothem ( n , a ) << endl ; return 0 ; }","['float polyapothem ( float n , float a ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float polyapothem ( float n , float a ) {
"
671,Area of a n | C ++ Program to find the area of a regular polygon with given side length ; Function to find the area of a regular polygon ; Side and side length cannot be negative ; Area degree converted to radians ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } int main ( ) { float a = 9 , n = 6 ; cout << polyarea ( n , a ) << endl ; return 0 ; }",Area of a n.,"#include <bits/stdc++.h> 
 using namespace std ; float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } int main ( ) { float a = 9 , n = 6 ; cout << polyarea ( n , a ) << endl ; return 0 ; }","['float polyarea ( float n , float a ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float polyarea ( float n , float a ) {
"
672,Side of a regular n | C ++ implementation of the approach ; Function to calculate the side of the polygon circumscribed in a circle ; Driver Code ; Total sides of the polygon ; Radius of the circumscribing circle,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateSide ( float n , float r ) { float theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; } int main ( ) { float n = 3 ; float r = 5 ; cout << calculateSide ( n , r ) ; }",Side of a regular n.,"#include <bits/stdc++.h> 
 using namespace std ; float calculateSide ( float n , float r ) { float theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; } int main ( ) { float n = 3 ; float r = 5 ; cout << calculateSide ( n , r ) ; }","['float calculateSide ( float n , float r ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float calculateSide ( float n , float r ) {
"
673,Largest right circular cylinder within a frustum | C ++ Program to find the biggest right circular cylinder that can be fit within a frustum ; Function to find the biggest right circular cylinder ; radii and height cannot be negative ; radius of right circular cylinder ; height of right circular cylinder ; volume of right circular cylinder ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return -1 ; float r1 = r ; float h1 = h ; float V = 3.14 * pow ( r1 , 2 ) * h1 ; return V ; } int main ( ) { float r = 7 , R = 11 , h = 6 ; cout << cyl ( r , R , h ) << endl ; return 0 ; }",Largest right circular cylinder within a frustum.,"#include <bits/stdc++.h> 
 using namespace std ; float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return -1 ; float r1 = r ; float h1 = h ; float V = 3.14 * pow ( r1 , 2 ) * h1 ; return V ; } int main ( ) { float r = 7 , R = 11 , h = 6 ; cout << cyl ( r , R , h ) << endl ; return 0 ; }","['float cyl ( float r , float R , float h ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float cyl ( float r , float R , float h ) {
"
674,Program to find the Perimeter of a Regular Polygon | C ++ program to find the perimeter of a regular polygon ; Function to calculate the perimeter ; Calculate Perimeter ; driver code ; Get the number of sides ; Get the length of side ; find perimeter,"#include <iostream> NEW_LINE using namespace std ; float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; } int main ( ) { int n = 5 ; float s = 2.5 , peri ; peri = Perimeter ( s , n ) ; cout << "" Perimeter ▁ of ▁ Regular ▁ Polygon "" << "" ▁ with ▁ "" << n << "" ▁ sides ▁ of ▁ length ▁ "" << s << "" ▁ = ▁ "" << peri << endl ; return 0 ; }",Program to find the Perimeter of a Regular Polygon.,"#include <iostream> 
 using namespace std ; float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; } int main ( ) { int n = 5 ; float s = 2.5 , peri ; peri = Perimeter ( s , n ) ; cout << "" Perimeter ▁ of ▁ Regular ▁ Polygon "" << "" ▁ with ▁ "" << n << "" ▁ sides ▁ of ▁ length ▁ "" << s << "" ▁ = ▁ "" << peri << endl ; return 0 ; }","['float Perimeter ( float s , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 float Perimeter ( float s , int n ) {
"
675,Area of the biggest possible rhombus that can be inscribed in a rectangle | C ++ Program to find the biggest rhombus which can be inscribed within the rectangle ; Function to find the area of the biggest rhombus ; the length and breadth cannot be negative ; area of the rhombus ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; return ( l * b ) / 2 ; } int main ( ) { float l = 16 , b = 6 ; cout << rhombusarea ( l , b ) << endl ; return 0 ; }",Area of the biggest possible rhombus that can be inscribed in a rectangle.,"#include <bits/stdc++.h> 
 using namespace std ; float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; return ( l * b ) / 2 ; } int main ( ) { float l = 16 , b = 6 ; cout << rhombusarea ( l , b ) << endl ; return 0 ; }","['float rhombusarea ( float l , float b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float rhombusarea ( float l , float b ) {
"
676,Check if a point lies inside a rectangle | Set | CPP program to Check if a point lies on or inside a rectangle | Set - 2 ; function to find if given point lies inside a given rectangle or not . ; Driver code ; bottom - left and top - right corners of rectangle ; given point ; function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if a point lies inside a rectangle.,"#include <bits/stdc++.h> 
 using namespace std ; bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) {
"
677,Distance between a point and a Plane in 3 D | C ++ program to find the Perpendicular ( shortest ) distance between a point and a Plane in 3 D . ; Function to find distance ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << "" Perpendicular ▁ distance ▁ is ▁ "" << ( d / e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; }",Distance between a point and a Plane in 3 D.,"#include <bits/stdc++.h> 
 #include <math.h> 
 using namespace std ; void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << "" Perpendicular ▁ distance ▁ is ▁ "" << ( d / e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; }","['void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <math.h> 
 using namespace std ;
 void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) {
"
678,Program to find the Volume of a Triangular Prism | CPP program to find the volume of the triangular prism ; function to find the Volume of triangular prism ; formula to find Volume ; Driver Code ; function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } int main ( ) { float l = 18 , b = 12 , h = 9 ; cout << "" Volume ▁ of ▁ triangular ▁ prism : ▁ "" << findVolume ( l , b , h ) ; return 0 ; }",Program to find the Volume of a Triangular Prism.,"#include <bits/stdc++.h> 
 using namespace std ; float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } int main ( ) { float l = 18 , b = 12 , h = 9 ; cout << "" Volume ▁ of ▁ triangular ▁ prism : ▁ "" << findVolume ( l , b , h ) ; return 0 ; }","['float findVolume ( float l , float b , float h ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float findVolume ( float l , float b , float h ) {
"
679,Check if given four integers ( or sides ) make rectangle | A simple program to find if given 4 values can represent 4 sides of rectangle ; Function to check if the given integers value make a rectangle ; Square is also a rectangle ; Driver code,"#include <iostream> NEW_LINE using namespace std ; bool isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } int main ( ) { int a , b , c , d ; a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if given four integers ( or sides ) make rectangle.,"#include <iostream> 
 using namespace std ; bool isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } int main ( ) { int a , b , c , d ; a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool isRectangle ( int a , int b , int c , int d ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 bool isRectangle ( int a , int b , int c , int d ) {
"
680,Program to find the mid | C ++ program to find the midpoint of a line ; function to find the midpoint of a line ; Driver Function to test above,"#include <iostream> NEW_LINE using namespace std ; void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << "" ▁ , ▁ "" << ( float ) ( y1 + y2 ) / 2 ; } int main ( ) { int x1 = -1 , y1 = 2 ; int x2 = 3 , y2 = -6 ; midpoint ( x1 , x2 , y1 , y2 ) ; return 0 ; }",Program to find the mid.,"#include <iostream> 
 using namespace std ; void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << "" ▁ , ▁ "" << ( float ) ( y1 + y2 ) / 2 ; } int main ( ) { int x1 = -1 , y1 = 2 ; int x2 = 3 , y2 = -6 ; midpoint ( x1 , x2 , y1 , y2 ) ; return 0 ; }","['void midpoint ( int x1 , int x2 , int y1 , int y2 ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void midpoint ( int x1 , int x2 , int y1 , int y2 ) {
"
681,Arc length from given Angle | C ++ program to calculate length of an arc ; function to calculate arc length ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << "" Angle ▁ cannot "" , "" ▁ be ▁ formed "" ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } int main ( ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; cout << ( arc_len ) ; return 0 ; }",Arc length from given Angle.,"#include <iostream> 
 using namespace std ; double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << "" Angle ▁ cannot "" , "" ▁ be ▁ formed "" ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } int main ( ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; cout << ( arc_len ) ; return 0 ; }","['double arcLength ( double diameter , double angle ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 double arcLength ( double diameter , double angle ) {
"
682,"Check if a line touches or intersects a circle | CPP program to check if a line touches or intersects or outside a circle . ; Finding the distance of line from center . ; Checking if the distance is less than , greater than or equal to radius . ; Driven Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << "" Touch "" << endl ; else if ( radius > dist ) cout << "" Intersect "" << endl ; else cout << "" Outside "" << endl ; } int main ( ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; return 0 ; }",Check if a line touches or intersects a circle.,"#include <bits/stdc++.h> 
 using namespace std ; void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << "" Touch "" << endl ; else if ( radius > dist ) cout << "" Intersect "" << endl ; else cout << "" Outside "" << endl ; } int main ( ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; return 0 ; }","['void checkCollision ( int a , int b , int c , int x , int y , int radius ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void checkCollision ( int a , int b , int c , int x , int y , int radius ) {
"
684,"Program to find area of a triangle | C ++ program to evaluate area of a polygon using shoelace formula ; ( X [ i ] , Y [ i ] ) are coordinates of i 'th point. ; Initialize area ; Calculate value of shoelace formula ; j = i ; j is previous vertex to i ; Return absolute value ; Driver program to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygonArea ( X , Y , n ) ; }",Program to find area of a triangle.,"#include <bits/stdc++.h> 
 using namespace std ; double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygonArea ( X , Y , n ) ; }","['double polygonArea ( double X [ ] , double Y [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double polygonArea ( double X [ ] , double Y [ ] , int n ) {
"
686,Count of subsequences having odd Bitwise AND values in the given array | C ++ program for the above approach ; Function to find count of subsequences having odd bitwise AND value ; Stores count of odd elements ; Traverse the array arr [ ] ; If x is odd increment count ; Return Answer ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequences ( vector < int > arr ) { int odd = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } int main ( ) { vector < int > arr = { 1 , 3 , 3 } ; cout << countSubsequences ( arr ) ; return 0 ; }",Count of subsequences having odd Bitwise AND values in the given array.,"#include <bits/stdc++.h> 
 using namespace std ; int countSubsequences ( vector < int > arr ) { int odd = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } int main ( ) { vector < int > arr = { 1 , 3 , 3 } ; cout << countSubsequences ( arr ) ; return 0 ; }","['int countSubsequences ( vector < int > arr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countSubsequences ( vector < int > arr ) {
"
687,"Count pairs from an array with absolute difference not less than the minimum element in the pair | C ++ program for the above approach ; Function to find the number of pairs ( i , j ) such that abs ( a [ i ] - a [ j ] ) is at least the minimum of ( a [ i ] , a [ j ] ) ; Stores the resultant count of pairs ; Iterate over the range [ 0 , n ] ; Iterate from arr [ i ] - ( i % arr [ i ] ) till n with an increment of arr [ i ] ; Count the possible pairs ; Return the total count ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPairsCount ( arr , N ) ; return 0 ; }",Count pairs from an array with absolute difference not less than the minimum element in the pair.,"#include <bits/stdc++.h> 
 using namespace std ; int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPairsCount ( arr , N ) ; return 0 ; }","['int getPairsCount ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getPairsCount ( int arr [ ] , int n ) {
"
688,Minimum steps to change N to 1 by changing it to 2 * N or N / 10 at any step | C ++ program for the above approach ; Function to check if N can be changed to 1 or not . ; Count the number of 2 in the prime factorisation of N ; Count the number of 5 in the prime factorisation of N ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { cout << 2 * fives - twos ; } else { cout << -1 ; } } int main ( ) { int N = 50 ; check ( N ) ; return 0 ; }",Minimum steps to change N to 1 by changing it to 2 * N or N / 10 at any step.,"#include <bits/stdc++.h> 
 using namespace std ; void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { cout << 2 * fives - twos ; } else { cout << -1 ; } } int main ( ) { int N = 50 ; check ( N ) ; return 0 ; }","['void check ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void check ( int N ) {
"
689,Sum of elements in given range from Array formed by infinitely concatenating given array | C ++ program for the above approach ; Function to find the sum of elements in a given range of an infinite array ; Stores the sum of array elements from L to R ; Traverse from L to R ; Print the resultant sum ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }",Sum of elements in given range from Array formed by infinitely concatenating given array.,"#include <bits/stdc++.h> 
 using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }","['void rangeSum ( int arr [ ] , int N , int L , int R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void rangeSum ( int arr [ ] , int N , int L , int R ) {
"
690,Sum of elements in given range from Array formed by infinitely concatenating given array | C ++ program for the above approach ; Function to find the sum of elements in a given range of an infinite array ; Stores the prefix sum ; Calculate the prefix sum ; Stores the sum of elements from 1 to L - 1 ; Stores the sum of elements from 1 to R ; Print the resultant sum ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; cout << rightsum - leftsum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }",Sum of elements in given range from Array formed by infinitely concatenating given array.,"#include <bits/stdc++.h> 
 using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; cout << rightsum - leftsum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }","['void rangeSum ( int arr [ ] , int N , int L , int R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void rangeSum ( int arr [ ] , int N , int L , int R ) {
"
691,"Exponential factorial of N | C ++ program for the above approach ; Function to find exponential factorial of a given number ; Stores the exponetial factor of N ; Iterare over the range [ 2 , N ] ; Update res ; Return res ; Driver Code ; Input ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) pow ( i , res ) % mod ; return res ; } int main ( ) { int N = 4 ; cout << ( ExpoFactorial ( N ) ) ;",Exponential factorial of N.,"#include <bits/stdc++.h> 
 using namespace std ; int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) pow ( i , res ) % mod ; return res ; } int main ( ) { int N = 4 ; cout << ( ExpoFactorial ( N ) ) ;","['int ExpoFactorial ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int ExpoFactorial ( int N ) {
"
692,"Maximum subarray sum in an array created after repeated concatenation | Set | C ++ program for the above approach ; Function to find contiguous subarray with maximum sum if array is repeated K times ; Store the sum of the array arr [ ] ; Traverse the array and find sum ; Store the answer ; If K = 1 ; Apply Kadane algorithm to find sum ; Return the answer ; Stores the twice repeated array ; Traverse the range [ 0 , 2 * N ] ; Stores the maximum suffix sum ; Stores the maximum prefix sum ; Apply Kadane algorithm for 2 repetition of the array ; If the sum of the array is greater than 0 ; Return the answer ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = max ( arr [ i ] , curr + arr [ i ] ) ; ans = max ( ans , curr ) ; } return ans ; } vector < int > V ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . push_back ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = max ( V [ i ] , curr + V [ i ] ) ; ans = max ( ans , curr ) ; } if ( sum > 0 ) { int temp = 1LL * sum * ( K - 2 ) ; ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 10 , 20 , -30 , -1 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 10 ; cout << maxSubArraySumRepeated ( arr , N , K ) ; return 0 ; }",Maximum subarray sum in an array created after repeated concatenation.,"#include <bits/stdc++.h> 
 using namespace std ; int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = max ( arr [ i ] , curr + arr [ i ] ) ; ans = max ( ans , curr ) ; } return ans ; } vector < int > V ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . push_back ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = max ( V [ i ] , curr + V [ i ] ) ; ans = max ( ans , curr ) ; } if ( sum > 0 ) { int temp = 1LL * sum * ( K - 2 ) ; ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 10 , 20 , -30 , -1 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 10 ; cout << maxSubArraySumRepeated ( arr , N , K ) ; return 0 ; }","['int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) {
"
693,"Count of subarrays with largest element at least twice the largest of remaining elements | C ++ program for the above approach ; Function to find count of subarrays which have max element greater than twice maximum of all other elements ; Stores the count of subarrays ; Generate all possible subarrays ; Stores the maximum element of the subarray ; Stores the maximum of all other elements ; Find the maximum element in the subarray [ i , j ] ; Find the maximum of all other elements ; If the maximum of subarray is greater than twice the maximum of other elements ; Print the maximum value obtained ; Driver Code","#include <iostream> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }",Count of subarrays with largest element at least twice the largest of remaining elements.,"#include <iostream> 
 using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }","['void countSubarray ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void countSubarray ( int arr [ ] , int n ) {
"
694,Count of subarrays with largest element at least twice the largest of remaining elements | C ++ program for the above approach ; Function to find count of subarrays which have max element greater than twice maximum of all other elements ; Stores the maximum element of the array ; Traverse the given array ; If the value of 2 * arr [ i ] is greater than mx ; Update the value of L and break out of loop ; If the value 2 * arr [ i ] is greater than mx ; Update the value of R and break out of loop ; Print the final answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 , L = 0 , R = 0 ; int mx = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } cout << ( L + 1 ) * ( n - R ) ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }",Count of subarrays with largest element at least twice the largest of remaining elements.,"#include <bits/stdc++.h> 
 using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 , L = 0 , R = 0 ; int mx = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } cout << ( L + 1 ) * ( n - R ) ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }","['void countSubarray ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void countSubarray ( int arr [ ] , int n ) {
"
696,"Kth smallest element in an array that contains A [ i ] exactly B [ i ] times | C ++ program for the above approach ; Function to find the Kth smallest element that contains A [ i ] exactly B [ i ] times ; Traverse the given array ; Stores the frequency of every elements ; Traverse the given array ; Initialize a variable to store the prefix sums ; Iterate over the range [ 0 , M ] ; Increment sum by freq [ i ] ; If sum is greater than or equal to K ; Return the current element as answer ; Return - 1 ; Driver Code ; Given Input ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( A [ i ] , M ) ; } int freq [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return -1 ; } int main ( ) { int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 4 ; cout << KthSmallest ( A , B , N , K ) ; return 0 ; }",Kth smallest element in an array that contains A [ i ] exactly B [ i ] times.,"#include <bits/stdc++.h> 
 using namespace std ; int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( A [ i ] , M ) ; } int freq [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return -1 ; } int main ( ) { int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 4 ; cout << KthSmallest ( A , B , N , K ) ; return 0 ; }","['int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) {
"
697,Bitwise OR of Bitwise AND of all subarrays of an array | C ++ program for the above approach ; Function to find the Bitwise OR of Bitwise AND of all subarrays ; Stores the required result ; Generate all the subarrays ; Store the current element ; Find the Bitwise OR ; Update the result ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }",Bitwise OR of Bitwise AND of all subarrays of an array.,"#include <bits/stdc++.h> 
 using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }","['void findbitwiseOR ( int * a , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findbitwiseOR ( int * a , int n ) {
"
698,Bitwise OR of Bitwise AND of all subarrays of an array | C ++ program for the above approach ; Function to find the Bitwise OR of Bitwise AND of all consecutive subsets of the array ; Stores the required result ; Traverse the given array ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }",Bitwise OR of Bitwise AND of all subarrays of an array.,"#include <bits/stdc++.h> 
 using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }","['void findbitwiseOR ( int * a , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findbitwiseOR ( int * a , int n ) {
"
699,Check if sum of digits of a number exceeds the product of digits of that number | C ++ program for the above approach ; Function to check if the sum of the digits of N is strictly greater than the product of the digits of N or not ; Stores the sum and the product of the digits of N ; Stores the last digit if N ; Increment the value of sumOfDigits ; Update the prodOfDigit ; Divide N by 10 ; Print the result ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int N = 1234 ; check ( N ) ; return 0 ; }",Check if sum of digits of a number exceeds the product of digits of that number.,"#include <iostream> 
 using namespace std ; void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int N = 1234 ; check ( N ) ; return 0 ; }","['void check ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void check ( int n ) {
"
700,Print all distinct even and odd prefix Bitwise XORs of first N natural numbers | C ++ program for the above approach ; Print all distinct even & odd prefix Bitwise XORs from 1 to N ; Print the even number ; Print the odd number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenOddBitwiseXOR ( int N ) { cout << "" Even : ▁ "" << 0 << "" ▁ "" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i << "" ▁ "" ; } cout << "" STRNEWLINE "" ; cout << "" Odd : ▁ "" << 1 << "" ▁ "" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i - 1 << "" ▁ "" ; } if ( N % 4 == 2 ) cout << N + 1 ; else if ( N % 4 == 3 ) cout << N ; } int main ( ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; return 0 ; }",Print all distinct even and odd prefix Bitwise XORs of first N natural numbers.,"#include <bits/stdc++.h> 
 using namespace std ; void evenOddBitwiseXOR ( int N ) { cout << "" Even : ▁ "" << 0 << "" ▁ "" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i << "" ▁ "" ; } cout << "" STRNEWLINE "" ; cout << "" Odd : ▁ "" << 1 << "" ▁ "" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i - 1 << "" ▁ "" ; } if ( N % 4 == 2 ) cout << N + 1 ; else if ( N % 4 == 3 ) cout << N ; } int main ( ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; return 0 ; }","['void evenOddBitwiseXOR ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void evenOddBitwiseXOR ( int N ) {
"
701,Lexicographically largest permutation possible by a swap that is smaller than a given array | C ++ program for the above approach ; Function to lexicographic largest permutation possible by a swap that is smaller than given array ; Find the index of first element such that arr [ i ] > arr [ i + 1 ] ; If the array is sorted in increasing order ; Find the index of first element which is smaller than arr [ i ] ; If arr [ j ] = = arr [ j - 1 ] ; Decrement j ; Swap the element ; Print the array arr [ ] ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == -1 ) { cout << "" - 1"" ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } swap ( arr [ i ] , arr [ j ] ) ; for ( auto & it : arr ) { cout << it << ' ▁ ' ; } } int main ( ) { vector < int > arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; return 0 ; }",Lexicographically largest permutation possible by a swap that is smaller than a given array.,"#include <bits/stdc++.h> 
 using namespace std ; void findPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == -1 ) { cout << "" - 1"" ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } swap ( arr [ i ] , arr [ j ] ) ; for ( auto & it : arr ) { cout << it << ' ▁ ' ; } } int main ( ) { vector < int > arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; return 0 ; }","['void findPermutation ( vector < int > & arr ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findPermutation ( vector < int > & arr ) {
"
703,Calculate Median from given values of Mean and Mode | C ++ program for the above approach ; Function to find the median of a group of data with given mean and mode ; Calculate the median ; Print the median ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; } int main ( ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; return 0 ; }",Calculate Median from given values of Mean and Mode.,"#include <bits/stdc++.h> 
 using namespace std ; void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; } int main ( ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; return 0 ; }","['void findMedian ( int Mean , int Mode ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findMedian ( int Mean , int Mode ) {
"
704,Program to find the Magnitude of a Vector | C ++ program for the above approach ; Function to calculate magnitude of a 3 dimensional vector ; Stores the sum of squares of coordinates of a vector ; Return the magnitude ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; } int main ( ) { int x = 1 ; int y = 2 ; int z = 3 ; cout << vectorMagnitude ( x , y , z ) ; return 0 ; }",Program to find the Magnitude of a Vector.,"#include <bits/stdc++.h> 
 using namespace std ; float vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; } int main ( ) { int x = 1 ; int y = 2 ; int z = 3 ; cout << vectorMagnitude ( x , y , z ) ; return 0 ; }","['float vectorMagnitude ( int x , int y , int z ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float vectorMagnitude ( int x , int y , int z ) {
"
705,Program to find the product of a number with a Mersenne Number | C ++ implementation of above approach ; Function to find prodcut of a Mersenne number with another number ; Stores the power of 2 of integer M + 1 ; Return the product ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long multiplyByMersenne ( long N , long M ) { long x = log2 ( M + 1 ) ; return ( ( N << x ) - N ) ; } int main ( ) { long N = 4 ; long M = 15 ; cout << multiplyByMersenne ( N , M ) ; return 0 ; }",Program to find the product of a number with a Mersenne Number.,"#include <bits/stdc++.h> 
 using namespace std ; long multiplyByMersenne ( long N , long M ) { long x = log2 ( M + 1 ) ; return ( ( N << x ) - N ) ; } int main ( ) { long N = 4 ; long M = 15 ; cout << multiplyByMersenne ( N , M ) ; return 0 ; }","['long multiplyByMersenne ( long N , long M ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long multiplyByMersenne ( long N , long M ) {
"
707,Partition array into two subarrays with every element in the right subarray strictly greater than every element in left subarray | C ++ program of the above approach ; Function to partition the array into two non - empty subarrays which satisfies the given condition ; Stores the suffix Min array ; Stores the Minimum of a suffix ; Traverse the array in reverse ; Update Minimum ; Store the Minimum ; Stores the Maximum value of a prefix ; Stores the index of the partition ; Update Max ; If Max is less than Min [ i + 1 ] ; Store the index of partition ; break ; If ind is not - 1 ; Print the first subarray ; Print the second subarray ; Otherwise ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void partitionArray ( int * a , int n ) { int * Min = new int [ n ] ; int Mini = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Mini = min ( Mini , a [ i ] ) ; Min [ i ] = Mini ; } int Maxi = INT_MIN ; int ind = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { Maxi = max ( Maxi , a [ i ] ) ; if ( Maxi < Min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != -1 ) { for ( int i = 0 ; i <= ind ; i ++ ) cout << a [ i ] << "" ▁ "" ; cout << endl ; for ( int i = ind + 1 ; i < n ; i ++ ) cout << a [ i ] << "" ▁ "" ; } else cout << "" Impossible "" ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = 5 ; partitionArray ( arr , N ) ; return 0 ; }",Partition array into two subarrays with every element in the right subarray strictly greater than every element in left subarray.,"#include <bits/stdc++.h> 
 using namespace std ; void partitionArray ( int * a , int n ) { int * Min = new int [ n ] ; int Mini = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Mini = min ( Mini , a [ i ] ) ; Min [ i ] = Mini ; } int Maxi = INT_MIN ; int ind = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { Maxi = max ( Maxi , a [ i ] ) ; if ( Maxi < Min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != -1 ) { for ( int i = 0 ; i <= ind ; i ++ ) cout << a [ i ] << "" ▁ "" ; cout << endl ; for ( int i = ind + 1 ; i < n ; i ++ ) cout << a [ i ] << "" ▁ "" ; } else cout << "" Impossible "" ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = 5 ; partitionArray ( arr , N ) ; return 0 ; }","['void partitionArray ( int * a , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void partitionArray ( int * a , int n ) {
"
711,Number of cards needed build a House of Cards of a given level N | C ++ implementation of the above approach ; Function to find number of cards needed ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << noOfCards ( n ) << "" , ▁ "" ; return 0 ; }",Number of cards needed build a House of Cards of a given level N.,"#include <bits/stdc++.h> 
 using namespace std ; int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << noOfCards ( n ) << "" , ▁ "" ; return 0 ; }","['int noOfCards ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int noOfCards ( int n ) {
"
712,Find smallest possible Number from a given large Number with same count of digits | C ++ implementation of the above approach ; Function for finding the smallest possible number after swapping the digits any number of times ; Variable to store the final answer ; Array to store the count of occurrence of each digit ; Loop to calculate the number of occurrences of every digit ; Loop to get smallest number ; Returning the answer ; Driver code,"#include <iostream> NEW_LINE using namespace std ; string smallestPoss ( string s , int n ) { string ans = "" "" ; int arr [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + to_string ( i ) ; } return ans ; } int main ( ) { int N = 15 ; string K = ""325343273113434"" ; cout << smallestPoss ( K , N ) ; return 0 ; }",Find smallest possible Number from a given large Number with same count of digits.,"#include <iostream> 
 using namespace std ; string smallestPoss ( string s , int n ) { string ans = "" "" ; int arr [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + to_string ( i ) ; } return ans ; } int main ( ) { int N = 15 ; string K = ""325343273113434"" ; cout << smallestPoss ( K , N ) ; return 0 ; }","['string smallestPoss ( string s , int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 string smallestPoss ( string s , int n ) {
"
713,Count the subarray with sum strictly greater than the sum of remaining elements | C ++ implementation of the above approach ; Function to count the number of sub - arrays with sum strictly greater than the remaining elements of array ; For loop for beginning point of a subarray ; For loop for ending point of the subarray ; Initialise subarray_sum and remaining_sum to 0 ; For loop to calculate the sum of generated subarray ; For loop to calculate the sum remaining array element ; Checking for condition when subarray sum is strictly greater than remaining sum of array element ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }",Count the subarray with sum strictly greater than the sum of remaining elements.,"#include <bits/stdc++.h> 
 using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }","['int Count_subarray ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Count_subarray ( int arr [ ] , int n ) {
"
714,Count the subarray with sum strictly greater than the sum of remaining elements | C ++ implementation of the above approach ; Calculating total sum of given array ; For loop for beginning point of a subarray ; initialise subarray_sum to 0 ; For loop for calculating subarray_sum and remaining_sum ; Calculating subarray_sum and corresponding remaining_sum ; Checking for the condition when subarray sum is strictly greater than the remaining sum of the array element ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }",Count the subarray with sum strictly greater than the sum of remaining elements.,"#include <bits/stdc++.h> 
 using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }","['int Count_subarray ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Count_subarray ( int arr [ ] , int n ) {
"
715,Remove one element to get maximum XOR | C ++ implementation of the approach ; Function to return the maximized XOR after removing an element from the array ; Find XOR of the complete array ; To store the final answer ; Iterating through the array to find the final answer ; Return the final answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXOR ( int * arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxXOR ( arr , n ) ; return 0 ; }",Remove one element to get maximum XOR.,"#include <bits/stdc++.h> 
 using namespace std ; int maxXOR ( int * arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxXOR ( arr , n ) ; return 0 ; }","['int maxXOR ( int * arr , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxXOR ( int * arr , int n ) {
"
717,Check if a given number is factorial of any number | C ++ implementation for the above approach ; Function to check if the given number is a factorial of any number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } int main ( ) { int n = 24 ; bool ans = isFactorial ( n ) ; if ( ans == 1 ) { cout << "" Yes STRNEWLINE "" ; } else { cout << "" No STRNEWLINE "" ; } return 0 ; }",Check if a given number is factorial of any number.,"#include <bits/stdc++.h> 
 using namespace std ; bool isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } int main ( ) { int n = 24 ; bool ans = isFactorial ( n ) ; if ( ans == 1 ) { cout << "" Yes STRNEWLINE "" ; } else { cout << "" No STRNEWLINE "" ; } return 0 ; }","['bool isFactorial ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isFactorial ( int n ) {
"
719,Number of coloured 0 's in an N | C ++ implementation of the approach ; Function to return the count of coloured 0 s in an n - level hexagon ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; },Number of coloured 0 's in an N.,"#include <bits/stdc++.h> 
 using namespace std ; int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; }","['int count ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int count ( int n ) {
"
720,Minimum value to be assigned to the elements so that sum becomes greater than initial sum | C ++ implementation of the approach ; Function to return the minimum required value ; Find the sum of the array elements ; Return the required value ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinValue ( arr , n ) ; return 0 ; }",Minimum value to be assigned to the elements so that sum becomes greater than initial sum.,"#include <bits/stdc++.h> 
 using namespace std ; int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinValue ( arr , n ) ; return 0 ; }","['int findMinValue ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findMinValue ( int arr [ ] , int n ) {
"
721,Color all boxes in line such that every M consecutive boxes are unique | C ++ implementation of the approach ; Function to return ( m ! % MOD ) ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } int main ( ) { int n = 3 , m = 2 ; cout << modFact ( n , m ) ; return 0 ; }",Color all boxes in line such that every M consecutive boxes are unique.,"#include <bits/stdc++.h> 
 using namespace std ; #define MOD  1000000007 
 int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } int main ( ) { int n = 3 , m = 2 ; cout << modFact ( n , m ) ; return 0 ; }","['int modFact ( int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 #define MOD  1000000007 
 int modFact ( int n , int m ) {
"
724,Comparing X ^ Y and Y ^ X for very large values of X and Y | C ++ implementation of the approach ; Function to compare x ^ y and y ^ x ; Storing values OF x ^ y AND y ^ x ; Comparing values ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << "" ^ "" << y << "" ▁ > ▁ "" << y << "" ^ "" << x ; else if ( a < b ) cout << x << "" ^ "" << y << "" ▁ < ▁ "" << y << "" ^ "" << x ; else if ( a == b ) cout << x << "" ^ "" << y << "" ▁ = ▁ "" << y << "" ^ "" << x ; } int main ( ) { long double x = 4 , y = 5 ; compareVal ( x , y ) ; return 0 ; }",Comparing X ^ Y and Y ^ X for very large values of X and Y.,"#include <bits/stdc++.h> 
 using namespace std ; void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << "" ^ "" << y << "" ▁ > ▁ "" << y << "" ^ "" << x ; else if ( a < b ) cout << x << "" ^ "" << y << "" ▁ < ▁ "" << y << "" ^ "" << x ; else if ( a == b ) cout << x << "" ^ "" << y << "" ▁ = ▁ "" << y << "" ^ "" << x ; } int main ( ) { long double x = 4 , y = 5 ; compareVal ( x , y ) ; return 0 ; }","['void compareVal ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void compareVal ( int x , int y ) {
"
725,"Euler zigzag numbers ( Alternating Permutation ) | CPP program to find zigzag sequence ; Function to print first n zigzag numbers ; To store factorial and n 'th zig zag number ; Initialize factorial upto n ; Set first two zig zag numbers ; Print first two zig zag number ; Print the rest zig zag numbers ; Binomial ( n , k ) * a ( k ) * a ( n - k ) ; Store the value ; Print the number ; Driver code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void ZigZag ( int n ) { long long fact [ n + 1 ] , zig [ n + 1 ] = { 0 } ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; cout << "" zig ▁ zag ▁ numbers : ▁ "" ; cout << zig [ 0 ] << "" ▁ "" << zig [ 1 ] << "" ▁ "" ; for ( int i = 2 ; i < n ; i ++ ) { long long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; cout << sum / 2 << "" ▁ "" ; } } int main ( ) { int n = 10 ; ZigZag ( n ) ; return 0 ; }",Euler zigzag numbers ( Alternating Permutation ).,"#include <bits/stdc++.h> 
 using namespace std ; void ZigZag ( int n ) { long long fact [ n + 1 ] , zig [ n + 1 ] = { 0 } ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; cout << "" zig ▁ zag ▁ numbers : ▁ "" ; cout << zig [ 0 ] << "" ▁ "" << zig [ 1 ] << "" ▁ "" ; for ( int i = 2 ; i < n ; i ++ ) { long long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; cout << sum / 2 << "" ▁ "" ; } } int main ( ) { int n = 10 ; ZigZag ( n ) ; return 0 ; }","['void ZigZag ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void ZigZag ( int n ) {
"
729,Decimal to Binary using recursion and without using power operator | C ++ implementation of the approach ; Recursive function to convert n to its binary equivalent ; Base case ; Recursive call ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void decimalToBinary ( int n ) { if ( n == 0 ) { cout << ""0"" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; } int main ( ) { int n = 13 ; decimalToBinary ( n ) ; return 0 ; }",Decimal to Binary using recursion and without using power operator.,"#include <bits/stdc++.h> 
 using namespace std ; void decimalToBinary ( int n ) { if ( n == 0 ) { cout << ""0"" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; } int main ( ) { int n = 13 ; decimalToBinary ( n ) ; return 0 ; }","['void decimalToBinary ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void decimalToBinary ( int n ) {
"
730,"Find minimum possible values of A , B and C when two of the ( A + B ) , ( A + C ) and ( B + C ) are given | C ++ implementation of the approach ; Function to find A , B and C ; Keep minimum number in x ; Find the numbers ; Driver code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumValue ( int x , int y ) { if ( x > y ) swap ( x , y ) ; int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << "" ▁ "" << b << "" ▁ "" << c ; } int main ( ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; return 0 ; }","Find minimum possible values of A , B and C when two of the ( A + B ) , ( A + C ) and ( B + C ) are given.","#include <bits/stdc++.h> 
 using namespace std ; void MinimumValue ( int x , int y ) { if ( x > y ) swap ( x , y ) ; int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << "" ▁ "" << b << "" ▁ "" << c ; } int main ( ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; return 0 ; }","['void MinimumValue ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void MinimumValue ( int x , int y ) {
"
731,Check whether it is possible to convert A into B | C ++ implementation of the approach ; Function that returns true if A can be converted to B with the given operations ; If the current number ends with 1 ; If the current number is divisible by 2 ; If above two conditions fail ; If it is possible to convert A to B ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; } int main ( ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check whether it is possible to convert A into B.,"#include <bits/stdc++.h> 
 using namespace std ; bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; } int main ( ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool canConvert ( int a , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool canConvert ( int a , int b ) {
"
732,Count Distinct Rectangles in N * N Chessboard | C ++ code to count distinct rectangle in a chessboard ; Function to return the count of distinct rectangles ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } int main ( ) { int N = 4 ; cout << count ( N ) ; },Count Distinct Rectangles in N * N Chessboard.,"#include <bits/stdc++.h> 
 using namespace std ; int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } int main ( ) { int N = 4 ; cout << count ( N ) ; }","['int count ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int count ( int N ) {
"
733,Total number of days taken to complete the task if after certain days one person leaves | C ++ implementation of the approach ; Function to return the number of days required ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } int main ( ) { int a = 10 , b = 20 , n = 5 ; cout << numberOfDays ( a , b , n ) ; return 0 ; }",Total number of days taken to complete the task if after certain days one person leaves.,"#include <bits/stdc++.h> 
 using namespace std ; int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } int main ( ) { int a = 10 , b = 20 , n = 5 ; cout << numberOfDays ( a , b , n ) ; return 0 ; }","['int numberOfDays ( int a , int b , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int numberOfDays ( int a , int b , int n ) {
"
734,Find average of two numbers using bit operation | C ++ implementation of the approach ; Function to return the average of x and y using bit operations ; Calculate the average Floor value of ( x + y ) / 2 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } int main ( ) { int x = 10 , y = 9 ; cout << getAverage ( x , y ) ; return 0 ; }",Find average of two numbers using bit operation.,"#include <bits/stdc++.h> 
 using namespace std ; int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } int main ( ) { int x = 10 , y = 9 ; cout << getAverage ( x , y ) ; return 0 ; }","['int getAverage ( int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getAverage ( int x , int y ) {
"
735,Smallest index such that there are no 0 or 1 to its right | C ++ program to implement the above approach ; Function to find the smallest index such that there are no 0 or 1 to its right ; Initially ; Traverse in the array ; Check if array element is 1 ; a [ i ] = 0 ; Return minimum of both ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; } int main ( ) { int a [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << smallestIndex ( a , n ) ; return 0 ; }",Smallest index such that there are no 0 or 1 to its right.,"#include <bits/stdc++.h> 
 using namespace std ; int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; } int main ( ) { int a [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << smallestIndex ( a , n ) ; return 0 ; }","['int smallestIndex ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int smallestIndex ( int a [ ] , int n ) {
"
736,"Total position where king can reach on a chessboard in exactly M moves | Set 2 | C ++ implementation of the approach ; Function to return the count of squares that can be visited by king in m moves ; To store the count of squares ; Check all squares of the chessboard ; Check if square ( i , j ) is at a distance <= m units from king 's current position ; Return count of squares ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } int main ( ) { int r = 4 , c = 4 , m = 1 ; cout << countSquares ( r , c , m ) << endl ; return 0 ; }",Total position where king can reach on a chessboard in exactly M moves.,"#include <bits/stdc++.h> 
 using namespace std ; int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } int main ( ) { int r = 4 , c = 4 , m = 1 ; cout << countSquares ( r , c , m ) << endl ; return 0 ; }","['int countSquares ( int r , int c , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countSquares ( int r , int c , int m ) {
"
737,Number of quadruples where the first three terms are in AP and last three terms are in GP | C ++ implementation of the approach ; Function to return the count of quadruples ; Hash table to count the number of occurrences ; Traverse and increment the count ; Run two nested loop for second and third element ; If they are same ; Initially decrease the count ; Find the first element using common difference ; Find the fourth element using GP y ^ 2 = x * z property ; If it is an integer ; If not equal ; Same elements ; Later increase the value for future calculations ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countQuadruples ( int a [ ] , int n ) { unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) mpp [ a [ i ] ] ++ ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mpp [ a [ j ] ] -- ; mpp [ a [ k ] ] -- ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) count += mpp [ first ] * mpp [ fourth ] ; else count += mpp [ first ] * ( mpp [ fourth ] - 1 ) ; } mpp [ a [ j ] ] ++ ; mpp [ a [ k ] ] ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countQuadruples ( a , n ) ; return 0 ; }",Number of quadruples where the first three terms are in AP and last three terms are in GP.,"#include <bits/stdc++.h> 
 using namespace std ; int countQuadruples ( int a [ ] , int n ) { unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) mpp [ a [ i ] ] ++ ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mpp [ a [ j ] ] -- ; mpp [ a [ k ] ] -- ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) count += mpp [ first ] * mpp [ fourth ] ; else count += mpp [ first ] * ( mpp [ fourth ] - 1 ) ; } mpp [ a [ j ] ] ++ ; mpp [ a [ k ] ] ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countQuadruples ( a , n ) ; return 0 ; }","['int countQuadruples ( int a [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countQuadruples ( int a [ ] , int n ) {
"
738,Numbers in a Range with given Digital Root | C ++ implementation of the approach ; Function to return the count of required numbers ; Count of numbers present in given range ; Number of groups of 9 elements starting from L ; Left over elements not covered in factor 9 ; One Number in each group of 9 ; To check if any number in rem satisfy the property ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int countNumbers ( int L , int R , int K ) { if ( K == 9 ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) ans ++ ; } return ans ; } int main ( ) { int L = 10 ; int R = 22 ; int K = 3 ; cout << countNumbers ( L , R , K ) ; return 0 ; }",Numbers in a Range with given Digital Root.,"#include <bits/stdc++.h> 
 #define ll  long long int 
 using namespace std ; int countNumbers ( int L , int R , int K ) { if ( K == 9 ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) ans ++ ; } return ans ; } int main ( ) { int L = 10 ; int R = 22 ; int K = 3 ; cout << countNumbers ( L , R , K ) ; return 0 ; }","['int countNumbers ( int L , int R , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define ll  long long int 
 using namespace std ;
 int countNumbers ( int L , int R , int K ) {
"
740,Sum of even values and update queries on an array | C ++ implementation of the approach ; Function to print the result for every query ; If current element is even ; If element is even then remove it from sum ; If the value becomes even after updating ; Store sum for each query ; Print the result for every query ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << "" ▁ "" ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }",Sum of even values and update queries on an array.,"#include <bits/stdc++.h> 
 using namespace std ; void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << "" ▁ "" ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }","['void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) {
"
741,Number of Hamiltonian cycle | C ++ program for implementation of the above program ; Function that calculates number of Hamiltonian cycle ; Calculating factorial ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } int main ( ) { int N = 5 ; int Number = Cycles ( N ) ; cout << "" Hamiltonian ▁ cycles ▁ = ▁ "" << Number ; return 0 ; }",Number of Hamiltonian cycle.,"#include <bits/stdc++.h> 
 using namespace std ; int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } int main ( ) { int N = 5 ; int Number = Cycles ( N ) ; cout << "" Hamiltonian ▁ cycles ▁ = ▁ "" << Number ; return 0 ; }","['int Cycles ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Cycles ( int N ) {
"
746,"Minimum removals in a number to be divisible by 10 power raised to K | CPP Program to count the number of digits that can be removed such that number is divisible by 10 ^ K ; function to return the required number of digits to be removed ; Converting the given number into string ; variable to store number of digits to be removed ; variable to denote if atleast one zero has been found ; zero found ; return size - 1 if K is not zero and atleast one zero is present , otherwise result ; Driver Code to test above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; } int main ( ) { int N = 10904025 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 1000 , K = 5 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 23985 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; return 0 ; }",Minimum removals in a number to be divisible by 10 power raised to K.,"#include <bits/stdc++.h> 
 using namespace std ; int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; } int main ( ) { int N = 10904025 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 1000 , K = 5 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 23985 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; return 0 ; }","['int countDigitsToBeRemoved ( int N , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countDigitsToBeRemoved ( int N , int K ) {
"
747,"Program to find the sum of the series ( 1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n ) | C ++ program to find the sum of the given series ; Function to return the sum of the series ; variable to store the answer ; Math . pow ( x , y ) returns x ^ y ; Driver code ; Print the sum of the series","#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; } int main ( ) { int a = 3 , n = 3 ; cout << ( getSum ( a , n ) ) ; return 0 ; }",Program to find the sum of the series ( 1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n ).,"#include <stdio.h> 
 #include <math.h> 
 #include <iostream> 
 using namespace std ; float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; } int main ( ) { int a = 3 , n = 3 ; cout << ( getSum ( a , n ) ) ; return 0 ; }","['float getSum ( int a , int n ) {', 'int main ( ) {']","#include <stdio.h> 
 #include <math.h> 
 #include <iostream> 
 using namespace std ;
 float getSum ( int a , int n ) {
"
749,Check if at least half array is reducible to zero by performing some operations | C ++ program to find whether half - array reducible to 0 ; Function to print the desired result after computation ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ m + 1 ] ; int i ; memset ( frequencyHash , 0 , sizeof ( frequencyHash ) ) ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; } int main ( ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 7 ; isHalfReducible ( arr , n , m ) ; return 0 ; }",Check if at least half array is reducible to zero by performing some operations.,"#include <bits/stdc++.h> 
 using namespace std ; void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ m + 1 ] ; int i ; memset ( frequencyHash , 0 , sizeof ( frequencyHash ) ) ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; } int main ( ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 7 ; isHalfReducible ( arr , n , m ) ; return 0 ; }","['void isHalfReducible ( int arr [ ] , int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void isHalfReducible ( int arr [ ] , int n , int m ) {
"
753,Area of a square inscribed in a circle which is inscribed in a hexagon | C ++ Program to find the area of the square inscribed within the circle which in turn is inscribed in a hexagon ; Function to find the area of the square ; side of hexagon cannot be negative ; area of the square ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }",Area of a square inscribed in a circle which is inscribed in a hexagon.,"#include <bits/stdc++.h> 
 using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }","['float area ( float a ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float area ( float a ) {
"
754,"Program to find Nth term of series 1 , 6 , 17 , 34 , 56 , 86 , 121 , 162 , ... ... . | C ++ program to find the N - th term of the series : 1 , 6 , 17 , 34 , 56 , 86 , 121 , 162 , ... . . ; calculate Nth term of series ; Driver code","#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }","Program to find Nth term of series 1 , 6 , 17 , 34 , 56 , 86 , 121 , 162 , ... ... ..","#include <iostream> 
 #include <math.h> 
 using namespace std ; int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }","['int nthTerm ( int n ) {', 'int main ( ) {']","#include <iostream> 
 #include <math.h> 
 using namespace std ;
 int nthTerm ( int n ) {
"
755,"Sum of the first N terms of the series 2 , 10 , 30 , 68 , ... . | C ++ program to find sum of first n terms ; Function to calculate the sum ; Driver code ; number of terms to be included in the sum ; find the Sum","#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; } int main ( ) { int n = 3 ; cout << "" Sum ▁ = ▁ "" << calculateSum ( n ) ; return 0 ; }","Sum of the first N terms of the series 2 , 10 , 30 , 68 , ... ..","#include <bits/stdc++.h> 
 using namespace std ; int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; } int main ( ) { int n = 3 ; cout << "" Sum ▁ = ▁ "" << calculateSum ( n ) ; return 0 ; }","['int calculateSum ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int calculateSum ( int n ) {
"
756,"Check if two arrays are permutations of each other using Mathematical Operation | CPP code to check if arrays are permutations of eah other ; Function to check if arrays are permutations of each other . ; Calculating sum and multiply of first array ; Calculating sum and multiply of second array ; If sum and mul of both arrays are equal , return true , else return false . ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } int main ( ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; int m = sizeof ( b ) / sizeof ( int ) ; if ( arePermutations ( a , b , n , m ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; return 0 ; }",Check if two arrays are permutations of each other using Mathematical Operation.,"#include <iostream> 
 using namespace std ; bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } int main ( ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; int m = sizeof ( b ) / sizeof ( int ) ; if ( arePermutations ( a , b , n , m ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; return 0 ; }","['bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) {
"
757,Program to find the head start in a race | C ++ implementation of above approach ; Function to find the B start to C ; When B completed it 's 100 meter  then Completed meters by C is ; Driver Code . ; When A completed it 's 100 meter  Then completed meters of B and C is,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } int main ( ) { int B = 10 , C = 28 ; B = 100 - B ; C = 100 - C ; cout << Race ( B , C ) << "" ▁ meters "" ; return 0 ; }",Program to find the head start in a race.,"#include <bits/stdc++.h> 
 using namespace std ; int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } int main ( ) { int B = 10 , C = 28 ; B = 100 - B ; C = 100 - C ; cout << Race ( B , C ) << "" ▁ meters "" ; return 0 ; }","['int Race ( int B , int C ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Race ( int B , int C ) {
"
758,Minimum time required to fill a cistern using N pipes | C ++ implementation of above approach ; Function to calculate the time ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; } int main ( ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << floor ( Time ( arr , n , Emptypipe ) ) << "" ▁ Hours "" ; return 0 ; }",Minimum time required to fill a cistern using N pipes.,"#include <bits/stdc++.h> 
 using namespace std ; float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; } int main ( ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << floor ( Time ( arr , n , Emptypipe ) ) << "" ▁ Hours "" ; return 0 ; }","['float Time ( float arr [ ] , int n , int Emptypipe ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float Time ( float arr [ ] , int n , int Emptypipe ) {
"
759,Check if Decimal representation of an Octal number is divisible by 7 | CPP program to check if Decimal representation of an Octal number is divisible by 7 or not ; Function to check Divisibility ; Sum of all individual digits ; Condition ; Driver Code ; Octal number,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } int main ( ) { int n = 25 ; ( check ( n ) == 1 ) ? cout << "" YES "" : cout << "" NO "" ; return 0 ; }",Check if Decimal representation of an Octal number is divisible by 7.,"#include <bits/stdc++.h> 
 using namespace std ; int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } int main ( ) { int n = 25 ; ( check ( n ) == 1 ) ? cout << "" YES "" : cout << "" NO "" ; return 0 ; }","['int check ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int check ( int n ) {
"
761,Sum of all the prime divisors of a number | CPP program to find prime divisors of all numbers from 1 to n ; function to find prime divisors of all numbers from 1 to n ; if the number is prime ; add this prime to all it 's multiples ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } int main ( ) { int N = 60 ; cout << "" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ "" << Sum ( N ) << endl ; }",Sum of all the prime divisors of a number.,"#include <bits/stdc++.h> 
 using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } int main ( ) { int N = 60 ; cout << "" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ "" << Sum ( N ) << endl ; }","['int Sum ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Sum ( int N ) {
"
762,"Find ( a ^ b ) % m where ' b ' is very large | C ++ program to find ( a ^ b ) % m for b very large . ; Function to find power ; Update x if it is more than or equal to p ; If y is odd , multiply x with the result ; y must be even now y = y >> 1 ; y = y / 2 ; Driver Code ; String input as b is very large ; Reduce the number B to a small number using Fermat Little","#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll power ( ll x , ll y , ll p ) { x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int main ( ) { ll a = 3 ; string b = ""100000000000000000000000000"" ; ll remainderB = 0 ; ll MOD = 1000000007 ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b [ i ] - '0' ) % ( MOD - 1 ) ; cout << power ( a , remainderB , MOD ) << endl ; return 0 ; }",Find ( a ^ b ) % m where ' b ' is very large.,"#include <bits/stdc++.h> 
 #define ll  long long int 
 using namespace std ; ll power ( ll x , ll y , ll p ) { x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int main ( ) { ll a = 3 ; string b = ""100000000000000000000000000"" ; ll remainderB = 0 ; ll MOD = 1000000007 ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b [ i ] - '0' ) % ( MOD - 1 ) ; cout << power ( a , remainderB , MOD ) << endl ; return 0 ; }","['ll power ( ll x , ll y , ll p ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #define ll  long long int 
 using namespace std ;
 ll power ( ll x , ll y , ll p ) {
"
763,"Squares of numbers with repeated single digits | Set 1 ( 3 , 6 and 9 ) | C ++ program to find square of these large numbers ; Function to find the square of 333. . .333 , 666. . .666 and 999. . .999 ; if the number is 333. . .333 ; if the number is 666. . .666 ; if the number is 999. . .999 ; variable for hold result ; find the no of digit ; add size - 1 time a in result ; add one time b in result ; add size - 1 time c in result ; add one time d in result ; return result ; Drivers code ; find square of 33. .33 ; find square of 66. .66 ; find square of 66. .66","#include <iostream> NEW_LINE using namespace std ; string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) a = '1' , b = '0' , c = '8' , d = '9' ; else if ( num [ 0 ] == '6' ) a = '4' , b = '3' , c = '5' , d = '6' ; else a = '9' , b = '8' , c = '0' , d = '1' ; string result = "" "" ; int size = num . size ( ) ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += c ; result += d ; return result ; } int main ( ) { string num_3 , num_6 , num_9 ; num_3 = ""3333"" ; num_6 = ""6666"" ; num_9 = ""9999"" ; string result = "" "" ; result = find_Square_369 ( num_3 ) ; cout << "" Square ▁ of ▁ "" << num_3 << "" ▁ is ▁ : ▁ "" << result << endl ; result = find_Square_369 ( num_6 ) ; cout << "" Square ▁ of ▁ "" << num_6 << "" ▁ is ▁ : ▁ "" << result << endl ; result = find_Square_369 ( num_9 ) ; cout << "" Square ▁ of ▁ "" << num_9 << "" ▁ is ▁ : ▁ "" << result << endl ; return 0 ; }",Squares of numbers with repeated single digits.,"#include <iostream> 
 using namespace std ; string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) a = '1' , b = '0' , c = '8' , d = '9' ; else if ( num [ 0 ] == '6' ) a = '4' , b = '3' , c = '5' , d = '6' ; else a = '9' , b = '8' , c = '0' , d = '1' ; string result = "" "" ; int size = num . size ( ) ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += c ; result += d ; return result ; } int main ( ) { string num_3 , num_6 , num_9 ; num_3 = ""3333"" ; num_6 = ""6666"" ; num_9 = ""9999"" ; string result = "" "" ; result = find_Square_369 ( num_3 ) ; cout << "" Square ▁ of ▁ "" << num_3 << "" ▁ is ▁ : ▁ "" << result << endl ; result = find_Square_369 ( num_6 ) ; cout << "" Square ▁ of ▁ "" << num_6 << "" ▁ is ▁ : ▁ "" << result << endl ; result = find_Square_369 ( num_9 ) ; cout << "" Square ▁ of ▁ "" << num_9 << "" ▁ is ▁ : ▁ "" << result << endl ; return 0 ; }","['string find_Square_369 ( string num ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 string find_Square_369 ( string num ) {
"
767,Pythagorean Triplet with given sum | C ++ program to find Pythagorean Triplet of given sum . ; Considering triplets in sorted order . The value of first element in sorted triplet can be at - most n / 3. ; The value of second element must be less than equal to n / 2 ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << "" , ▁ "" << j << "" , ▁ "" << k ; return ; } } } cout << "" No ▁ Triplet "" ; } int main ( ) { int n = 12 ; pythagoreanTriplet ( n ) ; return 0 ; }",Pythagorean Triplet with given sum.,"#include <bits/stdc++.h> 
 using namespace std ; void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << "" , ▁ "" << j << "" , ▁ "" << k ; return ; } } } cout << "" No ▁ Triplet "" ; } int main ( ) { int n = 12 ; pythagoreanTriplet ( n ) ; return 0 ; }","['void pythagoreanTriplet ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void pythagoreanTriplet ( int n ) {
"
769,Sum of series with alternate signed squares of AP | CPP program to find sum of series with alternate signed square AP sums . ; function to calculate series sum ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }",Sum of series with alternate signed squares of AP.,"#include <bits/stdc++.h> 
 using namespace std ; int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }","['int seiresSum ( int n , int a [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int seiresSum ( int n , int a [ ] ) {
"
770,Power of a prime number ‘ r ’ in n ! | C ++ program to find power of a prime number r in n ! ; Function to return power of a no . ' r ' in factorial of n ; Keep dividing n by powers of ' r ' and update count ; Driver program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } int main ( ) { int n = 6 , r = 3 ; printf ( "" ▁ % d ▁ "" , power ( n , r ) ) ; return 0 ; }",Power of a prime number ‘ r ’ in n !.,"#include <bits/stdc++.h> 
 using namespace std ; int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } int main ( ) { int n = 6 , r = 3 ; printf ( "" ▁ % d ▁ "" , power ( n , r ) ) ; return 0 ; }","['int power ( int n , int r ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int power ( int n , int r ) {
"
771,Average of first n odd naturals numbers | A C ++ program to find average of sum of first n odd natural numbers . ; Returns the Avg of first n odd numbers ; sum of first n odd number ; Average of first n odd numbers ; Driver Code,#include <iostream> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } int main ( ) { int n = 20 ; cout << avg_of_odd_num ( n ) ; return 0 ; },Average of first n odd naturals numbers.,"#include <iostream> 
 using namespace std ; int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } int main ( ) { int n = 20 ; cout << avg_of_odd_num ( n ) ; return 0 ; }","['int avg_of_odd_num ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int avg_of_odd_num ( int n ) {
"
772,Average of first n odd naturals numbers | CPP Program to find the average of sum of first n odd numbers ; Return the average of sum of first n odd numbers ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { return n ; } int main ( ) { int n = 8 ; cout << avg_of_odd_num ( n ) ; return 0 ; },Average of first n odd naturals numbers.,"#include <bits/stdc++.h> 
 using namespace std ; int avg_of_odd_num ( int n ) { return n ; } int main ( ) { int n = 8 ; cout << avg_of_odd_num ( n ) ; return 0 ; }","['int avg_of_odd_num ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int avg_of_odd_num ( int n ) {
"
774,Average of odd numbers till a given odd number | Program to find average of odd numbers till a given odd number . ; Function to calculate the average of odd numbers ; count odd numbers ; store the sum of odd numbers ; driver function,"#include <stdio.h> NEW_LINE int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( "" Invalid ▁ Input "" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 15 ; printf ( "" % d "" , averageOdd ( n ) ) ; return 0 ; }",Average of odd numbers till a given odd number.,"#include <stdio.h> 
 int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( "" Invalid ▁ Input "" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 15 ; printf ( "" % d "" , averageOdd ( n ) ) ; return 0 ; }","['int averageOdd ( int n ) {', 'int main ( ) {']","#include <stdio.h> 
 int averageOdd ( int n ) {
"
777,"Sum of largest prime factor of each number less than equal to n | C ++ implementation to find sum of largest prime factor of each number less than equal to n ; function to find sum of largest prime factor of each number less than equal to n ; Create an integer array "" prime [ 0 . . n ] "" and initialize all entries of it as 0. A value in prime [ i ] will finally be 0 if ' i ' is a prime , else it will contain the largest prime factor of ' i ' . ; If prime [ p ] is '0' , then it is a prime number ; Update all multiples of p ; Sum up the largest prime factor of all the numbers ; if ' p ' is a non - prime number then prime [ p ] gives its largesr prime factor ; ' p ' is a prime number ; required sum ; Driver program to test above","#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] , sum = 0 ; memset ( prime , 0 , sizeof ( prime ) ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; } int main ( ) { int n = 12 ; cout << "" Sum ▁ = ▁ "" << sumOfLargePrimeFactor ( n ) ; return 0 ; }",Sum of largest prime factor of each number less than equal to n.,"#include <bits/stdc++.h> 
 using namespace std ; int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] , sum = 0 ; memset ( prime , 0 , sizeof ( prime ) ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; } int main ( ) { int n = 12 ; cout << "" Sum ▁ = ▁ "" << sumOfLargePrimeFactor ( n ) ; return 0 ; }","['int sumOfLargePrimeFactor ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int sumOfLargePrimeFactor ( int n ) {
"
778,Sum of multiples of a number up to N | C ++ program to find sum of multiples of a number up to N efficiently ; Function for calculating sum of multiples of a upto N ; Number of multiples ; sum of first m natural numbers ; sum of multiples ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } int main ( ) { int a = 7 , N = 49 ; cout << "" Sum ▁ of ▁ multiples ▁ of ▁ "" << a << "" ▁ up ▁ to ▁ "" << N << "" ▁ = ▁ "" << calculate_sum ( a , N ) << endl ; return 0 ; }",Sum of multiples of a number up to N.,"#include <iostream> 
 using namespace std ; int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } int main ( ) { int a = 7 , N = 49 ; cout << "" Sum ▁ of ▁ multiples ▁ of ▁ "" << a << "" ▁ up ▁ to ▁ "" << N << "" ▁ = ▁ "" << calculate_sum ( a , N ) << endl ; return 0 ; }","['int calculate_sum ( int a , int N ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int calculate_sum ( int a , int N ) {
"
779,Given a HUGE number check if it 's a power of two. | C ++ program to find whether a number is power of 2 or not ; Function to check whether a number is power of 2 or not ; Driver function,#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace std ; using namespace boost :: multiprecision ; bool ispowerof2 ( cpp_int num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } int main ( ) { cpp_int num = 549755813888 ; cout << ispowerof2 ( num ) << endl ; return 0 ; },Given a HUGE number check if it 's a power of two..,"#include <bits/stdc++.h> 
 #include <boost/multiprecision/cpp_int.hpp> 
 using namespace std ; using namespace boost :: multiprecision ; bool ispowerof2 ( cpp_int num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } int main ( ) { cpp_int num = 549755813888 ; cout << ispowerof2 ( num ) << endl ; return 0 ; }","['bool ispowerof2 ( cpp_int num ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 #include <boost/multiprecision/cpp_int.hpp> 
 using namespace std ;
 using namespace boost :: multiprecision ;
 bool ispowerof2 ( cpp_int num ) {
"
783,Enneacontahexagon numbers | C ++ implementation for above approach ; Function to find the Nth Enneacontahexagon Number ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int EnneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << EnneacontahexagonNum ( n ) ; return 0 ; },Enneacontahexagon numbers.,"#include <bits/stdc++.h> 
 using namespace std ; int EnneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << EnneacontahexagonNum ( n ) ; return 0 ; }","['int EnneacontahexagonNum ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int EnneacontahexagonNum ( int n ) {
"
784,Find two Composite Numbers such that there difference is N | C ++ code to Find two Composite Numbers such that there difference is N ; Function to find the two composite numbers ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_composite_nos ( int n ) { cout << 9 * n << "" ▁ "" << 8 * n ; } int main ( ) { int n = 4 ; find_composite_nos ( n ) ; return 0 ; }",Find two Composite Numbers such that there difference is N.,"#include <bits/stdc++.h> 
 using namespace std ; void find_composite_nos ( int n ) { cout << 9 * n << "" ▁ "" << 8 * n ; } int main ( ) { int n = 4 ; find_composite_nos ( n ) ; return 0 ; }","['void find_composite_nos ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void find_composite_nos ( int n ) {
"
785,"Count the number of pairs ( i , j ) such that either arr [ i ] is divisible by arr [ j ] or arr [ j ] is divisible by arr [ i ] | C ++ implementation of the approach ; Function to find number of unordered pairs ; Maximum element from the array ; Array to store the frequency of each element ; Stores the number of unordered pairs ; Store the frequency of each element ; Find the number of unordered pairs ; If the number j divisible by ith element is present in the array ; If the ith element of the array has frequency more than one ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int freqPairs ( int arr [ ] , int n ) { int max = * ( std :: max_element ( arr , arr + n ) ) ; int freq [ max + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; cout << freqPairs ( arr , n ) ; return 0 ; }","Count the number of pairs ( i , j ) such that either arr [ i ] is divisible by arr [ j ] or arr [ j ] is divisible by arr [ i ].","#include <bits/stdc++.h> 
 using namespace std ; int freqPairs ( int arr [ ] , int n ) { int max = * ( std :: max_element ( arr , arr + n ) ) ; int freq [ max + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; cout << freqPairs ( arr , n ) ; return 0 ; }","['int freqPairs ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int freqPairs ( int arr [ ] , int n ) {
"
786,Find the Nth term of the series 1 + 2 + 6 + 15 + 31 + 56 + ... | C ++ program to find Nth term of the series : 1 + 2 + 6 + 15 + 31 + 56 + ... ; calculate Nth term of given series ; Driver code,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; } int main ( ) { int N = 8 ; cout << Nth_Term ( N ) ; }",Find the Nth term of the series 1 + 2 + 6 + 15 + 31 + 56 + ....,"#include <iostream> 
 #include <math.h> 
 using namespace std ; int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; } int main ( ) { int N = 8 ; cout << Nth_Term ( N ) ; }","['int Nth_Term ( int n ) {', 'int main ( ) {']","#include <iostream> 
 #include <math.h> 
 using namespace std ;
 int Nth_Term ( int n ) {
"
787,Program to find N | C ++ program to find n - th number in a series made of digits 3 and 5 ; Function to find n - th number in series made of 3 and 5 ; create an array of size ( n + 1 ) ; If i is odd ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } int main ( ) { int n = 6 ; cout << printNthElement ( n ) ; return 0 ; },Program to find N.,"#include <bits/stdc++.h> 
 using namespace std ; int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } int main ( ) { int n = 6 ; cout << printNthElement ( n ) ; return 0 ; }","['int printNthElement ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int printNthElement ( int n ) {
"
788,"Program to find Nth term of the series 3 , 6 , 18 , 24 , ... | CPP program to find N - th term of the series : 3 , 6 , 18 , 24 , 45 , 54. . . ; function to calculate Nth term of series ; By using above formula ; Driver Function ; get the value of N ; Calculate and print the Nth term","#include <iostream> NEW_LINE using namespace std ; int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } int main ( ) { int N = 5 ; cout << "" Nth ▁ term ▁ for ▁ N ▁ = ▁ "" << N << "" ▁ : ▁ "" << nthTerm ( N ) ; return 0 ; }","Program to find Nth term of the series 3 , 6 , 18 , 24 , ....","#include <iostream> 
 using namespace std ; int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } int main ( ) { int N = 5 ; cout << "" Nth ▁ term ▁ for ▁ N ▁ = ▁ "" << N << "" ▁ : ▁ "" << nthTerm ( N ) ; return 0 ; }","['int nthTerm ( int N ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int nthTerm ( int N ) {
"
789,"Program to print binomial expansion series | CPP program to print terms of binomial series and also calculate sum of series . ; function to print the series ; Calculating and printing first term ; Computing and printing remaining terms ; Find current term using previous terms We increment power of X by 1 , decrement power of A by 1 and compute nCi using previous term by multiplying previous term with ( n - i + 1 ) / i ; main function started","#include <bits/stdc++.h> NEW_LINE using namespace std ; void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << "" ▁ "" ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << "" ▁ "" ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }",Program to print binomial expansion series.,"#include <bits/stdc++.h> 
 using namespace std ; void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << "" ▁ "" ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << "" ▁ "" ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }","['void series ( int A , int X , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void series ( int A , int X , int n ) {
"
790,Check if a number is divisible by 8 using bitwise operators | C ++ program to check whether the number is divisible by 8 or not using bitwise operator ; function to check number is div by 8 or not using bitwise operator ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } int main ( ) { int n = 16 ; if ( Div_by_8 ( n ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }",Check if a number is divisible by 8 using bitwise operators.,"#include <bits/stdc++.h> 
 using namespace std ; int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } int main ( ) { int n = 16 ; if ( Div_by_8 ( n ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }","['int Div_by_8 ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int Div_by_8 ( int n ) {
"
791,Average of even numbers till a given even number | Program to find average of even numbers till a given even number . ; Function to calculate the average of even numbers ; count even numbers ; store the sum of even numbers ; driver function,"#include <stdio.h> NEW_LINE int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( "" Invalid ▁ Input "" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 16 ; printf ( "" % d "" , averageEven ( n ) ) ; return 0 ; }",Average of even numbers till a given even number.,"#include <stdio.h> 
 int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( "" Invalid ▁ Input "" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 16 ; printf ( "" % d "" , averageEven ( n ) ) ; return 0 ; }","['int averageEven ( int n ) {', 'int main ( ) {']","#include <stdio.h> 
 int averageEven ( int n ) {
"
792,Average of even numbers till a given even number | Program to find average of even numbers till a given even nend umber . ; Function to calculate the average of even numbers ; driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << "" Invalid ▁ Input "" ; return -1 ; } return ( n + 2 ) / 2 ; } int main ( ) { int n = 16 ; cout << averageEven ( n ) << endl ; return 0 ; }",Average of even numbers till a given even number.,"#include <bits/stdc++.h> 
 using namespace std ; int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << "" Invalid ▁ Input "" ; return -1 ; } return ( n + 2 ) / 2 ; } int main ( ) { int n = 16 ; cout << averageEven ( n ) << endl ; return 0 ; }","['int averageEven ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int averageEven ( int n ) {
"
794,Count numbers with unit digit k in given range | Simple CPP program to count numbers with last digit as k in given range . ; Returns count of numbers with k as last digit . ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << counLastDigitK ( low , high , k ) ; return 0 ; }",Count numbers with unit digit k in given range.,"#include <bits/stdc++.h> 
 using namespace std ; int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << counLastDigitK ( low , high , k ) ; return 0 ; }","['int counLastDigitK ( int low , int high , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int counLastDigitK ( int low , int high , int k ) {
"
795,"Taxicab Numbers | C ++ implementation to print first N Taxicab ( 2 ) numbers : ; Starting from 1 , check every number if it is Taxicab until count reaches N . ; Try all possible pairs ( j , k ) whose cube sums can be i . ; Taxicab ( 2 ) found ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; cout << count << "" ▁ "" << i << endl ; } i ++ ; } } int main ( ) { int N = 5 ; printTaxicab2 ( N ) ; return 0 ; }",Taxicab Numbers.,"#include <bits/stdc++.h> 
 using namespace std ; void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; cout << count << "" ▁ "" << i << endl ; } i ++ ; } } int main ( ) { int N = 5 ; printTaxicab2 ( N ) ; return 0 ; }","['void printTaxicab2 ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printTaxicab2 ( int N ) {
"
796,Composite Number | A optimized school method based C ++ program to check if a number is composite . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver Program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } int main ( ) { isComposite ( 11 ) ? cout << "" ▁ true STRNEWLINE "" : cout << "" ▁ false STRNEWLINE "" ; isComposite ( 15 ) ? cout << "" ▁ true STRNEWLINE "" : cout << "" ▁ false STRNEWLINE "" ; return 0 ; }",Composite Number.,"#include <bits/stdc++.h> 
 using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } int main ( ) { isComposite ( 11 ) ? cout << "" ▁ true STRNEWLINE "" : cout << "" ▁ false STRNEWLINE "" ; isComposite ( 15 ) ? cout << "" ▁ true STRNEWLINE "" : cout << "" ▁ false STRNEWLINE "" ; return 0 ; }","['bool isComposite ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isComposite ( int n ) {
"
800,"Pandigital number in a given base | C ++ program to check if a number is pandigital in given base . ; Return true if n is pandigit else return false . ; Checking length is less than base ; Traversing each digit of the number . ; If digit is integer ; If digit is alphabet ; Checking hash array , if any index is unmarked . ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } int main ( ) { int b = 13 ; char n [ ] = ""1298450376ABC "" ; ( checkPandigital ( b , n ) ) ? ( cout << "" Yes "" << endl ) : ( cout << "" No "" << endl ) ; return 0 ; }",Pandigital number in a given base.,"#include <bits/stdc++.h> 
 using namespace std ; bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } int main ( ) { int b = 13 ; char n [ ] = ""1298450376ABC "" ; ( checkPandigital ( b , n ) ) ? ( cout << "" Yes "" << endl ) : ( cout << "" No "" << endl ) ; return 0 ; }","['bool checkPandigital ( int b , char n [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool checkPandigital ( int b , char n [ ] ) {
"
801,Convert a number m to n using minimum number of given operations | C ++ implementation to convert a number m to n using minimum number of given operations ; Function to find minimum number of given operations to convert m to n ; only way is to do - 1 ( m - n ) times ; not possible ; n is greater and n is odd ; perform ' - 1' on m ( or + 1 on n ) ; n is even ; perform ' * 2' on m ( or n / 2 on n ) ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return -1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } int main ( ) { int m = 3 , n = 11 ; cout << "" Minimum ▁ number ▁ of ▁ operations ▁ : ▁ "" << convert ( m , n ) ; return 0 ; }",Convert a number m to n using minimum number of given operations.,"#include <bits/stdc++.h> 
 using namespace std ; int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return -1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } int main ( ) { int m = 3 , n = 11 ; cout << "" Minimum ▁ number ▁ of ▁ operations ▁ : ▁ "" << convert ( m , n ) ; return 0 ; }","['int convert ( int m , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int convert ( int m , int n ) {
"
803,Number with maximum number of prime factors | C ++ program to find integer having maximum number of prime factor in first N natural numbers . ; Return smallest number having maximum prime factors . ; Sieve of eratosthenes method to count number of prime factors . ; Finding number having maximum number of prime factor . ; Driven Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { int arr [ N + 5 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }",Number with maximum number of prime factors.,"#include <bits/stdc++.h> 
 using namespace std ; int maxPrimefactorNum ( int N ) { int arr [ N + 5 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }","['int maxPrimefactorNum ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxPrimefactorNum ( int N ) {
"
804,Sum of all Subarrays | Set 1 | Efficient C ++ program to compute sum of subarray elements ; function compute sum all sub - array ; computing sum of subarray using formula ; return all subarray sum ; driver program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Sum ▁ of ▁ SubArray ▁ : ▁ "" << SubArraySum ( arr , n ) << endl ; return 0 ; }",Sum of all Subarrays.,"#include <bits/stdc++.h> 
 using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Sum ▁ of ▁ SubArray ▁ : ▁ "" << SubArraySum ( arr , n ) << endl ; return 0 ; }","['int SubArraySum ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long int SubArraySum ( int arr [ ] , int n ) {
"
805,Highest power of 2 less than or equal to given number | C ++ program to find highest power of 2 smaller than or equal to n . ; If i is a power of 2 ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; },Highest power of 2 less than or equal to given number.,"#include <bits/stdc++.h> 
 using namespace std ; int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }","['int highestPowerof2 ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int highestPowerof2 ( int n ) {
"
806,"Find Cube Pairs | Set 2 ( A n ^ ( 1 / 3 ) Solution ) | C ++ program to find pairs that can represent the given number as sum of two cubes ; Function to find pairs that can represent the given number as sum of two cubes ; find cube root of n ; create a array of size of size ' cubeRoot ' ; for index i , cube [ i ] will contain i ^ 3 ; Find all pairs in above sorted array cube [ ] whose sum is equal to n ; Driver function","#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; int cube [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { cout << "" ( "" << l << "" , ▁ "" << r << "" ) "" << endl ; l ++ ; r -- ; } } } int main ( ) { int n = 20683 ; findPairs ( n ) ; return 0 ; }",Find Cube Pairs.,"#include <iostream> 
 #include <cmath> 
 using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; int cube [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { cout << "" ( "" << l << "" , ▁ "" << r << "" ) "" << endl ; l ++ ; r -- ; } } } int main ( ) { int n = 20683 ; findPairs ( n ) ; return 0 ; }","['void findPairs ( int n ) {', 'int main ( ) {']","#include <iostream> 
 #include <cmath> 
 using namespace std ;
 void findPairs ( int n ) {
"
807,"Find Cube Pairs | Set 1 ( A n ^ ( 2 / 3 ) Solution ) | C ++ program to find pairs that can represent the given number as sum of two cubes ; Function to find pairs that can represent the given number as sum of two cubes ; find cube root of n ; create an empty map ; Consider all pairs such with values less than cuberoot ; find sum of current pair ( x , y ) ; do nothing if sum is not equal to given number ; if sum is seen before , we found two pairs ; if sum is seen for the first time ; Driver function","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; unordered_map < int , pair < int , int > > s ; for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) { int sum = x * x * x + y * y * y ; if ( sum != n ) continue ; if ( s . find ( sum ) != s . end ( ) ) { cout << "" ( "" << s [ sum ] . first << "" , ▁ "" << s [ sum ] . second << "" ) ▁ and ▁ ( "" << x << "" , ▁ "" << y << "" ) "" << endl ; } else s [ sum ] = make_pair ( x , y ) ; } } } int main ( ) { int n = 13832 ; findPairs ( n ) ; return 0 ; }",Find Cube Pairs.,"#include <bits/stdc++.h> 
 using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; unordered_map < int , pair < int , int > > s ; for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) { int sum = x * x * x + y * y * y ; if ( sum != n ) continue ; if ( s . find ( sum ) != s . end ( ) ) { cout << "" ( "" << s [ sum ] . first << "" , ▁ "" << s [ sum ] . second << "" ) ▁ and ▁ ( "" << x << "" , ▁ "" << y << "" ) "" << endl ; } else s [ sum ] = make_pair ( x , y ) ; } } } int main ( ) { int n = 13832 ; findPairs ( n ) ; return 0 ; }","['void findPairs ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findPairs ( int n ) {
"
809,Find all divisors of a natural number | Set 2 | A O ( sqrt ( n ) ) program that prints all divisors in sorted order ; function to print the divisors ; Vector to store half of the divisors ; check if divisors are equal ; push the second divisor in the vector ; The vector will be printed in reverse ; Driver program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( "" % d ▁ "" , i ) ; else { printf ( "" % d ▁ "" , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( "" % d ▁ "" , v [ i ] ) ; } int main ( ) { printf ( "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ n "" ) ; printDivisors ( 100 ) ; return 0 ; }",Find all divisors of a natural number.,"#include <bits/stdc++.h> 
 using namespace std ; void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( "" % d ▁ "" , i ) ; else { printf ( "" % d ▁ "" , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( "" % d ▁ "" , v [ i ] ) ; } int main ( ) { printf ( "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ n "" ) ; printDivisors ( 100 ) ; return 0 ; }","['void printDivisors ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printDivisors ( int n ) {
"
810,Find all divisors of a natural number | Set 2 | A O ( sqrt ( n ) ) program that prints all divisors in sorted order ; Function to print the divisors ; Driver code,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) cout << i << "" ▁ "" ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) cout << n / i << "" ▁ "" ; } } int main ( ) { cout << "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE "" ; printDivisors ( 100 ) ; return 0 ; }",Find all divisors of a natural number.,"#include <iostream> 
 #include <math.h> 
 using namespace std ; void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) cout << i << "" ▁ "" ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) cout << n / i << "" ▁ "" ; } } int main ( ) { cout << "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE "" ; printDivisors ( 100 ) ; return 0 ; }","['void printDivisors ( int n ) {', 'int main ( ) {']","#include <iostream> 
 #include <math.h> 
 using namespace std ;
 void printDivisors ( int n ) {
"
811,Find all factors of a natural number | Set 1 | C ++ implementation of Naive method to print all divisors ; function to print the divisors ; Driver program to test above function,"#include <iostream> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << "" ▁ "" << i ; } int main ( ) { cout << "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE "" ; printDivisors ( 100 ) ; return 0 ; }",Find all factors of a natural number.,"#include <iostream> 
 using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << "" ▁ "" << i ; } int main ( ) { cout << "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE "" ; printDivisors ( 100 ) ; return 0 ; }","['void printDivisors ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void printDivisors ( int n ) {
"
812,"Find all factors of a natural number | Set 1 | A Better ( than Naive ) Solution to find all divisiors ; Function to print the divisors ; Note that this loop runs till square root ; If divisors are equal , print only one ; else Otherwise print both ; Driver program to test above function","#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << "" ▁ "" << i ; cout << "" ▁ "" << i << "" ▁ "" << n / i ; } } } int main ( ) { cout << "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE "" ; printDivisors ( 100 ) ; return 0 ; }",Find all factors of a natural number.,"#include <iostream> 
 #include <math.h> 
 using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << "" ▁ "" << i ; cout << "" ▁ "" << i << "" ▁ "" << n / i ; } } } int main ( ) { cout << "" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE "" ; printDivisors ( 100 ) ; return 0 ; }","['void printDivisors ( int n ) {', 'int main ( ) {']","#include <iostream> 
 #include <math.h> 
 using namespace std ;
 void printDivisors ( int n ) {
"
813,"Sieve of Atkin | C ++ program for implementation of Sieve of Atkin ; 2 and 3 are known to be prime ; Initialise the sieve array with false values ; Mark sieve [ n ] is true if one of the following is true : a ) n = ( 4 * x * x ) + ( y * y ) has odd number of solutions , i . e . , there exist odd number of distinct pairs ( x , y ) that satisfy the equation and n % 12 = 1 or n % 12 = 5. b ) n = ( 3 * x * x ) + ( y * y ) has odd number of solutions and n % 12 = 7 c ) n = ( 3 * x * x ) - ( y * y ) has odd number of solutions , x > y and n % 12 = 11 ; Main part of Sieve of Atkin ; Mark all multiples of squares as non - prime ; Print primes using sieve [ ] ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << "" ▁ "" ; if ( limit > 3 ) cout << 3 << "" ▁ "" ; bool sieve [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) cout << a << "" ▁ "" ; } int main ( void ) { int limit = 20 ; SieveOfAtkin ( limit ) ; return 0 ; }",Sieve of Atkin.,"#include <bits/stdc++.h> 
 using namespace std ; int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << "" ▁ "" ; if ( limit > 3 ) cout << 3 << "" ▁ "" ; bool sieve [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) cout << a << "" ▁ "" ; } int main ( void ) { int limit = 20 ; SieveOfAtkin ( limit ) ; return 0 ; }","['int SieveOfAtkin ( int limit ) {', 'int main ( void ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int SieveOfAtkin ( int limit ) {
"
814,Find if a point lies inside a Circle | C ++ program to check if a point lies inside a circle or not ; Compare radius of circle with distance of its center from given point ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } int main ( ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; isInside ( circle_x , circle_y , rad , x , y ) ? cout << "" Inside "" : cout << "" Outside "" ; }",Find if a point lies inside a Circle.,"#include <bits/stdc++.h> 
 using namespace std ; bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } int main ( ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; isInside ( circle_x , circle_y , rad , x , y ) ? cout << "" Inside "" : cout << "" Outside "" ; }","['bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) {
"
815,"Find all possible outcomes of a given expression | C ++ program to evaluate all possible values of a expression ; Utility function to evaluate a simple expression with one operator only . ; This function evaluates all possible values and returns a list of evaluated values . ; To store result ( all possible evaluations of given expression ' expr ' ) ; If there is only one character , it must be a digit ( or operand ) , return it . ; If there are only three characters , middle one must be operator and corner ones must be operand ; every i refers to an operator ; l refers to all the possible values in the left of operator ' expr [ i ] ' ; r refers to all the possible values in the right of operator ' expr [ i ] ' ; Take above evaluated all possible values in left side of ' i ' ; Take above evaluated all possible values in right side of ' i ' ; Calculate value for every pair and add the value to result . ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int eval ( int a , char op , int b ) { if ( op == ' + ' ) return a + b ; if ( op == ' - ' ) return a - b ; if ( op == ' * ' ) return a * b ; } vector < int > evaluateAll ( string expr , int low , int high ) { vector < int > res ; if ( low == high ) { res . push_back ( expr [ low ] - '0' ) ; return res ; } if ( low == ( high - 2 ) ) { int num = eval ( expr [ low ] - '0' , expr [ low + 1 ] , expr [ low + 2 ] - '0' ) ; res . push_back ( num ) ; return res ; } for ( int i = low + 1 ; i <= high ; i += 2 ) { vector < int > l = evaluateAll ( expr , low , i - 1 ) ; vector < int > r = evaluateAll ( expr , i + 1 , high ) ; for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) { for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) { int val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) ; res . push_back ( val ) ; } } } return res ; } int main ( ) { string expr = ""1*2 + 3*4"" ; int len = expr . length ( ) ; vector < int > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << endl ; return 0 ; }",Find all possible outcomes of a given expression.,"#include <bits/stdc++.h> 
 using namespace std ; int eval ( int a , char op , int b ) { if ( op == ' + ' ) return a + b ; if ( op == ' - ' ) return a - b ; if ( op == ' * ' ) return a * b ; } vector < int > evaluateAll ( string expr , int low , int high ) { vector < int > res ; if ( low == high ) { res . push_back ( expr [ low ] - '0' ) ; return res ; } if ( low == ( high - 2 ) ) { int num = eval ( expr [ low ] - '0' , expr [ low + 1 ] , expr [ low + 2 ] - '0' ) ; res . push_back ( num ) ; return res ; } for ( int i = low + 1 ; i <= high ; i += 2 ) { vector < int > l = evaluateAll ( expr , low , i - 1 ) ; vector < int > r = evaluateAll ( expr , i + 1 , high ) ; for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) { for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) { int val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) ; res . push_back ( val ) ; } } } return res ; } int main ( ) { string expr = ""1*2 + 3*4"" ; int len = expr . length ( ) ; vector < int > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << endl ; return 0 ; }","['int eval ( int a , char op , int b ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int eval ( int a , char op , int b ) {
"
816,"Program to check if a given number is Lucky ( all digits are different ) | C ++ program to check if a given number is lucky ; This function returns true if n is lucky ; Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not . ; Traverse through all digits of given number ; Find the last digit ; If digit is already seen , return false ; Mark this digit as seen ; REmove the last digit from number ; Driver program to test above function .","#include <iostream> NEW_LINE using namespace std ; bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } int main ( ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) isLucky ( arr [ i ] ) ? cout << arr [ i ] << "" ▁ is ▁ Lucky ▁ STRNEWLINE "" : cout << arr [ i ] << "" ▁ is ▁ not ▁ Lucky ▁ STRNEWLINE "" ; return 0 ; }",Program to check if a given number is Lucky ( all digits are different ).,"#include <iostream> 
 using namespace std ; bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } int main ( ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) isLucky ( arr [ i ] ) ? cout << arr [ i ] << "" ▁ is ▁ Lucky ▁ STRNEWLINE "" : cout << arr [ i ] << "" ▁ is ▁ not ▁ Lucky ▁ STRNEWLINE "" ; return 0 ; }","['bool isLucky ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 bool isLucky ( int n ) {
"
817,"Print squares of first n natural numbers without using * , / and | C ++ program to print squares of first ' n ' natural numbers wothout using * , / and - ; Initialize ' square ' and first odd number ; Calculate and print squares ; Print square ; Update ' square ' and ' odd ' ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << "" ▁ "" ; square = square + odd ; odd = odd + 2 ; } } int main ( ) { int n = 5 ; printSquares ( n ) ; }","Print squares of first n natural numbers without using * , / and.","#include <iostream> 
 using namespace std ; void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << "" ▁ "" ; square = square + odd ; odd = odd + 2 ; } } int main ( ) { int n = 5 ; printSquares ( n ) ; }","['void printSquares ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 void printSquares ( int n ) {
"
818,Write a program to reverse digits of a number | C ++ program to reverse digits of a number ; Recursive function to reverse digits of num ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } int main ( ) { int num = 4562 ; cout << "" Reverse ▁ of ▁ no . ▁ is ▁ "" << reversDigits ( num ) ; return 0 ; }",Write a program to reverse digits of a number.,"#include <bits/stdc++.h> 
 using namespace std ; int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } int main ( ) { int num = 4562 ; cout << "" Reverse ▁ of ▁ no . ▁ is ▁ "" << reversDigits ( num ) ; return 0 ; }","['int reversDigits ( int num ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int reversDigits ( int num ) {
"
820,Count of elements which are equal to the XOR of the next two elements | C ++ implementation of the approach ; Function to return the count of elements which are equal to the XOR of the next two elements ; To store the required count ; For every element of the array such that it has at least two elements appearing after it in the array ; If current element is equal to the XOR of the next two elements in the array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntElements ( arr , n ) ; return 0 ; }",Count of elements which are equal to the XOR of the next two elements.,"#include <bits/stdc++.h> 
 using namespace std ; int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntElements ( arr , n ) ; return 0 ; }","['int cntElements ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int cntElements ( int arr [ ] , int n ) {
"
821,Number of triplets in array having subarray xor equal | A simple C ++ program to find Number of triplets in array having subarray xor equal ; Function to return the count ; Initialise result ; Pick 1 st element of the triplet ; Pick 2 nd element of the triplet ; Pick 3 rd element of the triplet ; Taking xor in the first subarray ; Taking xor in the second subarray ; If both xor is equal ; Driver Code ; Function Calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xor_triplet ( arr , n ) ; return 0 ; }",Number of triplets in array having subarray xor equal.,"#include <bits/stdc++.h> 
 using namespace std ; int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xor_triplet ( arr , n ) ; return 0 ; }","['int xor_triplet ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int xor_triplet ( int arr [ ] , int n ) {
"
824,Print bitwise AND set of a number N | CPP program to print all bitwise subsets of N ( Efficient approach ) ; function to find bitwise subsets Efficient approach ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << "" ▁ "" ; cout << 0 ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }",Print bitwise AND set of a number N.,"#include <bits/stdc++.h> 
 using namespace std ; void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << "" ▁ "" ; cout << 0 ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }","['void printSubsets ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printSubsets ( int n ) {
"
825,"Check if a number is divisible by 17 using bitwise operators | CPP program to check if a number is divisible by 17 or not using bitwise operator . ; function to check recursively if the number is divisible by 17 or not ; if n = 0 or n = 17 then yes ; if n is less then 17 , not divisible by 17 ; reducing the number by floor ( n / 16 ) - n % 16 ; driver code to check the above function","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } int main ( ) { int n = 35 ; if ( isDivisibleby17 ( n ) ) cout << n << "" ▁ is ▁ divisible ▁ by ▁ 17"" ; else cout << n << "" ▁ is ▁ not ▁ divisible ▁ by ▁ 17"" ; return 0 ; }",Check if a number is divisible by 17 using bitwise operators.,"#include <bits/stdc++.h> 
 using namespace std ; bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } int main ( ) { int n = 35 ; if ( isDivisibleby17 ( n ) ) cout << n << "" ▁ is ▁ divisible ▁ by ▁ 17"" ; else cout << n << "" ▁ is ▁ not ▁ divisible ▁ by ▁ 17"" ; return 0 ; }","['bool isDivisibleby17 ( int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isDivisibleby17 ( int n ) {
"
826,Largest number with binary representation is m 1 's and m | CPP program to find largest number smaller than equal to n with m set bits then m - 1 0 bits . ; Returns largest number with m set bits then m - 1 0 bits . ; Start with 2 bits . ; initial answer is 1 which meets the given condition ; check for all numbers ; compute the number ; if less then N ; increment m to get the next number ; driver code to check the above condition,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } int main ( ) { long long n = 7 ; cout << answer ( n ) ; return 0 ; }",Largest number with binary representation is m 1 's and m.,"#include <bits/stdc++.h> 
 using namespace std ; long long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } int main ( ) { long long n = 7 ; cout << answer ( n ) ; return 0 ; }","['long answer ( long long n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 long long answer ( long long n ) {
"
827,Find most significant set bit of a number | Simple CPP program to find MSB number for given n . ; Driver code,#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; } int main ( ) { int n = 0 ; cout << setBitNumber ( n ) ; return 0 ; },Find most significant set bit of a number.,"#include <iostream> 
 using namespace std ; int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; } int main ( ) { int n = 0 ; cout << setBitNumber ( n ) ; return 0 ; }","['int setBitNumber ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int setBitNumber ( int n ) {
"
828,Find most significant set bit of a number | CPP program to find MSB number for given n . ; Suppose n is 273 ( binary is 100010001 ) . It does following 100010001 | 010001000 = 110011001 ; This makes sure 4 bits ( From MSB and including MSB ) are set . It does following 110011001 | 001100110 = 111111111 ; Increment n by 1 so that there is only one set bit which is just before original MSB . n now becomes 1000000000 ; Return original MSB after shifting . n now becomes 100000000 ; Driver code,#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; },Find most significant set bit of a number.,"#include <iostream> 
 using namespace std ; int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; }","['int setBitNumber ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int setBitNumber ( int n ) {
"
829,Count trailing zero bits using lookup table | Simple C ++ code for counting trailing zeros in binary representation of a number ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } int main ( ) { cout << countTrailingZero ( 11 ) << endl ; return 0 ; },Count trailing zero bits using lookup table.,"#include <bits/stdc++.h> 
 using namespace std ; int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } int main ( ) { cout << countTrailingZero ( 11 ) << endl ; return 0 ; }","['int countTrailingZero ( int x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countTrailingZero ( int x ) {
"
830,Count trailing zero bits using lookup table | C ++ code for counting trailing zeros in binary representation of a number ; Map a bit value mod 37 to its position ; Only difference between ( x and - x ) is the value of signed magnitude ( leftmostbit ) negative numbers signed bit is 1 ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; } int main ( ) { cout << countTrailingZero ( 48 ) << endl ; return 0 ; }",Count trailing zero bits using lookup table.,"#include <bits/stdc++.h> 
 using namespace std ; int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; } int main ( ) { cout << countTrailingZero ( 48 ) << endl ; return 0 ; }","['int countTrailingZero ( int x ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countTrailingZero ( int x ) {
"
831,Calculate 7 n / 8 without using division and multiplication operators | C ++ program to evaluate ceil ( 7 n / 8 ) without using * and / ; Note the inner bracket here . This is needed because precedence of ' - ' operator is higher than ' < < ' ; Driver code,#include <iostream> NEW_LINE using namespace std ; int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { int n = 9 ; cout << multiplyBySevenByEight ( n ) ; return 0 ; },Calculate 7 n / 8 without using division and multiplication operators.,"#include <iostream> 
 using namespace std ; int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { int n = 9 ; cout << multiplyBySevenByEight ( n ) ; return 0 ; }","['int multiplyBySevenByEight ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int multiplyBySevenByEight ( int n ) {
"
833,Maximize Sum possible by subtracting same value from all elements of a Subarray of the given Array | C ++ program to implement the above approach ; Function to generate previous smaller element for each array element ; The first element has no previous smaller ; Stack to keep track of elements that have occurred previously ; Push the first index ; Pop all the elements until the previous element is smaller than current element ; Store the previous smaller element ; Push the index of the current element ; Return the array ; Function to generate next smaller element for each array element ; Stack to keep track of elements that have occurring next ; Iterate in reverse order for calculating next smaller ; Pop all the elements until the next element is smaller than current element ; Store the next smaller element ; Push the index of the current element ; Return the array ; Function to find the maximum sum by subtracting same value from all elements of a Subarray ; Stores previous smaller element ; Stores next smaller element ; Calculate contribution of each element ; Return answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findPrevious ( vector < int > a , int n ) { vector < int > ps ( n ) ; ps [ 0 ] = -1 ; stack < int > Stack ; Stack . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ps [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : -1 ; Stack . push ( i ) ; } return ps ; } vector < int > findNext ( vector < int > a , int n ) { vector < int > ns ( n ) ; ns [ n - 1 ] = n ; stack < int > Stack ; Stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ns [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : n ; Stack . push ( i ) ; } return ns ; } int findMaximumSum ( vector < int > a , int n ) { vector < int > prev_smaller = findPrevious ( a , n ) ; vector < int > next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } int main ( ) { int n = 3 ; vector < int > a { 80 , 48 , 82 } ; cout << findMaximumSum ( a , n ) ; return 0 ; }",Maximize Sum possible by subtracting same value from all elements of a Subarray of the given Array.,"#include <bits/stdc++.h> 
 using namespace std ; vector < int > findPrevious ( vector < int > a , int n ) { vector < int > ps ( n ) ; ps [ 0 ] = -1 ; stack < int > Stack ; Stack . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ps [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : -1 ; Stack . push ( i ) ; } return ps ; } vector < int > findNext ( vector < int > a , int n ) { vector < int > ns ( n ) ; ns [ n - 1 ] = n ; stack < int > Stack ; Stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ns [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : n ; Stack . push ( i ) ; } return ns ; } int findMaximumSum ( vector < int > a , int n ) { vector < int > prev_smaller = findPrevious ( a , n ) ; vector < int > next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } int main ( ) { int n = 3 ; vector < int > a { 80 , 48 , 82 } ; cout << findMaximumSum ( a , n ) ; return 0 ; }","['int findMaximumSum ( vector < int > a , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 vector < int > findPrevious ( vector < int > a , int n ) {
 vector < int > ps ( n ) ;
 ps [ 0 ] = -1 ;
 stack < int > Stack ;
 Stack . push ( 0 ) ;
 for ( int i = 1 ;
 i < n ;
 i ++ ) {
 while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ;
 ps [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : -1 ;
 Stack . push ( i ) ;
 } return ps ;
 } vector < int > findNext ( vector < int > a , int n ) {
 vector < int > ns ( n ) ;
 ns [ n - 1 ] = n ;
 stack < int > Stack ;
 Stack . push ( n - 1 ) ;
 for ( int i = n - 2 ;
 i >= 0 ;
 i -- ) {
 while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ;
 ns [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : n ;
 Stack . push ( i ) ;
 } return ns ;
 } int findMaximumSum ( vector < int > a , int n ) {
"
835,Maximize the median of the given array after adding K elements to the same array | C ++ implementation of the approach ; Function to return the maximized median ; Sort the array ; If size is even ; If size is odd ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << getMaxMedian ( arr , n , k ) ; return 0 ; }",Maximize the median of the given array after adding K elements to the same array.,"#include <bits/stdc++.h> 
 using namespace std ; float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << getMaxMedian ( arr , n , k ) ; return 0 ; }","['float getMaxMedian ( int arr [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float getMaxMedian ( int arr [ ] , int n , int k ) {
"
836,Sort 3 Integers without using if condition or using only max ( ) function | C ++ program to print three numbers in sorted order using max function ; Find maximum element ; Find minimum element ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << "" ▁ "" << get_mid << "" ▁ "" << get_max ; } int main ( ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; return 0 ; }",Sort 3 Integers without using if condition or using only max ( ) function.,"#include <bits/stdc++.h> 
 using namespace std ; void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << "" ▁ "" << get_mid << "" ▁ "" << get_max ; } int main ( ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; return 0 ; }","['void printSorted ( int a , int b , int c ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void printSorted ( int a , int b , int c ) {
"
839,"Count of distinct permutation of a String obtained by swapping only unequal characters | C ++ program for the above approach ; Function to calculate total number of valid permutations ; Creating count which is equal to the Total number of characters present and ans that will store the number of unique permutations ; Storing frequency of each character present in the string ; Adding count of characters by excluding characters equal to current char ; Reduce the frequency of the current character and count by 1 , so that it cannot interfere with the calculations of the same elements present to the right of it . ; Return ans + 1 ( Because the given string is also a unique permutation ) ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int validPermutations ( string str ) { unordered_map < char , int > m ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m [ str [ i ] ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m [ str [ i ] ] ; m [ str [ i ] ] -- ; count -- ; } return ans + 1 ; } int main ( ) { string str = "" sstt "" ; cout << validPermutations ( str ) ; return 0 ; }",Count of distinct permutation of a String obtained by swapping only unequal characters.,"#include <bits/stdc++.h> 
 using namespace std ; int validPermutations ( string str ) { unordered_map < char , int > m ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m [ str [ i ] ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m [ str [ i ] ] ; m [ str [ i ] ] -- ; count -- ; } return ans + 1 ; } int main ( ) { string str = "" sstt "" ; cout << validPermutations ( str ) ; return 0 ; }","['int validPermutations ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int validPermutations ( string str ) {
"
840,Counts paths from a point to reach Origin | C ++ program to count total number of paths from a point to origin ; DP based function to count number of paths ; Fill entries in bottommost row and leftmost columns ; Fill DP in bottom up manner ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 2 ; cout << "" ▁ Number ▁ of ▁ Paths ▁ "" << countPaths ( n , m ) ; return 0 ; }",Counts paths from a point to reach Origin.,"#include <bits/stdc++.h> 
 using namespace std ; int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 2 ; cout << "" ▁ Number ▁ of ▁ Paths ▁ "" << countPaths ( n , m ) ; return 0 ; }","['int countPaths ( int n , int m ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int countPaths ( int n , int m ) {
"
841,"Coin Change | DP | Recursive C ++ program for coin change problem . ; Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n ; If n is 0 then there is 1 solution ( do not include any coin ) ; If n is less than 0 then no solution exists ; If there are no coins and n is greater than 0 , then no solution exist ; count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ] ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" ▁ "" << count ( arr , m , 4 ) ; return 0 ; }",Coin Change.,"#include <bits/stdc++.h> 
 using namespace std ; int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" ▁ "" << count ( arr , m , 4 ) ; return 0 ; }","['int count ( int S [ ] , int m , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int count ( int S [ ] , int m , int n ) {
"
842,Coin Change | DP | Either Pick this coin or not ; else We have no option but to leave this coin ; cin >> tc ;,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int coinchange ( vector < int > & a , int v , int n , vector < vector < int > > & dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != -1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) { return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; } return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; } int32_t main ( ) { int tc = 1 ; while ( tc -- ) { int n , v ; n = 3 , v = 4 ; vector < int > a = { 1 , 2 , 3 } ; vector < vector < int > > dp ( n + 1 , vector < int > ( v + 1 , -1 ) ) ; int res = coinchange ( a , v , n , dp ) ; cout << res << endl ; } }",Coin Change.,"#include <bits/stdc++.h> 
 using namespace std ; int coinchange ( vector < int > & a , int v , int n , vector < vector < int > > & dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != -1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) { return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; } return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; } int32_t main ( ) { int tc = 1 ; while ( tc -- ) { int n , v ; n = 3 , v = 4 ; vector < int > a = { 1 , 2 , 3 } ; vector < vector < int > > dp ( n + 1 , vector < int > ( v + 1 , -1 ) ) ; int res = coinchange ( a , v , n , dp ) ; cout << res << endl ; } }","['int coinchange ( vector < int > & a , int v , int n , vector < vector < int > > & dp ) {', 'int32_t main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int coinchange ( vector < int > & a , int v , int n , vector < vector < int > > & dp ) {
"
844,Replace every consonant sequence with its length in the given string | C ++ implementation of the approach ; Function to return the converted string after replacing every consonant sequence with its length ; To store the resultant string ; Checking each character for consonant sequence ; Count the length of consonants sequence ; Add the length in the string ; Add the vowel ; Check for the last consonant sequence in the string ; Return the resultant string ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string replaceConsonants ( string str ) { string res = "" "" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += to_string ( count ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += to_string ( count ) ; return res ; } int main ( ) { string str = "" abcdeiop "" ; cout << replaceConsonants ( str ) ; return 0 ; }",Replace every consonant sequence with its length in the given string.,"#include <bits/stdc++.h> 
 using namespace std ; string replaceConsonants ( string str ) { string res = "" "" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += to_string ( count ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += to_string ( count ) ; return res ; } int main ( ) { string str = "" abcdeiop "" ; cout << replaceConsonants ( str ) ; return 0 ; }","['string replaceConsonants ( string str ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string replaceConsonants ( string str ) {
"
846,String containing first letter of every word in a given string with spaces | C ++ implementation of the above approach ; we are splitting the input based on spaces ( s ) + : this regular expression will handle scenarios where we have words separated by multiple spaces ; charAt ( 0 ) will pick only the first character from the string and append to buffer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string processWords ( char * input ) { char * p ; vector < string > s ; p = strtok ( input , "" ▁ "" ) ; while ( p != NULL ) { s . push_back ( p ) ; p = strtok ( NULL , "" ▁ "" ) ; } string charBuffer ; for ( string values : s ) charBuffer += values [ 0 ] ; return charBuffer ; } int main ( ) { char input [ ] = "" geeks ▁ for ▁ geeks "" ; cout << processWords ( input ) ; return 0 ; }",String containing first letter of every word in a given string with spaces.,"#include <bits/stdc++.h> 
 using namespace std ; string processWords ( char * input ) { char * p ; vector < string > s ; p = strtok ( input , "" ▁ "" ) ; while ( p != NULL ) { s . push_back ( p ) ; p = strtok ( NULL , "" ▁ "" ) ; } string charBuffer ; for ( string values : s ) charBuffer += values [ 0 ] ; return charBuffer ; } int main ( ) { char input [ ] = "" geeks ▁ for ▁ geeks "" ; cout << processWords ( input ) ; return 0 ; }","['string processWords ( char * input ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string processWords ( char * input ) {
"
848,Largest right circular cylinder within a cube | C ++ Program to find the biggest right circular cylinder that can be fit within a cube ; Function to find the biggest right circular cylinder ; side cannot be negative ; radius of right circular cylinder ; height of right circular cylinder ; volume of right circular cylinder ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << findVolume ( a ) << endl ; return 0 ; }",Largest right circular cylinder within a cube.,"#include <bits/stdc++.h> 
 using namespace std ; float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << findVolume ( a ) << endl ; return 0 ; }","['float findVolume ( float a ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 float findVolume ( float a ) {
"
850,Program to find area of a Trapezoid | C ++ program to calculate area of a trapezoid ; Function for the area ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } int main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; cout << "" Area ▁ is : ▁ "" << area ; return 0 ; }",Program to find area of a Trapezoid.,"#include <bits/stdc++.h> 
 using namespace std ; double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } int main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; cout << "" Area ▁ is : ▁ "" << area ; return 0 ; }","['double Area ( int b1 , int b2 , int h ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 double Area ( int b1 , int b2 , int h ) {
"
851,Find number of diagonals in n sided convex polygon | C ++ function to find number of diagonals in n sided convex polygon ; driver code to test above function,"#include <iostream> NEW_LINE using namespace std ; int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; } int main ( ) { int n = 5 ; cout << n << "" ▁ sided ▁ convex ▁ polygon ▁ have ▁ "" ; cout << numberOfDiagonals ( n ) << "" ▁ diagonals "" ; return 0 ; }",Find number of diagonals in n sided convex polygon.,"#include <iostream> 
 using namespace std ; int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; } int main ( ) { int n = 5 ; cout << n << "" ▁ sided ▁ convex ▁ polygon ▁ have ▁ "" ; cout << numberOfDiagonals ( n ) << "" ▁ diagonals "" ; return 0 ; }","['int numberOfDiagonals ( int n ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int numberOfDiagonals ( int n ) {
"
852,Area of the largest Rectangle without a given point | C ++ implementation to find area of largest Rectangle without hole within a given Rectangle ; Function to find the maximum area such that it does not contains any hole ; Area for all the possible positions of the cut ; Find the maximum area among the above rectangles ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; cout << max ( max ( left , right ) , max ( above , below ) ) ; } int main ( ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( l , b , x , y ) ; return 0 ; }",Area of the largest Rectangle without a given point.,"#include <bits/stdc++.h> 
 using namespace std ; void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; cout << max ( max ( left , right ) , max ( above , below ) ) ; } int main ( ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( l , b , x , y ) ; return 0 ; }","['void maximumArea ( int l , int b , int x , int y ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void maximumArea ( int l , int b , int x , int y ) {
"
853,"Minimize cost of removals required to make all remaining characters of the string unique | C ++ program for the above approach ; Function to find the minimum cost of removing characters to make the string unique ; Store the minimum cost required ; Create a dictionary to store the maximum cost of removal a character ; Create a dictionary to store the total deletion cost of a character ; Traverse the string , S ; Keep track of maximum cost of each character ; Update the maximum deletion cost ; Keep track of the total cost of each character ; Update the total deletion cost ; Traverse through all the unique characters ; Keep the maximum cost character and delete the rest ; Return the answer ; Driver code ; Given string ; Given cost array ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int delCost ( string s , int cost [ ] ) { int ans = 0 ; map < char , int > forMax ; map < char , int > forTot ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax [ s [ i ] ] ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot [ s [ i ] ] ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] = forTot [ s [ i ] ] + cost [ i ] ; } } for ( auto i : forMax ) { ans += forTot [ i . first ] - i . second ; } return ans ; } int main ( ) { string s = "" AAABBB "" ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; cout << ( delCost ( s , cost ) ) ; }",Minimize cost of removals required to make all remaining characters of the string unique.,"#include <bits/stdc++.h> 
 using namespace std ; int delCost ( string s , int cost [ ] ) { int ans = 0 ; map < char , int > forMax ; map < char , int > forTot ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax [ s [ i ] ] ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot [ s [ i ] ] ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] = forTot [ s [ i ] ] + cost [ i ] ; } } for ( auto i : forMax ) { ans += forTot [ i . first ] - i . second ; } return ans ; } int main ( ) { string s = "" AAABBB "" ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; cout << ( delCost ( s , cost ) ) ; }","['int delCost ( string s , int cost [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int delCost ( string s , int cost [ ] ) {
"
855,"Count elements of same value placed at same indices of two given arrays | C ++ program for the above approach ; Function to count maximum matched elements from the arrays A [ ] and B [ ] ; Stores position of elements of array A [ ] in the array B [ ] ; Keep track of difference between the indices ; Traverse the array A [ ] ; Traverse the array B [ ] ; If difference is negative , add N to it ; Keep track of the number of shifts required to place elements at same indices ; Return the max matches ; Driver code ; Returns the count of matched elements","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMatch ( int A [ ] , int B [ ] , int M , int N ) { map < int , int > Aindex ; map < int , int > diff ; for ( int i = 0 ; i < M ; i ++ ) { Aindex [ A [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i - Aindex [ B [ i ] ] < 0 ) { diff [ M + i - Aindex [ B [ i ] ] ] += 1 ; } else { diff [ i - Aindex [ B [ i ] ] ] += 1 ; } } int max = 0 ; for ( auto ele = diff . begin ( ) ; ele != diff . end ( ) ; ele ++ ) { if ( ele -> second > max ) { max = ele -> second ; } } return max ; } int main ( ) { int A [ ] = { 5 , 3 , 7 , 9 , 8 } ; int B [ ] = { 8 , 7 , 3 , 5 , 9 } ; int M = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int N = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << maxMatch ( A , B , M , N ) ; return 0 ; }",Count elements of same value placed at same indices of two given arrays.,"#include <bits/stdc++.h> 
 using namespace std ; int maxMatch ( int A [ ] , int B [ ] , int M , int N ) { map < int , int > Aindex ; map < int , int > diff ; for ( int i = 0 ; i < M ; i ++ ) { Aindex [ A [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i - Aindex [ B [ i ] ] < 0 ) { diff [ M + i - Aindex [ B [ i ] ] ] += 1 ; } else { diff [ i - Aindex [ B [ i ] ] ] += 1 ; } } int max = 0 ; for ( auto ele = diff . begin ( ) ; ele != diff . end ( ) ; ele ++ ) { if ( ele -> second > max ) { max = ele -> second ; } } return max ; } int main ( ) { int A [ ] = { 5 , 3 , 7 , 9 , 8 } ; int B [ ] = { 8 , 7 , 3 , 5 , 9 } ; int M = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int N = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << maxMatch ( A , B , M , N ) ; return 0 ; }","['int maxMatch ( int A [ ] , int B [ ] , int M , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxMatch ( int A [ ] , int B [ ] , int M , int N ) {
"
858,"Check if a sequence of path visits any coordinate twice or not | C ++ program for the above approach ; Function to check if the man crosses previous visited coordinate or not ; Stores the count of crossed vertex ; Stores ( x , y ) coordinates ; The coordinates for the origin ; Iterate over the string ; Condition to increment X or Y co - ordinates respectively ; Check if ( x , y ) is already visited ; Print the result ; Driver Code ; Given string ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCrossed ( string path ) { if ( path . size ( ) == 0 ) return false ; bool ans = false ; set < pair < int , int > > set ; int x = 0 , y = 0 ; set . insert ( { x , y } ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { if ( path [ i ] == ' N ' ) set . insert ( { x , y ++ } ) ; if ( path [ i ] == ' S ' ) set . insert ( { x , y -- } ) ; if ( path [ i ] == ' E ' ) set . insert ( { x ++ , y } ) ; if ( path [ i ] == ' W ' ) set . insert ( { x -- , y } ) ; if ( set . find ( { x , y } ) != set . end ( ) ) { ans = true ; break ; } } if ( ans ) cout << "" Crossed "" ; else cout << "" Not ▁ Crossed "" ; } int main ( ) { string path = "" NESW "" ; isCrossed ( path ) ; return 0 ; }",Check if a sequence of path visits any coordinate twice or not.,"#include <bits/stdc++.h> 
 using namespace std ; bool isCrossed ( string path ) { if ( path . size ( ) == 0 ) return false ; bool ans = false ; set < pair < int , int > > set ; int x = 0 , y = 0 ; set . insert ( { x , y } ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { if ( path [ i ] == ' N ' ) set . insert ( { x , y ++ } ) ; if ( path [ i ] == ' S ' ) set . insert ( { x , y -- } ) ; if ( path [ i ] == ' E ' ) set . insert ( { x ++ , y } ) ; if ( path [ i ] == ' W ' ) set . insert ( { x -- , y } ) ; if ( set . find ( { x , y } ) != set . end ( ) ) { ans = true ; break ; } } if ( ans ) cout << "" Crossed "" ; else cout << "" Not ▁ Crossed "" ; } int main ( ) { string path = "" NESW "" ; isCrossed ( path ) ; return 0 ; }","['bool isCrossed ( string path ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isCrossed ( string path ) {
"
859,Maximum width of an N | C ++ program to implement the above approach ; Function to find the maximum width of the tree using level order traversal ; Store the edges of the tree ; Stores maximum width of the tree ; Stores the nodes of each level ; Insert root node ; Perform level order traversal on the tree ; Stores the size of the queue ; Update maximum width ; Push the nodes of the next level and pop the elements of the current level ; Get element from the front the Queue ; Push all nodes of the next level . ; Return the result . ; Driver Code ; Constructed tree is : 1 / | \ 2 - 1 3 / \ \ 4 5 8 / / | \ 2 6 12 7,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push_back ( s [ i ] [ 1 ] ) ; } int result = 0 ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; result = max ( count , result ) ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; } int main ( ) { int N = 11 , M = 10 ; vector < vector < int > > edges ; edges . push_back ( { 0 , 1 } ) ; edges . push_back ( { 0 , 2 } ) ; edges . push_back ( { 0 , 3 } ) ; edges . push_back ( { 1 , 4 } ) ; edges . push_back ( { 1 , 5 } ) ; edges . push_back ( { 3 , 6 } ) ; edges . push_back ( { 4 , 7 } ) ; edges . push_back ( { 6 , 10 } ) ; edges . push_back ( { 6 , 8 } ) ; edges . push_back ( { 6 , 9 } ) ; vector < int > cost = { 1 , 2 , -1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 } ; cout << maxWidth ( N , M , cost , edges ) ; return 0 ; }",Maximum width of an N.,"#include <bits/stdc++.h> 
 using namespace std ; int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push_back ( s [ i ] [ 1 ] ) ; } int result = 0 ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; result = max ( count , result ) ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; } int main ( ) { int N = 11 , M = 10 ; vector < vector < int > > edges ; edges . push_back ( { 0 , 1 } ) ; edges . push_back ( { 0 , 2 } ) ; edges . push_back ( { 0 , 3 } ) ; edges . push_back ( { 1 , 4 } ) ; edges . push_back ( { 1 , 5 } ) ; edges . push_back ( { 3 , 6 } ) ; edges . push_back ( { 4 , 7 } ) ; edges . push_back ( { 6 , 10 } ) ; edges . push_back ( { 6 , 8 } ) ; edges . push_back ( { 6 , 9 } ) ; vector < int > cost = { 1 , 2 , -1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 } ; cout << maxWidth ( N , M , cost , edges ) ; return 0 ; }","['int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) {
"
861,Count ways to split a Binary String into three substrings having equal count of zeros | C ++ implementation for the above approach ; Function to return ways to split a string into three parts with the equal number of 0 ; Store total count of 0 s ; Count total no . of 0 s character in given string ; If total count of 0 character is not divisible by 3 ; Initialize mp to store frequency of k ; Traverse string to find ways to split string ; Increment count if 0 appears ; Increment result if sum equal to 2 * k and k exists in mp ; Insert sum in mp ; Return result ; Driver Code ; Given string ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string s ) { int cnt = 0 ; for ( char c : s ) { cnt += c == '0' ? 1 : 0 ; } if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += s [ i ] == '0' ? 1 : 0 ; if ( sum == 2 * k && mp . find ( k ) != mp . end ( ) && i < s . length ( ) - 1 && i > 0 ) { res += mp [ k ] ; } mp [ sum ] ++ ; } return res ; } int main ( ) { string str = ""01010"" ; cout << count ( str ) ; }",Count ways to split a Binary String into three substrings having equal count of zeros.,"#include <bits/stdc++.h> 
 using namespace std ; int count ( string s ) { int cnt = 0 ; for ( char c : s ) { cnt += c == '0' ? 1 : 0 ; } if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += s [ i ] == '0' ? 1 : 0 ; if ( sum == 2 * k && mp . find ( k ) != mp . end ( ) && i < s . length ( ) - 1 && i > 0 ) { res += mp [ k ] ; } mp [ sum ] ++ ; } return res ; } int main ( ) { string str = ""01010"" ; cout << count ( str ) ; }","['int count ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int count ( string s ) {
"
862,Count ways to split a Binary String into three substrings having equal count of zeros | C ++ program for above approach ; Function to calculate the number of ways to split ; Calculating the total number of zeros ; Case1 If total count of zeros is not divisible by 3 ; Case2 if total count of zeros is zero ; Number of zeros in each substring ; Initialising zero to the number of ways for first and second cut ; Initializing the count ; Traversing from the beginning ; Incrementing the count if the element is '0' ; Incrementing the ways for the 1 st cut if count is equal to zeros required in each substring ; Incrementing the ways for the 2 nd cut if count is equal to 2 * ( zeros required in each substring ) ; Total number of ways to split is multiplication of ways for the 1 st and 2 nd cut ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int splitstring ( string s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 , waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } int main ( ) { string s = ""01010"" ; cout << "" The ▁ number ▁ of ▁ ways ▁ to ▁ split ▁ is ▁ "" << splitstring ( s ) << endl ; }",Count ways to split a Binary String into three substrings having equal count of zeros.,"#include <bits/stdc++.h> 
 using namespace std ; int splitstring ( string s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 , waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } int main ( ) { string s = ""01010"" ; cout << "" The ▁ number ▁ of ▁ ways ▁ to ▁ split ▁ is ▁ "" << splitstring ( s ) << endl ; }","['int splitstring ( string s ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int splitstring ( string s ) {
"
864,Longest Substring having equal count of Vowels and Consonants | C ++ Program to implement the above approach ; Function to return the length of the longest substring having equal number of vowel and consonant ; Generate the array ; Initialize variable to store result ; Stores the sum of subarray ; Map to store indices of the sum ; Loop through the array ; If sum is 0 ; Count of vowels and consonants are equal ; Update the maximum length of substring in HashMap ; Store the index of the sum ; Return the maximum length of required substring ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxsubstringLength ( string S , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = -1 ; int maxLen = 0 ; int curr_sum = 0 ; unordered_map < int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = max ( maxLen , i + 1 ) ; if ( hash . find ( curr_sum ) != hash . end ( ) ) maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; else hash [ curr_sum ] = i ; } return maxLen ; } int main ( ) { string S = "" geeksforgeeks "" ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; cout << maxsubstringLength ( S , n ) ; return 0 ; }",Longest Substring having equal count of Vowels and Consonants.,"#include <bits/stdc++.h> 
 using namespace std ; int maxsubstringLength ( string S , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = -1 ; int maxLen = 0 ; int curr_sum = 0 ; unordered_map < int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = max ( maxLen , i + 1 ) ; if ( hash . find ( curr_sum ) != hash . end ( ) ) maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; else hash [ curr_sum ] = i ; } return maxLen ; } int main ( ) { string S = "" geeksforgeeks "" ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; cout << maxsubstringLength ( S , n ) ; return 0 ; }","['int maxsubstringLength ( string S , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int maxsubstringLength ( string S , int N ) {
"
865,"Minimum Distance from a given Cell to all other Cells of a Matrix | C ++ Program to implement the above approach ; Stores the accessible directions ; Function to find the minimum distance from a given cell to all other cells in the matrix ; Stores the accessible cells from current cell ; Insert pair ( x , y ) ; Iterate untill queue is empty ; Extract the pair ; Pop them ; Checking boundary condition ; If the cell is not visited ; Assign the minimum distance ; Insert the traversed neighbour into the queue ; Driver Code ; Print the required distances","#include <bits/stdc++.h> NEW_LINE using namespace std ; int mat [ 1001 ] [ 1001 ] ; int r , c , x , y ; int dx [ ] = { 0 , -1 , -1 , -1 , 0 , 1 , 1 , 1 } ; int dy [ ] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ; void FindMinimumDistance ( ) { queue < pair < int , int > > q ; q . push ( { x , y } ) ; mat [ x ] [ y ] = 0 ; while ( ! q . empty ( ) ) { x = q . front ( ) . first ; y = q . front ( ) . second ; q . pop ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a > = r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( { a , b } ) ; } } } } int main ( ) { r = 5 , c = 5 , x = 1 , y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { cout << mat [ i ] [ j ] << "" ▁ "" ; } cout << endl ; } }",Minimum Distance from a given Cell to all other Cells of a Matrix.,"#include <bits/stdc++.h> 
 using namespace std ; int mat [ 1001 ] [ 1001 ] ; int r , c , x , y ; int dx [ ] = { 0 , -1 , -1 , -1 , 0 , 1 , 1 , 1 } ; int dy [ ] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ; void FindMinimumDistance ( ) { queue < pair < int , int > > q ; q . push ( { x , y } ) ; mat [ x ] [ y ] = 0 ; while ( ! q . empty ( ) ) { x = q . front ( ) . first ; y = q . front ( ) . second ; q . pop ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a > = r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( { a , b } ) ; } } } } int main ( ) { r = 5 , c = 5 , x = 1 , y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { cout << mat [ i ] [ j ] << "" ▁ "" ; } cout << endl ; } }","['void FindMinimumDistance ( ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int mat [ 1001 ] [ 1001 ] ;
 int r , c , x , y ;
 int dx [ ] = {
 0 , -1 , -1 , -1 , 0 , 1 , 1 , 1 } ;
 int dy [ ] = {
 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ;
 void FindMinimumDistance ( ) {
"
866,Minimum flips required to convert given string into concatenation of equal substrings of length K | C ++ Program to implement the above approach ; Function that returns the minimum number of flips to convert the s into a concatenation of K - length sub - string ; Stores the result ; Iterate through string index ; Stores count of 0 s & 1 s ; Iterate making K jumps ; Count 0 's ; Count 1 's ; Add minimum flips for index i ; Return minimum number of flips ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . size ( ) ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += min ( zero , one ) ; } return ans ; } int main ( ) { string S = ""110100101"" ; int K = 3 ; cout << minOperations ( S , K ) ; return 0 ; }",Minimum flips required to convert given string into concatenation of equal substrings of length K.,"#include <bits/stdc++.h> 
 using namespace std ; int minOperations ( string S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . size ( ) ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += min ( zero , one ) ; } return ans ; } int main ( ) { string S = ""110100101"" ; int K = 3 ; cout << minOperations ( S , K ) ; return 0 ; }","['int minOperations ( string S , int K ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minOperations ( string S , int K ) {
"
867,Find the missing number in unordered Arithmetic Progression | C ++ program for the above approach ; Function to get the missing element ; For maximum Element in the array ; For minimum Element in the array ; For xor of all elements ; Common difference of AP series ; find maximum and minimum element ; Calculating common difference ; Calculate the XOR of all elements ; Perform XOR with actual AP series resultant x will be the ans ; Return the missing element ; Driver Code ; Given array ; Function Call ; Print the missing element,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } int main ( ) { int arr [ ] = { 12 , 3 , 6 , 15 , 18 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int element = missingElement ( arr , n ) ; cout << element ; }",Find the missing number in unordered Arithmetic Progression.,"#include <bits/stdc++.h> 
 using namespace std ; int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } int main ( ) { int arr [ ] = { 12 , 3 , 6 , 15 , 18 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int element = missingElement ( arr , n ) ; cout << element ; }","['int missingElement ( int arr [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int missingElement ( int arr [ ] , int n ) {
"
868,"Given a string and an integer k , find the kth sub | C ++ implementation of the approach ; Function to prints kth sub - string ; Total sub - strings possible ; If k is greater than total number of sub - strings ; To store number of sub - strings starting with ith character of the string ; Compute the values ; substring [ i - 1 ] is added to store the cumulative sum ; Binary search to find the starting index of the kth sub - string ; To store the ending index of the kth sub - string ; Print the sub - string ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void Printksubstring ( string str , int n , int k ) { int total = ( n * ( n + 1 ) ) / 2 ; if ( k > total ) { printf ( "" - 1 STRNEWLINE "" ) ; return ; } int substring [ n + 1 ] ; substring [ 0 ] = 0 ; int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) l = m + 1 ; else { start = m ; break ; } } int end = n - ( substring [ start ] - k ) ; for ( int i = start - 1 ; i < end ; i ++ ) cout << str [ i ] ; } int main ( ) { string str = "" abc "" ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; return 0 ; }","Given a string and an integer k , find the kth sub.","#include <bits/stdc++.h> 
 using namespace std ; void Printksubstring ( string str , int n , int k ) { int total = ( n * ( n + 1 ) ) / 2 ; if ( k > total ) { printf ( "" - 1 STRNEWLINE "" ) ; return ; } int substring [ n + 1 ] ; substring [ 0 ] = 0 ; int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) l = m + 1 ; else { start = m ; break ; } } int end = n - ( substring [ start ] - k ) ; for ( int i = start - 1 ; i < end ; i ++ ) cout << str [ i ] ; } int main ( ) { string str = "" abc "" ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; return 0 ; }","['void Printksubstring ( string str , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void Printksubstring ( string str , int n , int k ) {
"
869,Lower Insertion Point | C ++ program to find the lower insertion point of an element in a sorted array ; Function to return the lower insertion point of an element in a sorted array ; Base cases ; Final check for the remaining elements which are < X ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; cout << LowerInsertionPoint ( arr , n , X ) ; return 0 ; }",Lower Insertion Point.,"#include <iostream> 
 using namespace std ; int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; cout << LowerInsertionPoint ( arr , n , X ) ; return 0 ; }","['int LowerInsertionPoint ( int arr [ ] , int n , int X ) {', 'int main ( ) {']","#include <iostream> 
 using namespace std ;
 int LowerInsertionPoint ( int arr [ ] , int n , int X ) {
"
870,Number of positions with Same address in row major and column major order | CPP Program to count the number of positions with same address in row major and column major order ; Returns count of required positions ; horizontal 1D array ; vertical 1D array ; iterating for all possible i ; checking if j is integer ; checking if j lies b / w 1 to N ; iterating for all possible j ; checking if i is integer ; checking if i lies b / w 1 to M ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } int main ( ) { int M = 3 , N = 5 ; cout << getCount ( M , N ) << endl ; return 0 ; }",Number of positions with Same address in row major and column major order.,"#include <bits/stdc++.h> 
 using namespace std ; int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } int main ( ) { int M = 3 , N = 5 ; cout << getCount ( M , N ) << endl ; return 0 ; }","['int getCount ( int M , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getCount ( int M , int N ) {
"
872,Middle of three using minimum comparisons | CPP program to find middle of three distinct numbers ; Function to find the middle of three numbers ; Compare each three number to find middle number . Enter only if a > b ; Decided a is not greater than b . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }",Middle of three using minimum comparisons.,"#include <bits/stdc++.h> 
 using namespace std ; int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }","['int middleOfThree ( int a , int b , int c ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int middleOfThree ( int a , int b , int c ) {
"
874,Largest area possible after removal of a series of horizontal & vertical bars | C ++ program for the above approach ; Function to find the largest area when a series of horizontal & vertical bars are removed ; Stores all bars ; Insert horizontal bars ; Insert vertictal bars ; Remove horizontal separators from s1 ; Remove vertical separators from s2 ; Stores left out horizontal and vertical separators ; Sort both list in ascending order ; Find maximum difference of neighbors of list1 ; Find max difference of neighbors of list2 ; Print largest volume ; Driver code ; Given value of N & M ; Given arrays ; Function call to find the largest area when a series of horizontal & vertical bars are removed,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestArea ( int N , int M , int H [ ] , int V [ ] , int h , int v ) { set < int > s1 ; set < int > s2 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . insert ( i ) ; for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . insert ( i ) ; for ( int i = 0 ; i < h ; i ++ ) { s1 . erase ( H [ i ] ) ; } for ( int i = 0 ; i < v ; i ++ ) { s2 . erase ( V [ i ] ) ; } int list1 [ s1 . size ( ) ] ; int list2 [ s2 . size ( ) ] ; int i = 0 ; for ( auto it1 = s1 . begin ( ) ; it1 != s1 . end ( ) ; it1 ++ ) { list1 [ i ++ ] = * it1 ; } i = 0 ; for ( auto it2 = s2 . begin ( ) ; it2 != s2 . end ( ) ; it2 ++ ) { list2 [ i ++ ] = * it2 ; } sort ( list1 , list1 + s1 . size ( ) ) ; sort ( list2 , list2 + s2 . size ( ) ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( int j = 0 ; j < s1 . size ( ) ; j ++ ) { maxH = max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) { maxV = max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } cout << ( maxV * maxH ) << endl ; } int main ( ) { int N = 3 , M = 3 ; int H [ ] = { 2 } ; int V [ ] = { 2 } ; int h = sizeof ( H ) / sizeof ( H [ 0 ] ) ; int v = sizeof ( V ) / sizeof ( V [ 0 ] ) ; largestArea ( N , M , H , V , h , v ) ; return 0 ; }",Largest area possible after removal of a series of horizontal & vertical bars.,"#include <bits/stdc++.h> 
 using namespace std ; void largestArea ( int N , int M , int H [ ] , int V [ ] , int h , int v ) { set < int > s1 ; set < int > s2 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . insert ( i ) ; for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . insert ( i ) ; for ( int i = 0 ; i < h ; i ++ ) { s1 . erase ( H [ i ] ) ; } for ( int i = 0 ; i < v ; i ++ ) { s2 . erase ( V [ i ] ) ; } int list1 [ s1 . size ( ) ] ; int list2 [ s2 . size ( ) ] ; int i = 0 ; for ( auto it1 = s1 . begin ( ) ; it1 != s1 . end ( ) ; it1 ++ ) { list1 [ i ++ ] = * it1 ; } i = 0 ; for ( auto it2 = s2 . begin ( ) ; it2 != s2 . end ( ) ; it2 ++ ) { list2 [ i ++ ] = * it2 ; } sort ( list1 , list1 + s1 . size ( ) ) ; sort ( list2 , list2 + s2 . size ( ) ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( int j = 0 ; j < s1 . size ( ) ; j ++ ) { maxH = max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) { maxV = max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } cout << ( maxV * maxH ) << endl ; } int main ( ) { int N = 3 , M = 3 ; int H [ ] = { 2 } ; int V [ ] = { 2 } ; int h = sizeof ( H ) / sizeof ( H [ 0 ] ) ; int v = sizeof ( V ) / sizeof ( V [ 0 ] ) ; largestArea ( N , M , H , V , h , v ) ; return 0 ; }","['void largestArea ( int N , int M , int H [ ] , int V [ ] , int h , int v ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void largestArea ( int N , int M , int H [ ] , int V [ ] , int h , int v ) {
"
875,"Check if an array can be sorted by swapping pairs from indices consisting of unequal elements in another array | C ++ Program for above approach ; Function to check if array , A [ ] can be converted into sorted array by swapping ( A [ i ] , A [ j ] ) if B [ i ] not equal to B [ j ] ; Stores if array A [ ] is sorted in descending order or not ; Traverse the array A [ ] ; If A [ i ] is greater than A [ i + 1 ] ; Update flag ; If array is sorted in ascending order ; count = 2 : Check if 0 s and 1 s both present in the B [ ] ; Traverse the array ; If current element is 0 ; Update count ; Traverse the array B [ ] ; If current element is 1 ; If both 0 s and 1 s are present in the array ; Driver Code ; Input array A [ ] ; Input array B [ ] ; Function call ; If true , print YES ; Else print NO","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkifSorted ( int A [ ] , int B [ ] , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; bool check = checkifSorted ( A , B , N ) ; if ( check ) { cout << "" YES "" << endl ; } else { cout << "" NO "" << endl ; } return 0 ; }",Check if an array can be sorted by swapping pairs from indices consisting of unequal elements in another array.,"#include <bits/stdc++.h> 
 using namespace std ; bool checkifSorted ( int A [ ] , int B [ ] , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; bool check = checkifSorted ( A , B , N ) ; if ( check ) { cout << "" YES "" << endl ; } else { cout << "" NO "" << endl ; } return 0 ; }","['bool checkifSorted ( int A [ ] , int B [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool checkifSorted ( int A [ ] , int B [ ] , int N ) {
"
876,Minimum swaps required between two strings to make one string strictly greater than the other | C ++ program for the above approach ; Function to find the minimum number of steps to make A > B ; If all character are same and M <= N ; If there lies any character in B which is greater than B [ 0 ] ; If there lies any character in A which is smaller than A [ 0 ] ; If there lies a character which is in A and greater than A [ 0 ] ; If there lies a character which is in B and less than B [ 0 ] ; Otherwise ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( string A , string B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A . begin ( ) , A . end ( ) , A [ 0 ] ) == M && count ( B . begin ( ) , B . end ( ) , B [ 0 ] ) == N ) return -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A [ i ] , B [ 0 ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A [ 0 ] , B [ i ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } return 0 ; } int main ( ) { string A = "" adsfd "" ; string B = "" dffff "" ; int M = A . length ( ) ; int N = B . length ( ) ; cout << minSteps ( A , B , M , N ) ; return 0 ; }",Minimum swaps required between two strings to make one string strictly greater than the other.,"#include <bits/stdc++.h> 
 using namespace std ; int minSteps ( string A , string B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A . begin ( ) , A . end ( ) , A [ 0 ] ) == M && count ( B . begin ( ) , B . end ( ) , B [ 0 ] ) == N ) return -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A [ i ] , B [ 0 ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A [ 0 ] , B [ i ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } return 0 ; } int main ( ) { string A = "" adsfd "" ; string B = "" dffff "" ; int M = A . length ( ) ; int N = B . length ( ) ; cout << minSteps ( A , B , M , N ) ; return 0 ; }","['int minSteps ( string A , string B , int M , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minSteps ( string A , string B , int M , int N ) {
"
879,Largest lexicographic triplet from a given Array that forms a triangle | C ++ Program to implement the the above approach ; Function to find lexicographically largest triplet that forms a triangle in the given array ; Sort the array ; Iterate from the end of the array ; If the triplet forms a triangle ; If triplet found ; Print the triplet ; Otherwise ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplet ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag ) { cout << arr [ i - 2 ] << "" ▁ "" << arr [ i - 1 ] << "" ▁ "" << arr [ i ] << endl ; } else { cout << -1 << endl ; } } int main ( ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplet ( arr , N ) ; return 0 ; }",Largest lexicographic triplet from a given Array that forms a triangle.,"#include <bits/stdc++.h> 
 using namespace std ; void findTriplet ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag ) { cout << arr [ i - 2 ] << "" ▁ "" << arr [ i - 1 ] << "" ▁ "" << arr [ i ] << endl ; } else { cout << -1 << endl ; } } int main ( ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplet ( arr , N ) ; return 0 ; }","['void findTriplet ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findTriplet ( int arr [ ] , int N ) {
"
880,Count of all pairs in an Array with minimum absolute difference | C ++ program for the above approach ; Function to return the count of all pairs having minimal absolute difference ; Stores the count of pairs ; Sort the array ; Stores the minimum difference between adjacent pairs ; Update the minimum difference between pairs ; Increase count of pairs with difference equal to that of minimum difference ; Return the final count ; Driver Code ; Given array arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = ( sizeof arr ) / ( sizeof arr [ 0 ] ) ; cout << numberofpairs ( arr , N ) << "" STRNEWLINE "" ; return 0 ; }",Count of all pairs in an Array with minimum absolute difference.,"#include <bits/stdc++.h> 
 using namespace std ; int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = ( sizeof arr ) / ( sizeof arr [ 0 ] ) ; cout << numberofpairs ( arr , N ) << "" STRNEWLINE "" ; return 0 ; }","['int numberofpairs ( int arr [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int numberofpairs ( int arr [ ] , int N ) {
"
882,Sort decreasing permutation of N using triple swaps | C ++ implementation to sort decreasing permutation of N using triple swaps ; Function to sort Array ; The three indices that has to be chosen ; Check if possible to sort array ; Swapping to bring element at required position Bringing at least one element at correct position ; Tracing changes in Array ; Print the sorted array ; If not possible to sort ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArray ( int A [ ] , int N ) { int x , y , z ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << "" Sorted ▁ Array : ▁ "" ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << "" ▁ "" ; } else cout << "" - 1"" ; } int main ( ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; sortArray ( A , N ) ; return 0 ; }",Sort decreasing permutation of N using triple swaps.,"#include <bits/stdc++.h> 
 using namespace std ; void sortArray ( int A [ ] , int N ) { int x , y , z ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << "" Sorted ▁ Array : ▁ "" ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << "" ▁ "" ; } else cout << "" - 1"" ; } int main ( ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; sortArray ( A , N ) ; return 0 ; }","['void sortArray ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void sortArray ( int A [ ] , int N ) {
"
883,Find K such that changing all elements of the Array greater than K to K will make array sum N | C ++ implementation of the approach ; Function to return K such that changing all elements greater than K to K will make array sum N otherwise return - 1 ; Sorting the array in increasing order ; Loop through all the elements of the array ; Checking if sum of array equals N ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int arr [ ] , int size , int N ) { sort ( arr , arr + size ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return -1 ; } int main ( ) { int arr [ ] = { 3 , 1 , 10 , 4 , 8 } ; int size = sizeof ( arr ) / sizeof ( int ) ; int N = 16 ; cout << findK ( arr , size , N ) ; return 0 ; }",Find K such that changing all elements of the Array greater than K to K will make array sum N.,"#include <bits/stdc++.h> 
 using namespace std ; int findK ( int arr [ ] , int size , int N ) { sort ( arr , arr + size ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return -1 ; } int main ( ) { int arr [ ] = { 3 , 1 , 10 , 4 , 8 } ; int size = sizeof ( arr ) / sizeof ( int ) ; int N = 16 ; cout << findK ( arr , size , N ) ; return 0 ; }","['int findK ( int arr [ ] , int size , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findK ( int arr [ ] , int size , int N ) {
"
884,Find three element from given three arrays such that their sum is X | Set 2 | C ++ implementation of the approach ; Function that returns true if there exists a triplet with sum x ; Sorting arrays such that a [ ] represents smallest array ; Iterating the smallest array ; Two pointers on second and third array ; If a valid triplet is found ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 and l2 <= l3 ) swap ( l2 , l1 ) , swap ( a , b ) ; else if ( l3 <= l1 and l3 <= l2 ) swap ( l3 , l1 ) , swap ( a , c ) ; for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 and k > = 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } int main ( ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = sizeof ( a ) / sizeof ( int ) ; int l2 = sizeof ( b ) / sizeof ( int ) ; int l3 = sizeof ( c ) / sizeof ( int ) ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Find three element from given three arrays such that their sum is X.,"#include <bits/stdc++.h> 
 using namespace std ; bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 and l2 <= l3 ) swap ( l2 , l1 ) , swap ( a , b ) ; else if ( l3 <= l1 and l3 <= l2 ) swap ( l3 , l1 ) , swap ( a , c ) ; for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 and k > = 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } int main ( ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = sizeof ( a ) / sizeof ( int ) ; int l2 = sizeof ( b ) / sizeof ( int ) ; int l3 = sizeof ( c ) / sizeof ( int ) ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }","['bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) {
"
887,Permute two arrays such that sum of every pair is greater or equal to K | C ++ program to check whether permutation of two arrays satisfy the condition a [ i ] + b [ i ] >= k . ; Check whether any permutation exists which satisfy the condition . ; Sort the array a [ ] in decreasing order . ; Sort the array b [ ] in increasing order . ; Checking condition on each index . ; Driven Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } int main ( ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; isPossible ( a , b , n , k ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Permute two arrays such that sum of every pair is greater or equal to K.,"#include <bits/stdc++.h> 
 using namespace std ; bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } int main ( ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; isPossible ( a , b , n , k ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }","['bool isPossible ( int a [ ] , int b [ ] , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool isPossible ( int a [ ] , int b [ ] , int n , int k ) {
"
889,"Check if end of given Binary string can be reached by choosing jump value in between given range | C ++ program for the above approach ; Function to check if it is possible to reach the end of the binary string using the given jumps ; Stores the DP states ; Initial state ; Stores count of indices from which it is possible to reach index i ; Traverse the given string ; Update the values of pre accordingly ; If the jump size is out of the range [ L , R ] ; Return answer ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canReach ( string s , int L , int R ) { vector < int > dp ( s . length ( ) ) ; dp [ 0 ] = 1 ; int pre = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) ; } return dp [ s . length ( ) - 1 ] ; } int main ( ) { string S = ""01101110"" ; int L = 2 , R = 3 ; cout << ( canReach ( S , L , R ) ? "" Yes "" : "" No "" ) ; return 0 ; }",Check if end of given Binary string can be reached by choosing jump value in between given range.,"#include <bits/stdc++.h> 
 using namespace std ; bool canReach ( string s , int L , int R ) { vector < int > dp ( s . length ( ) ) ; dp [ 0 ] = 1 ; int pre = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) ; } return dp [ s . length ( ) - 1 ] ; } int main ( ) { string S = ""01101110"" ; int L = 2 , R = 3 ; cout << ( canReach ( S , L , R ) ? "" Yes "" : "" No "" ) ; return 0 ; }","['bool canReach ( string s , int L , int R ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 bool canReach ( string s , int L , int R ) {
"
891,"Construct an N | C ++ program to implement the above approach ; Keep track of visited nodes ; Function to construct a tree such that there are no two adjacent nodes with the same weight ; If minimum and maximum elements are equal , i . e . array contains one distinct element ; Tree cannot be constructed ; Otherwise ; Tree can be constructed ; Choose weights [ 0 ] as root ; First Node is visited ; Traverse the array ; Otherwise , make an edge ; Mark this node as visited ; Find a weight not same as the root & make edges with that node ; Join non - roots with remaining nodes ; Check if current node ' s ▁ weight ▁ ▁ is ▁ same ▁ as ▁ root ▁ node ' s weight and if it is not visited or not ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e5 + 5 ; int visited [ N ] ; void construct_tree ( int weights [ ] , int n ) { int minimum = * min_element ( weights , weights + n ) ; int maximum = * max_element ( weights , weights + n ) ; if ( minimum == maximum ) { cout << "" No "" ; return ; } else { cout << "" Yes "" << endl ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { cout << 1 << "" ▁ "" << i + 1 << "" ▁ "" << endl ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { cout << notroot << "" ▁ "" << i + 1 << endl ; visited [ i + 1 ] = 1 ; } } } int main ( ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = sizeof ( weights ) / sizeof ( weights [ 0 ] ) ; construct_tree ( weights , N ) ; }",Construct an N.,"#include <bits/stdc++.h> 
 using namespace std ; const int N = 1e5 + 5 ; int visited [ N ] ; void construct_tree ( int weights [ ] , int n ) { int minimum = * min_element ( weights , weights + n ) ; int maximum = * max_element ( weights , weights + n ) ; if ( minimum == maximum ) { cout << "" No "" ; return ; } else { cout << "" Yes "" << endl ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { cout << 1 << "" ▁ "" << i + 1 << "" ▁ "" << endl ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { cout << notroot << "" ▁ "" << i + 1 << endl ; visited [ i + 1 ] = 1 ; } } } int main ( ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = sizeof ( weights ) / sizeof ( weights [ 0 ] ) ; construct_tree ( weights , N ) ; }","['void construct_tree ( int weights [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int N = 1e5 + 5 ;
 int visited [ N ] ;
 void construct_tree ( int weights [ ] , int n ) {
"
892,Minimize cost to convert given string into concatenation of equal substrings of length K | C ++ program for the above approach ; Function to find minimum cost to convert given String into String of K length same subString ; Stores length of String ; Stores the minimum cost ; Traverse left subString of k length ; Stores the frequency ; Stores minimum cost for sequence of S [ i ] % k indices ; Check for optimal character ; Find sum of distance ' a ' + ch from character S [ i ] % k indices ; Choose minimum cost for each index i ; Increment ans ; Print minimum cost to convert String ; Driver Code ; Given String S ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string s , int k ) { int n = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int a [ 26 ] ; for ( int p = 0 ; p < 26 ; p ++ ) { a [ p ] = 0 ; } for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - ' a ' ] ++ ; } int min_cost = INT_MAX ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += abs ( ch - tr ) * a [ tr ] ; min_cost = min ( min_cost , cost ) ; } ans += min_cost ; } cout << ( ans ) ; } int main ( ) { string S = "" abcdefabc "" ; int K = 3 ; minCost ( S , K ) ; }",Minimize cost to convert given string into concatenation of equal substrings of length K.,"#include <bits/stdc++.h> 
 using namespace std ; void minCost ( string s , int k ) { int n = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int a [ 26 ] ; for ( int p = 0 ; p < 26 ; p ++ ) { a [ p ] = 0 ; } for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - ' a ' ] ++ ; } int min_cost = INT_MAX ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += abs ( ch - tr ) * a [ tr ] ; min_cost = min ( min_cost , cost ) ; } ans += min_cost ; } cout << ( ans ) ; } int main ( ) { string S = "" abcdefabc "" ; int K = 3 ; minCost ( S , K ) ; }","['void minCost ( string s , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void minCost ( string s , int k ) {
"
893,Split first N natural numbers into two sets with minimum absolute difference of their sums | C ++ program to implement the above approach ; Function to split the first N natural numbers into two sets having minimum absolute difference of their sums ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; },Split first N natural numbers into two sets with minimum absolute difference of their sums.,"#include <bits/stdc++.h> 
 using namespace std ; int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }","['int minAbsDiff ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minAbsDiff ( int N ) {
"
895,Minimize cost to Swap two given Arrays | C ++ program to implement the above approach ; Function to calculate and return the minimum cost required to swap two arrays ; Return the total minimum cost ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinCost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; vector < int > A = { 1 , 4 , 2 } ; vector < int > B = { 10 , 6 , 12 } ; cout << getMinCost ( A , B , N ) ; return 0 ; }",Minimize cost to Swap two given Arrays.,"#include <bits/stdc++.h> 
 using namespace std ; int getMinCost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; vector < int > A = { 1 , 4 , 2 } ; vector < int > B = { 10 , 6 , 12 } ; cout << getMinCost ( A , B , N ) ; return 0 ; }","['int getMinCost ( vector < int > A , vector < int > B , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getMinCost ( vector < int > A , vector < int > B , int N ) {
"
897,Maximize count of Decreasing Subsequences from the given Array | C ++ Program to implement the above approach ; Function to count maximum subsequence ; Stores the frequency of array elements ; Stores max frequency ; Update frequency of A [ i ] ; Update max subsequence ; Print the count ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maximum_subsequence ( int A [ ] , int N ) { unordered_map < int , int > frequency ; int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( auto it : frequency ) { if ( it . second > max_freq ) { max_freq = it . second ; } } cout << max_freq << endl ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Maximum_subsequence ( arr , N ) ; return 0 ; }",Maximize count of Decreasing Subsequences from the given Array.,"#include <bits/stdc++.h> 
 using namespace std ; void Maximum_subsequence ( int A [ ] , int N ) { unordered_map < int , int > frequency ; int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( auto it : frequency ) { if ( it . second > max_freq ) { max_freq = it . second ; } } cout << max_freq << endl ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Maximum_subsequence ( arr , N ) ; return 0 ; }","['void Maximum_subsequence ( int A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void Maximum_subsequence ( int A [ ] , int N ) {
"
898,Check if a string can be split into two strings with same number of K | C ++ implementation of the above approach ; Function to print the arrangement of characters ; Stores frequency of characters ; Count the character having frequency K ; Count the character having frequency greater than K and not equal to 2 K ; Case 1 ; Case 2 ; Case 3 ; If all cases fail ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void DivideString ( string s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ; int fr [ 26 ] = { 0 } ; string ans = "" "" ; for ( i = 0 ; i < n ; i ++ ) { fr [ s [ i ] - ' a ' ] ++ ; } char ch , ch1 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] == k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = i + ' a ' ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = i + ' a ' ; } } for ( i = 0 ; i < n ; i ++ ) ans = ans + ""1"" ; map < char , int > mp ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s [ i ] - ' a ' ] == k ) { if ( mp . find ( s [ i ] ) != mp . end ( ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp [ s [ i ] ] = 1 ; } } } } if ( c % 2 == 1 && c1 > 0 ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } } if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s [ i ] - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } cout << ans << endl ; } else { cout << "" NO "" << endl ; } } int main ( ) { string S = "" abbbccc "" ; int N = S . size ( ) ; int K = 1 ; DivideString ( S , N , K ) ; return 0 ; }",Check if a string can be split into two strings with same number of K.,"#include <bits/stdc++.h> 
 using namespace std ; void DivideString ( string s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ; int fr [ 26 ] = { 0 } ; string ans = "" "" ; for ( i = 0 ; i < n ; i ++ ) { fr [ s [ i ] - ' a ' ] ++ ; } char ch , ch1 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] == k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = i + ' a ' ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = i + ' a ' ; } } for ( i = 0 ; i < n ; i ++ ) ans = ans + ""1"" ; map < char , int > mp ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s [ i ] - ' a ' ] == k ) { if ( mp . find ( s [ i ] ) != mp . end ( ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp [ s [ i ] ] = 1 ; } } } } if ( c % 2 == 1 && c1 > 0 ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } } if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s [ i ] - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } cout << ans << endl ; } else { cout << "" NO "" << endl ; } } int main ( ) { string S = "" abbbccc "" ; int N = S . size ( ) ; int K = 1 ; DivideString ( S , N , K ) ; return 0 ; }","['void DivideString ( string s , int n , int k ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void DivideString ( string s , int n , int k ) {
"
899,Check if two items can be selected from two different categories without exceeding price | C ++ implementation to check if two items can be selected from two different categories without exceeding the total price ; Function to check if two items can be selected from two different categories without exceeding the total price ; Loop to choose two different pairs using two nested loops ; Condition to check if the price of these two elements is less than S ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return "" Yes "" ; } } } } return "" No "" ; } int main ( ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ; cout << check ( S , prices , type , n ) ; return 0 ; }",Check if two items can be selected from two different categories without exceeding price.,"#include <bits/stdc++.h> 
 using namespace std ; string check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return "" Yes "" ; } } } } return "" No "" ; } int main ( ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ; cout << check ( S , prices , type , n ) ; return 0 ; }","['string check ( int S , int prices [ ] , int type [ ] , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string check ( int S , int prices [ ] , int type [ ] , int n ) {
"
900,Find the maximum sum ( a + b ) for a given input integer N satisfying the given condition | C ++ implementation to find the largest value of a + b satisfying the given condition ; Function to return the maximum sum of a + b satisfying the given condition ; Consider all possible pairs and check the sum divides product property ; To find the largest factor k ; Check if the product is divisible by the sum ; Storing the maximum sum in the max_sum variable ; Return the max_sum value ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = max ( max_sum , a + b ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }",Find the maximum sum ( a + b ) for a given input integer N satisfying the given condition.,"#include <bits/stdc++.h> 
 using namespace std ; int getLargestSum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = max ( max_sum , a + b ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }","['int getLargestSum ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int getLargestSum ( int N ) {
"
901,Encrypt a string by repeating i | C ++ implementation of the approach ; Function to return the encrypted string ; Number of times the current character will be repeated ; Repeat the current character in the encrypted string ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = "" "" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; } int main ( ) { string str = "" geeks "" ; int n = str . length ( ) ; cout << encryptString ( str , n ) ; return 0 ; }",Encrypt a string by repeating i.,"#include <bits/stdc++.h> 
 using namespace std ; string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = "" "" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; } int main ( ) { string str = "" geeks "" ; int n = str . length ( ) ; cout << encryptString ( str , n ) ; return 0 ; }","['string encryptString ( string str , int n ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 string encryptString ( string str , int n ) {
"
902,Minimize the difference between the maximum and minimum values of the modified array | C ++ program to find the minimum difference . ; Function to return required minimum difference ; finding minimum and maximum values ; returning minimum possible difference ; Driver program ; function to return the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; } int main ( ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ; cout << minDiff ( n , x , A ) ; return 0 ; }",Minimize the difference between the maximum and minimum values of the modified array.,"#include <bits/stdc++.h> 
 using namespace std ; int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; } int main ( ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ; cout << minDiff ( n , x , A ) ; return 0 ; }","['int minDiff ( int n , int x , int A [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int minDiff ( int n , int x , int A [ ] ) {
"
904,"Longest subsequence from an array of pairs having first element increasing and second element decreasing . | C ++ program for the above approach ; Function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing ; dp [ i ] : Stores the longest subsequence upto i ; Base case ; When the conditions hold ; Finally , print the required answer ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubSequence ( pair < int , int > A [ ] , int N ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] . first < A [ i ] . first && A [ j ] . second > A [ i ] . second ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } cout << dp [ N - 1 ] << endl ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; longestSubSequence ( A , N ) ; return 0 ; }",Longest subsequence from an array of pairs having first element increasing and second element decreasing ..,"#include <bits/stdc++.h> 
 using namespace std ; void longestSubSequence ( pair < int , int > A [ ] , int N ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] . first < A [ i ] . first && A [ j ] . second > A [ i ] . second ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } cout << dp [ N - 1 ] << endl ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; longestSubSequence ( A , N ) ; return 0 ; }","['void longestSubSequence ( pair < int , int > A [ ] , int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void longestSubSequence ( pair < int , int > A [ ] , int N ) {
"
905,Count ways to obtain given sum by repeated throws of a dice | C ++ Program for the above approach ; Function to calculate the total number of ways to have sum N ; Base Case ; Return already stored result ; Recur for all 6 states ; Return the result ; Driver Code ; Given sum N ; Initialize the dp array ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != -1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } int main ( ) { int N = 4 ; int dp [ N + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << findWays ( N , dp ) ; return 0 ; }",Count ways to obtain given sum by repeated throws of a dice.,"#include <bits/stdc++.h> 
 using namespace std ; int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != -1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } int main ( ) { int N = 4 ; int dp [ N + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << findWays ( N , dp ) ; return 0 ; }","['int findWays ( int N , int dp [ ] ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 int findWays ( int N , int dp [ ] ) {
"
906,Count ways to obtain given sum by repeated throws of a dice | C ++ Program for the above approach ; Function to calculate the total number of ways to have sum N ; Initialize dp array ; Iterate over all the possible intermediate values to reach N ; Calculate the sum for all 6 faces ; Print the total number of ways ; Driver Code ; Given sum N ; Function call,#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; } int main ( ) { int N = 4 ; findWays ( N ) ; return 0 ; },Count ways to obtain given sum by repeated throws of a dice.,"#include <bits/stdc++.h> 
 using namespace std ; void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; } int main ( ) { int N = 4 ; findWays ( N ) ; return 0 ; }","['void findWays ( int N ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 void findWays ( int N ) {
"
908,Largest Square in a Binary Matrix with at most K 1 s for multiple Queries | C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to find the largest square in the matrix such that it contains atmost K 1 's ; Precomputation of the countDP prefix sum of the matrix ; Loop to solve each query ; Binary Search to the side which have atmost in K 1 's in square ; Count total number of 1 s in the sub square considered ; If the count is less than or equals to the maximum move to right half ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } cout << ans << "" STRNEWLINE "" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }",Largest Square in a Binary Matrix with at most K 1 s for multiple Queries.,"#include <bits/stdc++.h> 
 using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } cout << ans << "" STRNEWLINE "" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }","['void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {', 'int main ( ) {']","#include <bits/stdc++.h> 
 using namespace std ;
 const int MAX = 100 ;
 void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {
"
