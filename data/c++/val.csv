id,text,code,question
0,Program to convert Centimeters to Pixels | C ++ program to convert centimeter to pixels ; Function to convert centimeters to pixels ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; void Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; cout << fixed << setprecision ( 2 ) << pixels ; } int main ( ) { double centi = 15 ; Conversion ( centi ) ; return 0 ; },Program to convert Centimeters to Pixels.
1,"Kth array element after M replacements of array elements by XOR of adjacent pairs | C ++ program for the above approach ; Method that returns the corresponding output by taking the given inputs . ; If this condition is satisfied , value of M is invalid ; Check if index K is valid ; Loop to perform M operations ; Creating a temporary list ; Traversing the array ; Calculate XOR values of adjacent elements ; Adding this value to the temporary list ; Update the original array ; Getting value at index K ; Driver Code ; Number of elements ; Given array arr [ ] ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 or M > = N ) return -1 ; if ( K < 0 or K > = N - M ) return -1 ; for ( int p = 0 ; p < M ; p ++ ) { vector < int > temp ; for ( int i = 0 ; i < N ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . push_back ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 4 , 5 , 6 , 7 } ; int M = 1 , K = 2 ; cout << xor_operations ( N , arr , M , K ) ; return 0 ; }",Kth array element after M replacements of array elements by XOR of adjacent pairs.
2,"Check if N can be divided into K consecutive elements with a sum equal to N | C ++ program for the above approach ; Function to find the K consecutive elements with a sum equal to N ; Iterate over [ 2 , INF ] ; Store the sum ; If the sum exceeds N then break the loop ; Common difference should be divisible by number of terms ; Print value of i & return ; Print "" - 1"" if not possible to break N ; Driver Code ; Given N ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBreakN ( long long n ) { for ( long long i = 2 ; ; i ++ ) { long long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long long k = n - m ; if ( k % i ) continue ; cout << i << endl ; return ; } cout << "" - 1"" ; } int main ( ) { long long N = 12 ; canBreakN ( N ) ; return 0 ; }",Check if N can be divided into K consecutive elements with a sum equal to N.
3,"Coprime divisors of a number | C ++ program to find two coprime divisors of a given number such that both are greater than 1 ; Function which finds the required pair of divisors of N ; We iterate upto sqrt ( N ) as we can find all the divisors of N in this time ; If x is a divisor of N keep dividing as long as possible ; We have found a required pair ; No such pair of divisors of N was found , hence print - 1 ; Driver Code ; Sample example 1 ; Sample example 2","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCoprimePair ( int N ) { for ( int x = 2 ; x <= sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) { while ( N % x == 0 ) { N /= x ; } if ( N > 1 ) { cout << x << "" ▁ "" << N << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 45 ; findCoprimePair ( N ) ; N = 25 ; findCoprimePair ( N ) ; return 0 ; }",Coprime divisors of a number.
4,"Wasteful Numbers | C ++ program for the above approach ; Array to store all prime less than and equal to MAX . ; Function for Sieve of Sundaram ; Boolean Array ; Mark all numbers which do not generate prime number by 2 * i + 1 ; Since 2 is a prime number ; Print remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; Function that returns true if n is a Wasteful number ; Count digits in original number ; Count all digits in prime factors of N pDigit is going to hold this value . ; Count powers of p in n ; If primes [ i ] is a prime factor , ; Count the power of prime factors ; Add its digits to pDigit ; Add digits of power of prime factors to pDigit . ; If n != 1 then one prime factor still to be summed up ; If digits in prime factors is more than digits in original number then return true . Else return false . ; Function to print Wasteful Number before N ; Iterate till N and check if i is wastefull or not ; Driver code ; Precompute prime numbers upto 10 ^ 6 ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 1 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } bool isWasteful ( int n ) { if ( n == 1 ) return false ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit > sumDigits ) ; } void Solve ( int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { cout << i << "" ▁ "" ; } } } int main ( ) { sieveSundaram ( ) ; int N = 10 ; Solve ( N ) ; return 0 ; }",Wasteful Numbers.
5,Hexanacci Numbers | C ++ simple recursive program to print Nth Hexanacci numbers . ; Function to print the Nth Hexanacci number ; Driver code,#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; } int printhexa ( int n ) { cout << printhexaRec ( n ) << endl ; } int main ( ) { privatenthexa ( n ) ; },Hexanacci Numbers.
6,"Hexanacci Numbers | C ++ implementation to print Nth term of hexanacci numbers . ; Function to print the Nth term of the Hexanacci number ; Initialize first five numbers to base cases ; Declare a current variable ; Loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth fifth to second , third , fourth , fifth and curr to sixth respectively ; Driver Code",#include <bits/stdc++.h> NEW_LINE using namespace std ; void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) cout << first << endl ; else if ( n == 6 ) cout << sixth << endl ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } cout << curr << endl ; } int main ( ) { int n = 11 ; printhexa ( n ) ; return 0 ; },Hexanacci Numbers.
7,Find the smallest number whose sum of digits is N | C ++ program to find the smallest number whose sum of digits is also N ; Function to find the smallest number whose sum of digits is also N ; Driver code,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void smallestNumber ( int N ) { cout << ( N % 9 + 1 ) * pow ( 10 , ( N / 9 ) ) - 1 ; } int main ( ) { int N = 10 ; smallestNumber ( N ) ; return 0 ; }",Find the smallest number whose sum of digits is N.
8,Compositorial of a number | C ++ program to find compositorial of composite numbers ; Function to check if a number is composite . ; Corner cases ; This is checked so that we can skip the middle five numbers in the below loop ; This function stores all composite numbers less than N ; Function to calculate the compositorial of n ; Multiply first n composite number ; Driver code ; Vector to store all the composite less than N,#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > compo ; bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 or n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 or n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; } void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . push_back ( i ) ; l += 1 ; } } } } int calculateCompositorial ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; } int main ( ) { int n = 5 ; Compositorial_list ( n ) ; cout << ( calculateCompositorial ( n ) ) ; return 0 ; },Compositorial of a number.
9,"Distinct powers of a number N such that the sum is equal to K | C ++ implementation to find out the powers of N that add upto K ; Initializing the PowerArray with all 0 's ; Function to find the powers of N that add up to K ; Initializing the counter ; Executing the while loop until K is greater than 0 ; If K % N == 1 , then the power array is incremented by 1 ; Checking if any power is occurred more than once ; For any other value , the sum of powers cannot be added up to K ; Printing the powers of N that sum up to K ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int b [ 50 ] = { 0 } ; int PowerArray ( int n , int k ) { int count = 0 ; while ( k ) { if ( k % n == 0 ) { k /= n ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { cout << -1 ; return 0 ; } } else { cout << -1 ; return 0 ; } } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] ) { cout << i << "" , ▁ "" ; } } } int main ( ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; return 0 ; }",Distinct powers of a number N such that the sum is equal to K.
10,"Program to find value of 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k | C ++ Program to find the value 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K ; Function to find value of 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K ; Initialise sum to 0 ; Find the value of pow ( i , 4 ) and then add it to the sum ; Return the sum ; Drivers Code ; Function call to find the sum","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , k ) ; } return sum ; } int main ( ) { int N = 8 , k = 4 ; cout << findSum ( N , k ) << endl ; return 0 ; }",Program to find value of 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k.
11,Count of indices in an array that satisfy the given condition | C ++ implementation of the approach ; Function to return the count of indices that satisfy the given condition ; To store the result ; To store the current maximum Initialized to 0 since there are only positive elements in the array ; i is a valid index ; Update the maximum so far ; Increment the counter ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << countIndices ( arr , n ) ; return 0 ; }",Count of indices in an array that satisfy the given condition.
12,Maximum frequency of a remainder modulo 2 i | C ++ implementation of the approach ; Binary representation of the digits ; Function to return the maximum frequency of s modulo with a power of 2 ; Store the binary representation ; Convert the octal to binary ; Remove the LSB ; If there is 1 in the binary representation ; Find the number of zeroes in between two 1 's in the binary representation ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const string bin [ ] = { ""000"" , ""001"" , ""010"" , ""011"" , ""100"" , ""101"" , ""110"" , ""111"" } ; int maxFreq ( string s ) { string binary = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s [ i ] - '0' ] ; } binary = binary . substr ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = -1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary [ i ] == '1' ) { count = max ( count , j - prev ) ; prev = j ; } return count ; } int main ( ) { string octal = ""13"" ; cout << maxFreq ( octal ) ; return 0 ; }",Maximum frequency of a remainder modulo 2 i.
13,Find all the prime numbers of given number of digits | C ++ implementation of the approach ; Function for Sieve of Eratosthenes ; Function to print all the prime numbers with d digits ; Range to check integers ; For every integer in the range ; If the current integer is prime ; Driver code ; Generate primes,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; bool isPrime [ sz + 1 ] ; void sieve ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } void findPrimesD ( int d ) { int left = pow ( 10 , d - 1 ) ; int right = pow ( 10 , d ) - 1 ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { cout << i << "" ▁ "" ; } } } int main ( ) { sieve ( ) ; int d = 1 ; findPrimesD ( d ) ; return 0 ; }",Find all the prime numbers of given number of digits.
14,Find the number of cells in the table contains X | C ++ program to find number of cells in the table contains X ; Function to find number of cells in the table contains X ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; } int main ( ) { int n = 6 , x = 12 ; cout << ( Cells ( n , x ) ) ; return 0 ; }",Find the number of cells in the table contains X.
15,Find the maximum possible value of the minimum value of modified array | CPP program to find the maximum possible value of the minimum value of modified array ; Function to find the maximum possible value of the minimum value of the modified array ; To store minimum value of array ; To store sum of elements of array ; Solution is not possible ; zero is the possible value ; minimum possible value ; maximum possible value ; to store a required answer ; Binary Search ; If mid is possible then try to increase required answer ; If mid is not possible then decrease required answer ; Return required answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOfMin ( int a [ ] , int n , int S ) { int mi = INT_MAX ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = min ( a [ i ] , mi ) ; } if ( s1 < S ) return -1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } int main ( ) { int a [ ] = { 10 , 10 , 10 , 10 , 10 } ; int S = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxOfMin ( a , n , S ) ; return 0 ; }",Find the maximum possible value of the minimum value of modified array.
16,"Program to print ' N ' alphabet using the number pattern from 1 to n | C ++ implementation of the approach ; Function to print the desired Alphabet N Pattern ; Declaring the values of Right , Left and Diagonal values ; Main Loop for the rows ; For the left Values ; Spaces for the diagonals ; Condition for the diagonals ; Spaces for the Right Values ; For the right values ; Driver Code ; Size of the Pattern ; Calling the function to print the desired Pattern","#include <iostream> NEW_LINE using namespace std ; void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { cout << Left ++ ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) cout << "" ▁ "" ; if ( index != 0 && index != N - 1 ) cout << Diagonal ++ ; else cout << "" ▁ "" ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) cout << "" ▁ "" ; cout << Right ++ ; cout << endl ; } } int main ( int argc , char * * argv ) { int Size = 6 ; Alphabet_N_Pattern ( Size ) ; }",Program to print ' N ' alphabet using the number pattern from 1 to n.
17,Check if the sum of digits of a number N divides it | C ++ program to check if sum of digits of a number divides it ; Function to check if sum of digits of a number divides it ; Calculate sum of all of digits of N ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; } int main ( ) { int N = 12 ; if ( isSumDivides ( N ) ) cout << "" YES "" ; else cout << "" NO "" ; return 0 ; }",Check if the sum of digits of a number N divides it.
18,Sum of numbers from 1 to N which are divisible by 3 or 4 | C ++ program to find sum of numbers from 1 to N which are divisible by 3 or 4 ; Function to calculate the sum of numbers divisible by 3 or 4 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; } int main ( ) { int N = 20 ; cout << sum ( 12 ) ; return 0 ; }",Sum of numbers from 1 to N which are divisible by 3 or 4.
19,Next greater number than N with exactly one bit different in binary representation of N | CPP program to find next greater number than N with exactly one bit different in binary representation of N ; Function to find next greater number than N with exactly one bit different in binary representation of N ; It is guaranteed that there is a bit zero in the number ; If the shifted bit is zero then break ; increase the bit shift ; increase the power of 2 ; set the lowest bit of the number ; Driver code ; display the next number,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long long nextGreater ( long long N ) { long long power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; } int main ( ) { long long N = 11 ; cout << "" The ▁ next ▁ number ▁ is ▁ = ▁ "" << nextGreater ( N ) ; return 0 ; }",Next greater number than N with exactly one bit different in binary representation of N.
20,"Count number of ways to cover a distance | Set 2 | C ++ implementation of the approach ; Function to return the count of the total number of ways to cover the distance with 1 , 2 and 3 steps ; Base conditions ; To store the last three stages ; Find the numbers of steps required to reach the distance i ; Return the required answer ; Driver code","#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 , ans ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }",Count number of ways to cover a distance.
21,"Maximize sum by choosing elements from different section of a matrix | C ++ program for the above approach ; Function to find the maximum value ; Dp table ; Fill the dp in bottom up manner ; Maximum of the three sections ; Maximum of the first section ; Maximum of the second section ; Maximum of the third section ; If we choose element from section 1 , we cannot have selection from same section in adjacent rows ; Print the maximum sum ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 6 , m = 6 ; void maxSum ( long arr [ n ] [ m ] ) { long dp [ n + 1 ] [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( j / ( m / 3 ) ) == 0 ) { m1 = max ( m1 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 1 ) { m2 = max ( m2 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 2 ) { m3 = max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } cout << max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) << ' ' ; } int main ( ) { long arr [ n ] [ m ] = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; return 0 ; }",Maximize sum by choosing elements from different section of a matrix.
22,"Total number of odd length palindrome sub | C ++ implementation of the approach ; Function to find the total palindromic odd length sub - sequences ; dp array to store the number of palindromic subsequences for 0 to i - 1 and j + 1 to n - 1 ; We will start with the largest distance between i and j ; For each len , we fix our i ; For this i we will find our j ; Base cases ; If the characters are equal then look for out of bound index ; We have only 1 way that is to just pick these characters ; If the characters are not equal ; Subtract it as we have counted it twice ; We have just 1 palindrome sequence of length 1 ; Else total ways would be sum of dp [ i - 1 ] [ i + 1 ] , that is number of palindrome sub - sequences from 1 to i - 1 + number of palindrome sub - sequences from i + 1 to n - 1 ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string & s ) { int n = s . length ( ) ; int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int len = n - 1 ; len >= 0 ; -- len ) { for ( int i = 0 ; i + len < n ; ++ i ) { int j = i + len ; if ( i == 0 and j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 or j + 1 >= n ) { dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 and j + 1 <= n - 1 ) { dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } vector < int > ways ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 or i == n - 1 ) { ways . push_back ( 1 ) ; } else { int total = dp [ i - 1 ] [ i + 1 ] ; ways . push_back ( total ) ; } } for ( int i = 0 ; i < ways . size ( ) ; ++ i ) { cout << ways [ i ] << "" ▁ "" ; } } int main ( ) { string s = "" xyxyx "" ; solve ( s ) ; return 0 ; }",Total number of odd length palindrome sub.
23,Find the number of Chicks in a Zoo at Nth day | C ++ implementation of the approach ; Function to return the number of chicks on the nth day ; Size of dp [ ] has to be at least 6 ( 1 - based indexing ) ; Every day current population will be three times of the previous day ; Manually calculated value ; From 8 th day onwards ; Chick population decreases by 2 / 3 everyday . For 8 th day on [ i - 6 ] i . e 2 nd day population was 3 and so 2 new born die on the 6 th day and so on for the upcoming days ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getChicks ( int n ) { int size = max ( n , 7 ) ; ll dp [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 7 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }",Find the number of Chicks in a Zoo at Nth day.
24,Find the number of Chicks in a Zoo at Nth day | C ++ implementation of the approach ; Function to return the number of chicks on the nth day ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getChicks ( int n ) { ll chicks = ( ll ) pow ( 3 , n - 1 ) ; return chicks ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }",Find the number of Chicks in a Zoo at Nth day.
25,Find minimum steps required to reach the end of a matrix | Set 2 | C ++ implementation of the approach ; 2d array to store states of dp ; Array to determine whether a state has been solved before ; Function to return the minimum steps required ; Base cases ; If a state has been solved before it won 't be evaluated again ; Recurrence relation ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( int k = max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 4 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }",Find minimum steps required to reach the end of a matrix.
26,Find minimum steps required to reach the end of a matrix | Set | C ++ program to implement above approach ; 2d array to store states of dp ; array to determine whether a state has been solved before ; Function to find the minimum number of steps to reach the end of matrix ; base cases ; if a state has been solved before it won 't be evaluated again. ; recurrence relation ; Driver Code,"#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }",Find minimum steps required to reach the end of a matrix.
27,Treasure and Cities | A memoization based program to find maximum treasure that can be collected . ; k is current index and col is previous color . ; if ( k == n ) base case ; if ( col == color [ k ] ) check if color of this city is equal to prev visited city ; return max of both options ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1001 ; int dp [ MAX ] [ MAX ] ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != -1 ) return dp [ k ] [ col ] ; int sum = 0 ; sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }",Treasure and Cities.
28,Tetranacci Numbers | A DP based CPP program to print the nth tetranacci number ; Function to print the N - th tetranacci number ; base cases ; Driver code,#include <iostream> NEW_LINE using namespace std ; int printTetra ( int n ) { int dp [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; cout << dp [ n ] ; } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; },Tetranacci Numbers.
29,Maximum sum in circular array such that no two elements are adjacent | CPP program to find maximum sum in a circular array such that no elements are adjacent in the sum . ; Function to calculate the sum from 0 th position to ( n - 2 ) th position ; copy the element of original array to dp [ ] ; find the maximum element in the array ; start from 2 nd to n - 1 th pos ; traverse for all pairs bottom - up approach ; dp - condition ; find maximum sum ; return the maximum ; Function to find the maximum sum from 1 st position to n - 1 - th position ; Traverse from third to n - th pos ; bootom - up approach ; dp condition ; find max sum ; return max ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum1 ( int arr [ ] , int n ) { int dp [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 2 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } int maxSum2 ( int arr [ ] , int n ) { int dp [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 3 ; i < n ; i ++ ) { for ( int j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } int findMaxSum ( int arr [ ] , int n ) { return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }",Maximum sum in circular array such that no two elements are adjacent.
30,"Permutation Coefficient | A O ( n ) solution that uses table fact [ ] to calculate the Permutation Coefficient ; Returns value of Permutation Coefficient P ( n , k ) ; Base case ; Calculate value factorials up to n ; P ( n , k ) = n ! / ( n - k ) ! ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; } int main ( ) { int n = 10 , k = 2 ; cout << "" Value ▁ of ▁ P ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << permutationCoeff ( n , k ) ; return 0 ; }",Permutation Coefficient.
31,"Dynamic Programming | A recursive solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following : ( a ) including the last element ( b ) excluding the last element ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ with ▁ given ▁ sum "" ; return 0 ; }",Dynamic Programming.
32,Count of cyclic permutations having XOR with other binary string as 0 | C ++ program to find bitwise XOR between binary string A and all the cyclic permutations of binary string B ; Implementation of Z - algorithm for linear time pattern searching ; Function to get the count of the cyclic permutations of b that given 0 when XORed with a ; concatenate b with b ; new b now contains all the cyclic permutations of old b as it 's sub-strings ; concatenate pattern with text ; Fill z array used in Z algorithm ; pattern occurs at index i since z value of i equals pattern length ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void compute_z ( string s , int z [ ] ) { int l = 0 , r = 0 ; int n = s . length ( ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i , r = i ; while ( r < n && s [ r - l ] == s [ r ] ) r ++ ; z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] == s [ r ] ) r ++ ; z [ i ] = r - l ; r -- ; } } } } int countPermutation ( string a , string b ) { b = b + b ; b = b . substr ( 0 , b . size ( ) - 1 ) ; int ans = 0 ; string s = a + "" $ "" + b ; int n = s . length ( ) ; int z [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] == a . length ( ) ) ans ++ ; } return ans ; } int main ( ) { string a = ""101"" ; string b = ""101"" ; cout << countPermutation ( a , b ) << endl ; return 0 ; }",Count of cyclic permutations having XOR with other binary string as 0.
33,Lexicographically smallest K | C ++ program for the above approach ; Function to find lexicographically smallest subsequence of size K ; Length of string ; Stores the minimum subsequence ; Traverse the string S ; If the stack is empty ; Iterate till the current character is less than the the character at the top of stack ; Check if there are enough characters remaining to obtain length K ; If stack size is < K ; Push the current character into it ; Stores the resultant string ; Iterate until stack is empty ; Reverse the string ; Print the string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestSubsequence ( string & S , int K ) { int N = S . size ( ) ; stack < char > answer ; for ( int i = 0 ; i < N ; ++ i ) { if ( answer . empty ( ) ) { answer . push ( S [ i ] ) ; } else { while ( ( ! answer . empty ( ) ) && ( S [ i ] < answer . top ( ) ) && ( answer . size ( ) - 1 + N - i >= K ) ) { answer . pop ( ) ; } if ( answer . empty ( ) || answer . size ( ) < K ) { answer . push ( S [ i ] ) ; } } } string ret ; while ( ! answer . empty ( ) ) { ret . push_back ( answer . top ( ) ) ; answer . pop ( ) ; } reverse ( ret . begin ( ) , ret . end ( ) ) ; cout << ret ; } int main ( ) { string S = "" aabdaabc "" ; int K = 3 ; smallestSubsequence ( S , K ) ; return 0 ; }",Lexicographically smallest K.
34,Check if string is right to left diagonal or not | C ++ program to Check if the given string is right to left diagonal or not ; Function to check if the given string is right to left diagonal or not ; Iterate over string ; If character is not same as the first character then return false ; Driver Code ; Given String str ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int is_rtol ( string s ) { int tmp = sqrt ( s . length ( ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; } int main ( ) { string str = "" abcxabxcaxbcxabc "" ; if ( is_rtol ( str ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }",Check if string is right to left diagonal or not.
35,"Split a given string into substrings of length K with equal sum of ASCII values | C ++ program to check if a given string can be split into substrings of size K having an equal sum of ASCII values . ; Function for checking string ; Check if the string can be split into substrings of K length only ; Compute the sum of first substring of length K ; Compute the sum of remaining substrings ; Check if sum is equal to that of the first substring ; Since all sums are not equal , return false ; All sums are equal , Return true ; All substrings cannot be of size K ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str , int K ) { if ( str . size ( ) % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] ; } for ( int j = i ; j < str . size ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str [ p ] ; if ( s_comp != sum ) return false ; } return true ; } return false ; } int main ( ) { int K = 3 ; string str = "" abdcbbdba "" ; if ( check ( str , K ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; }",Split a given string into substrings of length K with equal sum of ASCII values.
36,Maximize count of 0 s in left and 1 s in right substring by splitting given Binary string | C ++ program for the above approach ; Function to maximize the sum of the count of zeros and ones in the left and right substring ; To store the total ones ; Count the total numbers of ones in string str ; To store the count of zeros and ones while traversing string ; Iterate the given string and update the maximum sum ; Update the maximum Sum ; Driver Code ; Given binary string ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( string & str ) { int maximumSum = 0 ; int totalOnes ; totalOnes = count ( str . begin ( ) , str . end ( ) , '1' ) ; int zero = 0 , ones = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { ones ++ ; } maximumSum = max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; } int main ( ) { string str = ""011101"" ; cout << maxSum ( str ) ; return 0 ; }",Maximize count of 0 s in left and 1 s in right substring by splitting given Binary string.
37,Longest substring such that no three consecutive characters are same | C ++ implementation of the approach ; Function to return the length of the longest substring such that no three consecutive characters are same ; If the length of the given string is less than 3 ; Initialize temporary and final ans to 2 as this is the minimum length of substring when length of the given string is greater than 2 ; Traverse the string from the third character to the last ; If no three consecutive characters are same then increment temporary count ; Else update the final ans and reset the temporary count ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLenSubStr ( string & s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = max ( temp , ans ) ; temp = 2 ; } } ans = max ( temp , ans ) ; return ans ; } int main ( ) { string s = "" baaabbabbb "" ; cout << maxLenSubStr ( s ) ; return 0 ; }",Longest substring such that no three consecutive characters are same.
38,Number of ways to remove a sub | C ++ program to count number of ways of removing a substring from a string such that all remaining characters are equal ; Function to return the number of ways of removing a sub - string from s such that all the remaining characters are same ; To store the count of prefix and suffix ; Loop to count prefix ; Loop to count suffix ; First and last characters of the string are same ; Otherwise ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int no_of_ways ( string s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } int main ( ) { string s = "" geeksforgeeks "" ; cout << no_of_ways ( s ) ; return 0 ; }",Number of ways to remove a sub.
39,Count number of indices such that s [ i ] = s [ i + 1 ] : Range queries | C ++ program to find substring with ; Function to create prefix array ; Function to return the result of the query ; Driver Code ; Query 1 ; Query 2,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void preCompute ( int n , string s , int pref [ ] ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } } int query ( int pref [ ] , int l , int r ) { return pref [ r ] - pref [ l ] ; } int main ( ) { string s = "" ggggggg "" ; int n = s . length ( ) ; int pref [ n ] ; preCompute ( n , s , pref ) ; int l = 1 ; int r = 2 ; cout << query ( pref , l , r ) << endl ; l = 1 ; r = 5 ; cout << query ( pref , l , r ) << endl ; return 0 ; }",Count number of indices such that s [ i ] = s [ i + 1 ] : Range queries.
40,Find the direction from given string | CPP implementation of above approach ; Function to find the final direction ; if count is positive that implies resultant is clockwise direction ; if count is negative that implies resultant is anti - clockwise direction ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string findDirection ( string s ) { int count = 0 ; string d = "" "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ 0 ] == ' ' ) return NULL ; if ( s [ i ] == ' L ' ) count -- ; else { if ( s [ i ] == ' R ' ) count ++ ; } } if ( count > 0 ) { if ( count % 4 == 0 ) d = "" N "" ; else if ( count % 4 == 1 ) d = "" E "" ; else if ( count % 4 == 2 ) d = "" S "" ; else if ( count % 4 == 3 ) d = "" W "" ; } if ( count < 0 ) { if ( count % 4 == 0 ) d = "" N "" ; else if ( count % 4 == -1 ) d = "" W "" ; else if ( count % 4 == -2 ) d = "" S "" ; else if ( count % 4 == -3 ) d = "" E "" ; } return d ; } int main ( ) { string s = "" LLRLRRL "" ; cout << ( findDirection ( s ) ) << endl ; s = "" LL "" ; cout << ( findDirection ( s ) ) << endl ; }",Find the direction from given string.
41,Check if lowercase and uppercase characters are in same order | C ++ program to check if lowercase and uppercase characters are in same order ; Function to check if both the case follow the same order ; Traverse the string ; Store both lowercase and uppercase in two different strings ; using transform ( ) function and :: toupper in STL ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCheck ( string str ) { int len = str . length ( ) ; string lowerStr = "" "" , upperStr = "" "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= 65 && str [ i ] <= 91 ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } transform ( lowerStr . begin ( ) , lowerStr . end ( ) , lowerStr . begin ( ) , :: toupper ) ; return lowerStr == upperStr ; } int main ( ) { string str = "" geeGkEEsKS "" ; isCheck ( str ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Check if lowercase and uppercase characters are in same order.
42,Replace every character of string by character whose ASCII value is K times more than it | CPP program to move every character K times ahead in a given string ; Function to move string character ; changed string ; iterate for every characters ; ASCII value ; store the duplicate ; if k - th ahead character exceed ' z ' ; print the new string ; driver code ; function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void encode ( string s , int k ) { string newS ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int val = int ( s [ i ] ) ; int dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += char ( 96 + k ) ; } else newS += char ( val + k ) ; k = dup ; } cout << newS ; } int main ( ) { string str = "" abc "" ; int k = 28 ; encode ( str , k ) ; return 0 ; }",Replace every character of string by character whose ASCII value is K times more than it.
43,"Modify string by removing vowels in between two consonants | C ++ program to remove all Vowels in between two consonants from the string ; Function to check if the character x is a vowel or not ; Returns the updated string formed after removing all the Sandwiched Vowels from the given string ; string to store the Updated String after removing the Sandwiched Vowels ; traverse the string from left to right ; if the current character is the first or the last character of the string then , this needs to be appended to the updatedString , since the corner alphabet irrespective of it being a vowel or a consonant , is never ' Sandwiched ' ; Check if the current character of the string is a vowel and both the previous and the next characters are consonants , if so then this is a sandwiched vowel , thus is ignored and not appended to the updated string ; if this character is not a sandwiched Vowel append it to the updated String ; Driver Code ; Remove all the Sandwitched Vowels","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char x ) { if ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) return true ; else return false ; } string updateSandwichedVowels ( string a ) { int n = a . length ( ) ; string updatedString = "" "" ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! i i == n - 1 ) { updatedString += a [ i ] ; continue ; } if ( isVowel ( a [ i ] ) && ! isVowel ( a [ i - 1 ] ) && ! isVowel ( a [ i + 1 ] ) ) { continue ; } updatedString += a [ i ] ; } return updatedString ; } int main ( ) { string str = "" geeksforgeeks "" ; string updatedString = updateSandwichedVowels ( str ) ; cout << updatedString ; return 0 ; }",Modify string by removing vowels in between two consonants.
44,"Print all paths of the Binary Tree with maximum element in each path greater than or equal to K | C ++ program to print paths with maximum element in the path greater than K ; A Binary Tree node ; A utility function to create a new node ; A recursive function to print the paths whose maximum element is greater than or equal to K . ; If the current node value is greater than or equal to k , then all the subtrees following that node will get printed , flag = 1 indicates to print the required path ; If the leaf node is encountered , then the path is printed if the size of the path vector is greater than 0 ; Append the node to the path vector ; Recur left and right subtrees ; Backtracking to return the vector and print the path if the flag is 1 ; Function to initialize the variables and call the utility function to print the paths with maximum values greater than or equal to K ; Initialize flag ; ans is used to check empty condition ; Call function that print path ; If the path doesn 't exist ; Driver code ; Constructing the following tree : 10 / \ 5 8 / \ / \ 29 2 1 98 / \ 20 50","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * newNode = new Node ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return ( newNode ) ; } void findPathUtil ( Node * root , int k , vector < int > path , int flag , int & ans ) { if ( root == NULL ) return ; if ( root -> data >= k ) flag = 1 ; if ( root -> left == NULL && root -> right == NULL ) { if ( flag == 1 ) { ans = 1 ; cout << "" ( "" ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { cout << path [ i ] << "" , ▁ "" ; } cout << root -> data << "" ) , ▁ "" ; } return ; } path . push_back ( root -> data ) ; findPathUtil ( root -> left , k , path , flag , ans ) ; findPathUtil ( root -> right , k , path , flag , ans ) ; path . pop_back ( ) ; } void findPath ( Node * root , int k ) { int flag = 0 ; int ans = 0 ; vector < int > v ; findPathUtil ( root , k , v , flag , ans ) ; if ( ans == 0 ) cout << "" - 1"" ; } int main ( void ) { int K = 25 ; struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 5 ) ; root -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 29 ) ; root -> left -> right = newNode ( 2 ) ; root -> right -> right = newNode ( 98 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right -> right = newNode ( 50 ) ; root -> left -> left -> left = newNode ( 20 ) ; findPath ( root , K ) ; return 0 ; }",Print all paths of the Binary Tree with maximum element in each path greater than or equal to K.
45,Tridecagonal Number | C ++ program to find N - th Tridecagonal number ; Function to find N - th Tridecagonal number ; Formula to calculate nth Tridecagonal number ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Tridecagonal_num ( n ) << endl ; n = 10 ; cout << Tridecagonal_num ( n ) << endl ; return 0 ; },Tridecagonal Number.
46,Check if a given Binary Tree is Heap | C ++ program to checks if a binary tree is max heap or not ; Tree node structure ; To add a new node ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int k ) { struct Node * node = new Node ; node -> data = k ; node -> right = node -> left = NULL ; return node ; } bool isHeap ( Node * root ) { queue < Node * > q ; q . push ( root ) ; bool nullish = false ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { if ( nullish temp -> left -> data > = temp -> data ) { return false ; } q . push ( temp -> left ) ; } else { nullish = true ; } if ( temp -> right ) { if ( nullish temp -> right -> data > = temp -> data ) { return false ; } q . push ( temp -> right ) ; } else { nullish = true ; } } return true ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 3 ) ; root -> left -> left -> right = newNode ( 2 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( isHeap ( root ) ) cout << "" Given ▁ binary ▁ tree ▁ is ▁ a ▁ Heap STRNEWLINE "" ; else cout << "" Given ▁ binary ▁ tree ▁ is ▁ not ▁ a ▁ Heap STRNEWLINE "" ; return 0 ; }",Check if a given Binary Tree is Heap.
47,Number of N digit integers with weight W | CPP program to find total possible numbers with n digits and weight w ; Function to find total possible numbers with n digits and weight w ; When Weight of an integer is Positive ; Subtract the weight from 9 ; When weight of an integer is negative ; add the weight to 10 to make it positive ; Driver code ; number of digits in an integer and w as weight ; print the total possible numbers with n digits and weight w,"#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= -9 && w <= -1 ) { x = 10 + w ; } sum = pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; } int main ( ) { int n , w ; n = 3 , w = 4 ; cout << findNumbers ( n , w ) ; ; return 0 ; }",Number of N digit integers with weight W.
48,Maximum height of triangular arrangement of array values | C ++ program to find the maximum height of Pyramidal Arrangement of array values ; Just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) / 2 elements in the array ; updating the result value each time ; otherwise we have exceeded n value ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; } int main ( ) { int arr [ ] = { 40 , 100 , 20 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaximumHeight ( arr , n ) ; return 0 ; }",Maximum height of triangular arrangement of array values.
49,k | CPP program to find k - th element in the Odd - Even sequence . ; insert all the odd numbers from 1 to n . ; insert all the even numbers from 1 to n . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int n , int k ) { vector < long > a ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push_back ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push_back ( i ) ; return ( a [ k - 1 ] ) ; } int main ( ) { long n = 10 , k = 3 ; cout << findK ( n , k ) << endl ; return 0 ; }",k.
50,One line function for factorial of a number | C ++ program to find factorial of given number ; single line to find factorial ; Driver Code,"#include <iostream> NEW_LINE int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; printf ( "" Factorial ▁ of ▁ % d ▁ is ▁ % d "" , num , factorial ( num ) ) ; return 0 ; }",One line function for factorial of a number.
51,Pell Number | Iterative Pell Number Series in C ++ ; Calculate nth pell number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; } int main ( ) { int n = 4 ; cout << pell ( n ) ; return 0 ; }",Pell Number.
52,An efficient way to check whether n | A simple C ++ program to check if n - th Fibonacci number is multiple of 10. ; Returns true if n - th Fibonacci number is multiple of 10. ; main function,"#include <bits/stdc++.h> NEW_LINE bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; } int main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) printf ( "" Yes STRNEWLINE "" ) ; else printf ( "" No STRNEWLINE "" ) ; return 0 ; }",An efficient way to check whether n.
53,"Find politeness of a number | C + program to find politeness of number ; A function to count all odd prime factors of a given number n ; Eliminate all even prime factor of number of n ; n must be odd at this point , so iterate for only odd numbers till sqrt ( n ) ; if i divides n , then start counting of Odd divisors ; If n odd prime still remains then count it ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; int countOddPrimeFactors ( int n ) { int result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; } int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; } int main ( ) { int n = 90 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; n = 15 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; return 0 ; }",Find politeness of a number.
54,"Nearest prime less than given number n | C ++ program to find the nearest prime to n . ; array to store all primes less than 10 ^ 6 ; Utility function of Sieve of Sundaram ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x ; This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j ; eliminate indexes which does not produce primes ; Since 2 is a prime number ; Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; modified binary search to find nearest prime less than N ; base condition is , if we are reaching at left corner or right corner of primes [ ] array then return that corner element because before or after that we don 't have any prime number in  primes array ; now if n is itself a prime so it will be present in primes array and here we have to find nearest prime less than n so we will return primes [ mid - 1 ] ; now if primes [ mid ] < n and primes [ mid + 1 ] > n that mean we reached at nearest prime ; Driver program to run the case","#include <bits/stdc++.h> NEW_LINE #define MAX  1000000 NEW_LINE using namespace std ; vector < int > primes ; void Sieve ( ) { int n = MAX ; int nNew = sqrt ( n ) ; int marked [ n / 2 + 500 ] = { 0 } ; for ( int i = 1 ; i <= ( nNew - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . push_back ( 2 * i + 1 ) ; } int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( mid == 0 || mid == primes . size ( ) - 1 ) return primes [ mid ] ; if ( primes [ mid ] == n ) return primes [ mid - 1 ] ; if ( primes [ mid ] < n && primes [ mid + 1 ] > n ) return primes [ mid ] ; if ( n < primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; } int main ( ) { Sieve ( ) ; int n = 17 ; cout << binarySearch ( 0 , primes . size ( ) - 1 , n ) ; return 0 ; }",Nearest prime less than given number n.
55,Program for factorial of a number | C ++ program to find factorial of given number ; function to find factorial of given number ; Driver code,"#include <iostream> NEW_LINE using namespace std ; unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << "" Factorial ▁ of ▁ "" << num << "" ▁ is ▁ "" << factorial ( num ) << endl ; return 0 ; }",Program for factorial of a number.
56,Turn off the rightmost set bit | Set 2 | C ++ program to unset the rightmost set bit ; Unsets the rightmost set bit of n and returns the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int FlipBits ( unsigned int n ) { return n -= ( n & ( - n ) ) ; } int main ( ) { int N = 12 ; cout << "" The ▁ number ▁ after ▁ unsetting ▁ the "" ; cout << "" ▁ rightmost ▁ set ▁ bit : ▁ "" << FlipBits ( N ) ; return 0 ; }",Turn off the rightmost set bit.
57,Maximum value of XOR among all triplets of an array | C ++ implementation of the approach ; function to count maximum XOR value for a triplet ; set is used to avoid repetitions ; store all possible unique XOR value of pairs ; store maximum value ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maximum_xor_Triplet ( int n , int a [ ] ) { set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { s . insert ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; for ( auto i : s ) { for ( int j = 0 ; j < n ; j ++ ) { ans = max ( ans , i ^ a [ j ] ) ; } } cout << ans << "" STRNEWLINE "" ; } int main ( ) { int a [ ] = { 1 , 3 , 8 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Maximum_xor_Triplet ( n , a ) ; return 0 ; }",Maximum value of XOR among all triplets of an array.
58,"Find missing elements of a range | A sorting based C ++ program to find missing elements from an array ; Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; Do binary search for ' low ' in sorted array and find index of first element which either equal to or greater than low . ; Start from the found index and linearly search every range element x after this index in arr [ ] ; If x doesn 't math with current element  print it ; If x matches , move to next element in arr [ ] ; Move to next element in range [ low , high ] ; Print range elements thar are greater than the last element of sorted array . ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { sort ( arr , arr + n ) ; int * ptr = lower_bound ( arr , arr + n , low ) ; int index = ptr - arr ; int i = index , x = low ; while ( i < n && x <= high ) { if ( arr [ i ] != x ) cout << x << "" ▁ "" ; else i ++ ; x ++ ; } while ( x <= high ) cout << x ++ << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }",Find missing elements of a range.
59,"Find missing elements of a range | An array based C ++ program to find missing elements from an array ; Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; Create boolean array of size high - low + 1 , each index i representing wether ( i + low ) th element found or not . ; if ith element of arr is in range low to high then mark corresponding index as true in array ; Traverse through the range and print all elements whose value is false ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { bool points_of_range [ high - low + 1 ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; } for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) cout << low + x << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }",Find missing elements of a range.
60,"Find missing elements of a range | A hashing based C ++ program to find missing elements from an array ; Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; Insert all elements of arr [ ] in set ; Traverse throught the range an print all missing elements ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int x = low ; x <= high ; x ++ ) if ( s . find ( x ) == s . end ( ) ) cout << x << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }",Find missing elements of a range.
61,k | C ++ program to find the k - th missing element in a given sequence ; Returns k - th missing element . It returns - 1 if no k is more than number of missing elements . ; Insert all elements of givens sequence b [ ] . ; Traverse through increasing sequence and keep track of count of missing numbers . ; driver program to test the above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return -1 ; } int main ( ) { int a [ ] = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int b [ ] = { 4 , 10 , 6 , 8 , 12 } ; int n1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int n2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; int k = 3 ; cout << find ( a , b , k , n1 , n2 ) ; return 0 ; }",k.
62,"Minimize steps to form string S from any random string of length K using a fixed length subsequences | C ++ program for the above approach ; Function to find the minimum number of string required to generate the original string ; Stores the frequency of each character of String S ; Iterate over the range [ 0 , 25 ] ; Stores the frequency of each character of String S ; Count unique characters in S ; If unique characters is greater then N , then return - 1 ; Otherwise ; Perform Binary Search ; Find the value of mid ; Iterate over the range [ 0 , 26 ] ; If the amount [ i ] is greater than 0 ; Update the ranges ; Find the resultant string ; Generate the subsequence ; If the length of resultant string is less than N than add a character ' a ' ; Print the string ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findString ( string S , int N ) { int amounts [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; } for ( int i = 0 ; i < S . length ( ) ; i ++ ) { amounts [ int ( S [ i ] ) - 97 ] ++ ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; } if ( count > N ) { cout << "" - 1"" ; } else { string ans = "" "" ; int high = 100001 ; int low = 0 ; int mid , total ; while ( ( high - low ) > 1 ) { total = 0 ; mid = ( high + low ) / 2 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / mid + 1 ; } } if ( total <= N ) { high = mid ; } else { low = mid ; } } cout << high << "" ▁ "" ; total = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / high + 1 ; for ( int j = 0 ; j < ( ( amounts [ i ] - 1 ) / high + 1 ) ; j ++ ) { ans += char ( i + 97 ) ; } } } for ( int i = total ; i < N ; i ++ ) { ans += ' a ' ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; cout << ans ; } } int main ( ) { string S = "" toffee "" ; int K = 4 ; findString ( S , K ) ; return 0 ; }",Minimize steps to form string S from any random string of length K using a fixed length subsequences.
63,"Find the first repeating element in an array of integers | C ++ program to find first repeating element in arr [ ] ; This function prints the first repeating element in arr [ ] ; Initialize index of first repeating element ; Creates an empty hashset ; Traverse the input array from right to left ; If element is already in hash set , update min ; Else add element to hash set ; Print the result ; Driver method to test above method","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int min = -1 ; set < int > myset ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i ; else myset . insert ( arr [ i ] ) ; } if ( min != -1 ) cout << "" The ▁ first ▁ repeating ▁ element ▁ is ▁ "" << arr [ min ] ; else cout << "" There ▁ are ▁ no ▁ repeating ▁ elements "" ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }",Find the first repeating element in an array of integers.
64,"Find the first repeating element in an array of integers | C ++ program to find first repeating element in arr [ ] ; This function prints the first repeating element in arr [ ] ; This will set k = 1 , if any repeating element found ; max = maximum from ( all elements & n ) ; Array a is for storing 1 st time occurence of element initialized by 0 ; Store 1 in array b if element is duplicate initialized by 0 ; Duplicate element found ; storing 1 st occurence of arr [ i ] ; trace array a & find repeating element with min index ; Driver method to test above method","#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int k = 0 ; int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ; int a [ max + 1 ] = { } ; int b [ max + 1 ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ arr [ i ] ] ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else a [ arr [ i ] ] = i ; } if ( k == 0 ) cout << "" No ▁ repeating ▁ element ▁ found "" << endl ; else { int min = max + 1 ; for ( int i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] && min > a [ i ] && b [ i ] ) min = a [ i ] ; cout << arr [ min ] ; } cout << endl ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }",Find the first repeating element in an array of integers.
65,k | C ++ program to print k - th distinct element in a given array ; Returns k - th distinct element in arr . ; Check if current element is present somewhere else . ; If element is unique ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; } int main ( ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; int k = 2 ; cout << printKDistinct ( ar , n , k ) ; return 0 ; }",k.
66,Count subarrays having an equal count of 0 s and 1 s segregated | C ++ program for the above approach ; Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together ; Stores the count ; Initialize cur with first element ; If the next element is same as the current element ; Increment count ; Update curr ; Iterate over the array count ; Consider the minimum ; Driver code ; Given arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int A [ ] , int N ) { int res = 0 ; int curr = A [ 0 ] ; vector < int > cnt = { 1 } ; for ( int c = 1 ; c < N ; c ++ ) { if ( A == curr ) cnt [ cnt . size ( ) - 1 ] ++ ; else curr = A ; cnt . push_back ( 1 ) ; } for ( int i = 1 ; i < cnt . size ( ) ; i ++ ) { res += min ( cnt [ i - 1 ] , cnt [ i ] ) ; } cout << ( res - 1 ) ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }",Count subarrays having an equal count of 0 s and 1 s segregated.
67,Check if a Binary Tree is an Even | C ++ program for the above approach ; Tree node ; Function to return new tree node ; Function to check if the tree is even - odd tree ; Stores nodes of each level ; Store the current level of the binary tree ; Traverse until the queue is empty ; Stores the number of nodes present in the current level ; Check if the level is even or odd ; Add the nodes of the next level into the queue ; Increment the level count ; Driver Code ; Construct a Binary Tree ; Check if the binary tree is even - odd tree or not,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int val ; Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> val = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } bool isEvenOddBinaryTree ( Node * root ) { if ( root == NULL ) return true ; queue < Node * > q ; q . push ( root ) ; int level = 0 ; while ( ! q . empty ( ) ) { int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node * node = q . front ( ) ; if ( level % 2 == 0 ) { if ( node -> val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node -> val % 2 == 0 ) return true ; } if ( node -> left != NULL ) { q . push ( node -> left ) ; } if ( node -> right != NULL ) { q . push ( node -> right ) ; } } level ++ ; } return true ; } int main ( ) { Node * root = NULL ; root = newNode ( 2 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 9 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 10 ) ; root -> right -> right = newNode ( 6 ) ; if ( isEvenOddBinaryTree ( root ) ) cout << "" YES "" ; else cout << "" NO "" ; }",Check if a Binary Tree is an Even.
68,Maximize minimum distance between repetitions from any permutation of the given Array | C ++ Program to implement the above approach ; Size of the array ; Stores the frequency of array elements ; Find the highest frequency in the array ; Increase count of max frequent element ; If no repetition is present ; Find the maximum distance ; Return the max distance ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLen ( vector < int > & a ) { int n = a . size ( ) ; int freq [ n + 1 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } int maxFreqElement = INT_MIN ; int maxFreqCount = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; } else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } int ans ; if ( maxFreqElement == 1 ) ans = 0 ; else { ans = ( ( n - maxFreqCount ) / ( maxFreqElement - 1 ) ) ; } return ans ; } int main ( ) { vector < int > a = { 1 , 2 , 1 , 2 } ; cout << findMaxLen ( a ) << endl ; }",Maximize minimum distance between repetitions from any permutation of the given Array.
69,"Queries to evaluate the given equation in a range [ L , R ] | C ++ Program to implement the above approach ; Function to obtain the middle index of the range ; Recursive function to get the sum of values in the given range from the array . The following are parameters for this function . st -> Pointer to segment tree node -> Index of current node in the segment tree ss & se -> Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r -> Starting and ending indexes of range query ; If the segment of this node lies completely within the given range ; Return maximum in the segment ; If the segment of this node lies outside the given range ; If segment of this node lies partially in the given range ; Function to return the maximum in the range from [ l , r ] ; Check for erroneous input values ; Function to construct Segment Tree for the subarray [ ss . . se ] ; For a single element ; Otherwise ; Recur for left subtree ; Recur for right subtree ; Function to construct Segment Tree from the given array ; Height of Segment Tree ; Maximum size of Segment Tree ; Allocate memory ; Fill the allocated memory ; Return the constructed Segment Tree ; Driver Code ; Build the Segment Tree from the given array","#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se ) ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } int getMax ( int * st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { printf ( "" Invalid ▁ Input "" ) ; return -1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } int mid = getMid ( ss , se ) ; st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * st = constructST ( arr , n ) ; vector < vector < int > > Q = { { 1 , 3 } , { 0 , 2 } } ; for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; int ok = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { if ( ( max & ( 1 << i ) ) != 0 ) ok = 1 ; if ( ! ok ) continue ; max |= ( 1 << i ) ; } cout << max << "" ▁ "" ; } return 0 ; }","Queries to evaluate the given equation in a range [ L , R ]."
70,Find number of pairs in an array such that their XOR is 0 | C ++ program to find number of pairs in an array such that their XOR is 0 ; Function to calculate the count ; Sorting the list using built in function ; Traversing through the elements ; Counting frequency of each elements ; Adding the contribution of the frequency to the answer ; Driver Code ; Print the count,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }",Find number of pairs in an array such that their XOR is 0.
71,Find number of pairs in an array such that their XOR is 0 | C ++ program to find number of pairs in an array such that their XOR is 0 ; Function to calculate the answer ; Finding the maximum of the array ; Creating frequency array With initial value 0 ; Traversing through the array ; Counting frequency ; Traversing through the frequency array ; Calculating answer ; Driver Code ; Function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { int * maximum = max_element ( a , a + n ) ; int frequency [ * maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( calculate ( a , n ) ) ; }",Find number of pairs in an array such that their XOR is 0.
72,"Largest subarray with equal number of 0 s and 1 s | A simple C ++ program to find the largest subarray with equal number of 0 s and 1 s ; This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray . ; Pick a starting point as i ; Consider all subarrays starting from i ; If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << "" No ▁ such ▁ subarray "" ; else cout << startindex << "" ▁ to ▁ "" << startindex + maxsize - 1 ; return maxsize ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }",Largest subarray with equal number of 0 s and 1 s.
73,"Maximum element in a sorted and rotated array |  ; Function to return the maximum element ; If there is only one element left ; Find mid ; Check if mid reaches 0 , it is greater than next element or not ; Check if mid itself is maximum element ; Decide whether we need to go to the left half or the right half ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMax ( int arr [ ] , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } } int main ( ) { int arr [ ] = { 6 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMax ( arr , 0 , n - 1 ) ; return 0 ; }",Maximum element in a sorted and rotated array.
74,"Ternary Search | C ++ program to illustrate iterative approach to ternary search ; Function to perform Ternary Search ; Find the mid1 and mid2 ; Check if key is present at any mid ; Since key is not present at mid , check in which region it is present then repeat the Search operation in that region ; The key lies in between l and mid1 ; The key lies in between mid2 and r ; The key lies in between mid1 and mid2 ; Key not found ; Driver code ; Get the array Sort the array if not sorted ; Starting index ; length of array ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result","#include <iostream> NEW_LINE using namespace std ; int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return -1 ; } int main ( ) { int l , r , p , key ; int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; cout << "" Index ▁ of ▁ "" << key << "" ▁ is ▁ "" << p << endl ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; cout << "" Index ▁ of ▁ "" << key << "" ▁ is ▁ "" << p ; }",Ternary Search.
75,Majority Element | Set |  ; function to print the majority Number ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int majorityNumber ( int arr [ ] , int n ) { int ans = -1 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq [ arr [ i ] ] > n / 2 ) ans = arr [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 2 , 2 , 1 , 1 , 1 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << majorityNumber ( a , n ) ; return 0 ; }",Majority Element.
76,"Search an element in a sorted and rotated array | Search an element in sorted and rotated array using single pass of Binary Search ; Returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1 ; If arr [ l ... mid ] is sorted ; As this subarray is sorted , we can quickly check if key lies in half or other half ; If key not lies in first half subarray , Divide other half into two subarrays , such that we can quickly check if key lies in other half ; If arr [ l . . mid ] first subarray is not sorted , then arr [ mid ... h ] must be sorted subarray ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != -1 ) cout << "" Index : ▁ "" << i << endl ; else cout << "" Key ▁ not ▁ found "" ; }",Search an element in a sorted and rotated array.
77,"Find the minimum element in a sorted and rotated array | C ++ program to find minimum element in a sorted and rotated array ; This condition is needed to handle the case when array is not rotated at all ; If there is only one element left ; Find mid ; Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 } ; Check if mid itself is minimum element ; Decide whether we need to go to left half or right half ; Driver program to test above functions","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }",Find the minimum element in a sorted and rotated array.
78,Find the minimum element in a sorted and rotated array | C ++ program to find minimum element in a sorted and rotated array contating duplicate elements . ; Function to find minimum element ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << "" The ▁ minimum ▁ element ▁ is ▁ "" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }",Find the minimum element in a sorted and rotated array.
79,k | C ++ program to find k - th absolute difference between two elements ; returns number of pairs with absolute difference less than or equal to mid . ; Upper bound returns pointer to position of next higher number than a [ i ] + mid in a [ i . . n - 1 ] . We subtract ( a + i + 1 ) from this position to count ; Returns k - th absolute difference ; Sort array ; Minimum absolute difference ; Maximum absolute difference ; Do binary search for k - th absolute difference ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int * a , int n , int mid ) { int res = 0 ; for ( int i = 0 ; i < n ; ++ i ) res += upper_bound ( a + i , a + n , a [ i ] + mid ) - ( a + i + 1 ) ; return res ; } int kthDiff ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int low = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i <= n - 2 ; ++ i ) low = min ( low , a [ i + 1 ] - a [ i ] ) ; int high = a [ n - 1 ] - a [ 0 ] ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( countPairs ( a , n , mid ) < k ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { int k = 3 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << kthDiff ( a , n , k ) ; return 0 ; }",k.
80,Find the smallest and second smallest elements in an array | C ++ program to find smallest and second smallest elements ; For INT_MAX ; There should be atleast two elements ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void print2Smallest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { cout << "" ▁ Invalid ▁ Input ▁ "" ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) cout << "" There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE "" ; else cout << "" The ▁ smallest ▁ element ▁ is ▁ "" << first << "" ▁ and ▁ second ▁ "" "" Smallest ▁ element ▁ is ▁ "" << second << endl ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2Smallest ( arr , n ) ; return 0 ; }",Find the smallest and second smallest elements in an array.
81,"Range LCM Queries | LCM of given range queries using Segment Tree ; allocate space for tree ; declaring the array globally ; Function to return gcd of a and b ; utility function to find lcm ; Function to build the segment tree Node starts beginning index of current subtree . start and end are indexes in arr [ ] which is global ; If there is only one element in current subarray ; build left and right segments ; build the parent ; Function to make queries for array range ) l , r ) . Node is index of root of current segment in segment tree ( Note that indexes in segment tree begin with 1f or simplicity ) . start and end are indexes of subarray covered by root of current segment . ; Completely outside the segment , returning 1 will not affect the lcm ; ; completely inside the segment ; partially inside ; driver function to check the above program ; initialize the array ; build the segment tree ; Now we can answer each query efficiently Print LCM of ( 2 , 5 ) ; Print LCM of ( 5 , 10 ) ; Print LCM of ( 0 , 10 )","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int tree [ 4 * MAX ] ; int arr [ MAX ] ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return a * b / gcd ( a , b ) ; } void build ( int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; int left_lcm = tree [ 2 * node ] ; int right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; } int query ( int node , int start , int end , int l , int r ) { if ( end < l start > r ) return 1 ; if ( l <= start && r >= end ) return tree [ node ] ; int mid = ( start + end ) / 2 ; int left_lcm = query ( 2 * node , start , mid , l , r ) ; int right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; } int main ( ) { arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; cout << query ( 1 , 0 , 10 , 2 , 5 ) << endl ; cout << query ( 1 , 0 , 10 , 5 , 10 ) << endl ; cout << query ( 1 , 0 , 10 , 0 , 10 ) << endl ; return 0 ; }",Range LCM Queries.
82,"Count possible decoding of a given digit sequence with hidden characters |  ; check the first character of the string if it is ' * ' then 9 ways ; traverse the string ; If s [ i ] = = ' * ' there can be 9 possible values of * ; If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 ) ; If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 ) ; If the previous digit is * then all 15 2 - digit characters can be formed ; taking the value from previous step ; If previous character is 1 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] . ; If previous character is 2 and ith character is less than 6 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] . ; If previous character is * then it will contain the above 2 cases ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { vector < int > dp ( ( int ) s . size ( ) + 1 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ ( int ) s . size ( ) ] ; } int main ( ) { string s = ""12"" ; cout << waysOfDecoding ( s ) ; return 0 ; }",Count possible decoding of a given digit sequence with hidden characters.
83,Count ways to split array into two subsets having difference between their sum equal to K | C ++ program for the above approach ; Function to count the number of ways to divide the array into two subsets and such that the difference between their sums is equal to diff ; Store the sum of the set S1 ; Initializing the matrix ; Number of ways to get sum using 0 elements is 0 ; Number of ways to get sum 0 using i elements is 1 ; Traverse the 2D array ; If the value is greater than the sum store the value of previous state ; Return the result ; Driver Code ; Given Input ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubset ( int arr [ ] , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; } int main ( ) { int diff = 1 , n = 4 ; int arr [ ] = { 1 , 1 , 2 , 3 } ; cout << countSubset ( arr , n , diff ) ; }",Count ways to split array into two subsets having difference between their sum equal to K.
84,Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers | C ++ program for above approach ; Function to calculate probability that the sum of numbers on N throws of dice lies between A and B ; Base case ; Add the probability for all the numbers between a and b ; Driver Code ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int a , int b ) { float probability = 0.0 ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = 1.0 / 6 ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = find ( N , a , b ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }",Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers.
85,Maximum sum from a tree with adjacent levels not allowed | C ++ code for max sum with adjacent levels not allowed ; Tree node class for Binary Tree representation ; Recursive function to find the maximum sum returned for a root node and its grandchildren ; Returns maximum sum with adjacent levels not allowed -> This function mainly uses getSumAlternate ( ) ; We compute sum of alternate levels starting first level and from second level -> And return maximum of two values -> ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int item ) { data = item ; } } ; int getSum ( Node * root ) ; int getSumAlternate ( Node * root ) { if ( root == NULL ) return 0 ; int sum = root -> data ; if ( root -> left != NULL ) { sum += getSum ( root -> left -> left ) ; sum += getSum ( root -> left -> right ) ; } if ( root -> right != NULL ) { sum += getSum ( root -> right -> left ) ; sum += getSum ( root -> right -> right ) ; } return sum ; } int getSum ( Node * root ) { if ( root == NULL ) return 0 ; return max ( getSumAlternate ( root ) , ( getSumAlternate ( root -> left ) + getSumAlternate ( root -> right ) ) ) ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> right -> left = new Node ( 4 ) ; root -> right -> left -> right = new Node ( 5 ) ; root -> right -> left -> right -> left = new Node ( 6 ) ; cout << ( getSum ( root ) ) ; return 0 ; }",Maximum sum from a tree with adjacent levels not allowed.
86,"Subset Sum Problem in O ( sum ) space | Returns true if there exists a subset with given sum in arr [ ] ; Returns true if there exists a subset with given sum in arr [ ] ; The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ] ; A subset with sum 0 is always possible ; If there exists no element no sum is possible ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; } int main ( ) { int arr [ ] = { 6 , 2 , 5 } ; int sum = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSubsetSum ( arr , n , sum ) == true ) cout << "" There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ exists ▁ with ▁ given ▁ sum "" ; return 0 ; }",Subset Sum Problem in O ( sum ) space.
87,Maximum equlibrium sum in an array | CPP program to find maximum equilibrium sum . ; Function to find maximum equilibrium sum . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }",Maximum equlibrium sum in an array.
88,Maximum equlibrium sum in an array | CPP program to find maximum equilibrium sum . ; Function to find maximum equilibrium sum . ; Array to store prefix sum . ; Array to store suffix sum . ; Variable to store maximum sum . ; Calculate prefix sum . ; Calculate suffix sum and compare it with prefix sum . Update ans accordingly . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }",Maximum equlibrium sum in an array.
89,Maximum equlibrium sum in an array | CPP program to find maximum equilibrium sum . ; Function to find maximum equilibrium sum . ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int sum = accumulate ( arr , arr + n , 0 ) ; int prefix_sum = 0 , res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }",Maximum equlibrium sum in an array.
90,Majority Element | C ++ program to find Majority element in an array ; Function to find Majority element in an array ; sentinels ; update maxCount if count of current element is greater ; if maxCount is greater than n / 2 return the corresponding element ; Driver code ; Function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << "" No ▁ Majority ▁ Element "" << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }",Majority Element.
91,"Majority Element | C ++ program to demonstrate insert operation in binary search tree . ; A utility function to create a new BST node ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; find the max count ; return the ( unchanged ) node pointer ; A utility function to do inorder traversal of BST ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int key ; int c = 0 ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> c = 1 ; temp -> left = temp -> right = NULL ; return temp ; } struct node * insert ( struct node * node , int key , int & ma ) { if ( node == NULL ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; } if ( key < node -> key ) node -> left = insert ( node -> left , key , ma ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key , ma ) ; else node -> c ++ ; ma = max ( ma , node -> c ) ; return node ; } void inorder ( struct node * root , int s ) { if ( root != NULL ) { inorder ( root -> left , s ) ; if ( root -> c > ( s / 2 ) ) printf ( "" % d ▁ STRNEWLINE "" , root -> key ) ; inorder ( root -> right , s ) ; } } int main ( ) { int a [ ] = { 1 , 3 , 3 , 3 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; struct node * root = NULL ; int ma = 0 ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] , ma ) ; } if ( ma > ( size / 2 ) ) inorder ( root , size ) ; else cout << "" No ▁ majority ▁ element STRNEWLINE "" ; return 0 ; }",Majority Element.
92,Majority Element | C ++ Program for finding out majority element in an array ; Function to find the candidate for Majority ; Function to check if the candidate occurs more than n / 2 times ; Function to print Majority Element ; Find the candidate for Majority ; Print the candidate if it is Majority ; Driver code ; Function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; for ( int i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; } bool isMajority ( int a [ ] , int size , int cand ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( a [ i ] == cand ) count ++ ; if ( count > size / 2 ) return 1 ; else return 0 ; } void printMajority ( int a [ ] , int size ) { int cand = findCandidate ( a , size ) ; if ( isMajority ( a , size , cand ) ) cout << "" ▁ "" << cand << "" ▁ "" ; else cout << "" No ▁ Majority ▁ Element "" ; } int main ( ) { int a [ ] = { 1 , 3 , 3 , 1 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; printMajority ( a , size ) ; return 0 ; }",Majority Element.
93,Majority Element | C ++ program for finding out majority element in an array ; Driver code ; Function calling,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int size ) { unordered_map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) m [ arr [ i ] ] ++ ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; cout << "" Majority ▁ found ▁ : - ▁ "" << i . first << endl ; break ; } } if ( count == 0 ) cout << "" No ▁ Majority ▁ element "" << endl ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }",Majority Element.
94,"Majority Element | C ++ program to find Majority element in an array ; Function to find Majority element in an array it returns - 1 if there is no majority element ; sort the array in O ( nlogn ) ; increases the count if the same element occurs otherwise starts counting new element ; sets maximum count and stores maximum occured element so far if maximum count becomes greater than n / 2 it breaks out setting the flag ; returns maximum occured element if there is no such element , returns - 1 ; Driver code ; Function calling","#include <bits/stdc++.h> NEW_LINE using namespace std ; int majorityElement ( int * arr , int n ) { sort ( arr , arr + n ) ; int count = 1 , max_ele = -1 , temp = arr [ 0 ] , ele , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : -1 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << majorityElement ( arr , n ) ; return 0 ; }",Majority Element.
95,"Dynamic Programming | A Dynamic Programming solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; uncomment this code to print table ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( "" % 4d "" , subset [ i ] [ j ] ) ; cout << "" STRNEWLINE "" ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ; else cout << "" No ▁ subset ▁ with ▁ given ▁ sum "" ; return 0 ; }",Dynamic Programming.
96,Dynamic Programming | CPP program for the above approach ; Taking the matrix as globally ; Check if possible subset with given sum is possible or not ; If the sum is zero it means we got our expected sum ; If the value is not - 1 it means it already call the function with the same value . it will save our from the repetition . ; if the value of a [ n - 1 ] is greater than the sum . we call for the next value ; Here we do two calls because we don ' t ▁ know ▁ which ▁ value ▁ is ▁ ▁ full - fill ▁ our ▁ criteria ▁ ▁ that ' s why we doing two calls ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int tab [ 2000 ] [ 2000 ] ; int subsetSum ( int a [ ] , int n , int sum ) { if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != -1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } } int main ( ) { memset ( tab , -1 , sizeof ( tab ) ) ; int n = 5 ; int a [ ] = { 1 , 5 , 3 , 7 , 4 } ; int sum = 12 ; if ( subsetSum ( a , n , sum ) ) { cout << "" YES "" << endl ; } else cout << "" NO "" << endl ; }",Dynamic Programming.
97,Sum of bit differences for numbers from 0 to N | C ++ program for the above approach ; Function to implement fast exponentiation ; Function to return the value for powers of 2 ; Function to convert N into binary ; To store binary representation ; Iterate each digit of n ; Return binary representation ; Function to find difference in bits ; Get binary representation ; total number of bit differences from 0 to N ; Iterate over each binary bit ; If current bit is '1' then add the count of current bit ; Driver Code ; Given Number ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binpow ( int a , int b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b /= 2 ; } return res ; } int find ( int x ) { if ( x == 0 ) return 0 ; int p = log2 ( x ) ; return binpow ( 2 , p + 1 ) - 1 ; } string getBinary ( int n ) { string ans = "" "" ; while ( n ) { int dig = n % 2 ; ans += to_string ( dig ) ; n /= 2 ; } return ans ; } int totalCountDifference ( int n ) { string ans = getBinary ( n ) ; int req = 0 ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans [ i ] == '1' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; } int main ( ) { int N = 5 ; cout << totalCountDifference ( N ) ; return 0 ; }",Sum of bit differences for numbers from 0 to N.
98,Find the maximum length of the prefix | C ++ implementation of the approach ; Function to return the maximum length of the required prefix ; Array to store the frequency of each element of the array ; Iterating for all the elements ; Update the frequency of the current element i . e . v ; Sorted positive values from counts array ; If current prefix satisfies the given conditions ; Return the maximum length ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Maximum_Length ( vector < int > a ) { int counts [ 11 ] = { 0 } ; int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) { counts [ a [ index ] ] += 1 ; vector < int > k ; for ( auto i : counts ) if ( i != 0 ) k . push_back ( i ) ; sort ( k . begin ( ) , k . end ( ) ) ; if ( k . size ( ) == 1 || ( k [ 0 ] == k [ k . size ( ) - 2 ] && k . back ( ) - k [ k . size ( ) - 2 ] == 1 ) || ( k [ 0 ] == 1 and k [ 1 ] == k . back ( ) ) ) ans = index ; } return ans + 1 ; } int main ( ) { vector < int > a = { 1 , 1 , 1 , 2 , 2 , 2 } ; cout << ( Maximum_Length ( a ) ) ; }",Find the maximum length of the prefix.
99,Online Queries for GCD of array after divide operations | C ++ implementation of the approach ; Function to calculate gcd of onine queries ; stores the gcd of the initial array elements ; calculates the gcd ; performing online queries ; index is 1 based ; divide the array element ; calculates the current gcd ; print the gcd after each step ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_gcd_online ( int n , int m , int query [ ] [ 2 ] , int arr [ ] ) { int max_gcd = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) max_gcd = __gcd ( max_gcd , arr [ i ] ) ; for ( i = 0 ; i < m ; i ++ ) { query [ i ] [ 0 ] -- ; arr [ query [ i ] [ 0 ] ] /= query [ i ] [ 1 ] ; max_gcd = __gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ; cout << max_gcd << endl ; } } int main ( ) { int n = 3 ; int m = 3 ; int query [ m ] [ 2 ] ; int arr [ ] = { 36 , 24 , 72 } ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ; return 0 ; }",Online Queries for GCD of array after divide operations.
100,"Numbers in range [ L , R ] such that the count of their divisors is both even and prime | C ++ implementation of the approach ; stores whether the number is prime or not ; stores the count of prime numbers less than or equal to the index ; create the sieve ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all the entries as true . A value in prime [ i ] will finally be false if ' i ' is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; stores the prefix sum of number of primes less than or equal to ' i ' ; Driver code ; create the sieve ; ' l ' and ' r ' are the lower and upper bounds of the range ; get the value of count ; display the count","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX + 1 ] ; int sum [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; memset ( sum , 0 , sizeof ( sum ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } } int main ( ) { SieveOfEratosthenes ( ) ; int l = 3 , r = 9 ; int c = ( sum [ r ] - sum [ l - 1 ] ) ; cout << "" Count : ▁ "" << c << endl ; return 0 ; }","Numbers in range [ L , R ] such that the count of their divisors is both even and prime."
101,Area of a circle inscribed in a rectangle which is inscribed in a semicircle | C ++ Program to find the area of the circle inscribed within the rectangle which in turn is inscribed in a semicircle ; Function to find the area of the circle ; radius cannot be negative ; area of the circle ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }",Area of a circle inscribed in a rectangle which is inscribed in a semicircle.
102,"Find count of Almost Prime numbers from 1 to N | CPP program to count almost prime numbers from 1 to n ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to count almost prime numbers from 1 to n ; to store required answer ; 6 is first almost prime number ; to count prime factors ; if it is perfect square ; if I is almost prime number ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE bool prime [ N ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } } int almostPrimes ( int n ) { int ans = 0 ; for ( int i = 6 ; i <= n ; i ++ ) { int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i / j ] ) c ++ ; } } } if ( c == 2 ) ans ++ ; } return ans ; } int main ( ) { SieveOfEratosthenes ( ) ; int n = 21 ; cout << almostPrimes ( n ) ; return 0 ; }",Find count of Almost Prime numbers from 1 to N.
103,Divide a number into two parts such that sum of digits is maximum | C ++ implementation of above approach ; Returns sum of digits of x ; Returns closest number to x in terms of 9 's. ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x ) { ans += x % 10 ; x /= 10 ; } return ans ; } int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; } int main ( ) { int N = 35 ; cout << sumOfDigitsTwoParts ( N ) ; return 0 ; },Divide a number into two parts such that sum of digits is maximum.
104,Primality Test | Set 5 ( Using Lucas | CPP program to check for primality using Lucas - Lehmer series . ; Function to check whether ( 2 ^ p - 1 ) is prime or not . ; generate the number ; First number of the series ; Generate the rest ( p - 2 ) terms of the series . ; now if the ( p - 1 ) th term is 0 return true else false . ; Driver Program ; Check whether 2 ^ p - 1 is prime or not .,"#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool isPrime ( int p ) { long long checkNumber = pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; } int main ( ) { int p = 7 ; long long checkNumber = pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) cout << checkNumber << "" ▁ is ▁ Prime . "" ; else cout << checkNumber << "" ▁ is ▁ not ▁ Prime . "" ; return 0 ; }",Primality Test.
105,"Sophie Germain Prime | CPP program to print all sophie german prime number till n . ; function to detect prime number here we have used sieve method https : www . geeksforgeeks . org / sieve - of - eratosthenes / to detect prime number ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; We have made array till 2 * n + 1 so that we can check prime number till that and conclude about sophie german prime . ; checking every i whether it is sophie german prime or not . ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sieve ( int n , bool prime [ ] ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } void printSophieGermanNumber ( int n ) { bool prime [ 2 * n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i <= n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) cout << i << "" ▁ "" ; } } int main ( ) { int n = 25 ; printSophieGermanNumber ( n ) ; return 0 ; }",Sophie Germain Prime.
106,Bessel 's Interpolation | CPP Program to interpolate using Bessel 's interpolation ; calculating u mentioned in the formula ; calculating factorial of given number n ; Driver code ; Number of values given ; y [ ] [ ] is used for difference table with y [ ] [ 0 ] used for input ; Calculating the central difference table ; Displaying the central difference table ; value to interpolate at ; Initializing u and sum ; k is origin thats is f ( 0 ) ; if ( n % 2 ) origin for odd ; k = n / 2 - 1 ; origin for even ; Solving using bessel 's formula,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float ucal ( float u , int n ) { if ( n == 0 ) return 1 ; float temp = u ; for ( int i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; } int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } int main ( ) { int n = 6 ; float x [ ] = { 25 , 26 , 27 , 28 , 29 , 30 } ; float y [ n ] [ n ] ; y [ 0 ] [ 0 ] = 4.000 ; y [ 1 ] [ 0 ] = 3.846 ; y [ 2 ] [ 0 ] = 3.704 ; y [ 3 ] [ 0 ] = 3.571 ; y [ 4 ] [ 0 ] = 3.448 ; y [ 5 ] [ 0 ] = 3.333 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) cout << setw ( 4 ) << y [ i ] [ j ] << "" TABSYMBOL "" ; cout << endl ; } float value = 27.4 ; float sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) / 2 ; int k ; k = n / 2 ; else float u = ( value - x [ k ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( i % 2 ) sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) / fact ( i ) ; else sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ -- k ] [ i ] ) / ( fact ( i ) * 2 ) ) ; } cout << "" Value ▁ at ▁ "" << value << "" ▁ is ▁ "" << sum << endl ; return 0 ; }",Bessel 's Interpolation.
107,An efficient way to check whether n | A simple C ++ program to check if n - th Fibonacci number is multiple of 10. ; Returns true if n - th Fibonacci number is multiple of 10. ; Driver code,"#include <bits/stdc++.h> NEW_LINE int fibonacci ( int n ) { int a = 0 , b = 1 , c ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; } bool isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; } int main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) printf ( "" Yes STRNEWLINE "" ) ; else printf ( "" No STRNEWLINE "" ) ; }",An efficient way to check whether n.
108,Program to find whether a given number is power of 2 | C ++ program for above approach ; Function which checks whether a number is a power of 2 ; base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 ) ; all other odd numbers are not powers of 2 ; recursive function call ; Driver Code ; True ; False,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; if ( powerOf2 ( m ) == 1 ) cout << "" True "" << endl ; else cout << "" False "" << endl ; }",Program to find whether a given number is power of 2.
109,Program to find whether a given number is power of 2 |  ; Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerOfTwo ( 64 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }",Program to find whether a given number is power of 2.
110,Program to find whether a given number is power of 2 |  ; Function to check if x is power of 2 ; Driver code,"#include <iostream> NEW_LINE using namespace std ; bool isPowerofTwo ( long long n ) { if ( n == 0 ) return 0 ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return 1 ; return 0 ; } int main ( ) { isPowerofTwo ( 30 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; isPowerofTwo ( 128 ) ? cout << "" Yes STRNEWLINE "" : cout << "" No STRNEWLINE "" ; return 0 ; }",Program to find whether a given number is power of 2.
111,Smallest power of 2 which is greater than or equal to sum of array elements | C ++ implementation of the above approach ; Function to find the nearest power of 2 ; The number ; If already a power of 2 ; Find the next power of 2 ; Function to find the memory used ; Sum of array ; Traverse and find the sum of array ; Function call to find the nearest power of 2 ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int memoryUsed ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int nearest = nextPowerOf2 ( sum ) ; return nearest ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << memoryUsed ( arr , n ) ; return 0 ; }",Smallest power of 2 which is greater than or equal to sum of array elements.
112,Toggling k | CPP program to toggle k - th bit of n ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } int main ( ) { int n = 5 , k = 1 ; cout << toggleKthBit ( n , k ) ; return 0 ; }",Toggling k.
113,Smallest power of 2 greater than or equal to n | C ++ program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.
114,"Kth number from the set of multiples of numbers A , B and C | C ++ implementation of the approach ; Function to return the GCD of A and B ; Function to return the LCM of A and B ; Function to return the Kth element from the required set if it a multiple of A ; Start and End for Binary Search ; If no answer found return - 1 ; Inclusion and Exclusion ; Multiple should be smaller ; Multiple should be bigger ; Function to return the Kth element from the required set if it a multiple of B ; Start and End for Binary Search ; If no answer found return - 1 ; Inclusion and Exclusion ; Multiple should be smaller ; Multiple should be bigger ; Function to return the Kth element from the required set if it a multiple of C ; Start and End for Binary Search ; If no answer found return - 1 ; Inclusion and Exclusion ; Multiple should be smaller ; Multiple should be bigger ; Function to return the Kth element from the set of multiples of A , B and C ; Apply binary search on the multiples of A ; If the required element is not a multiple of A then the multiples of B and C need to be checked ; If the required element is neither a multiple of A nor a multiple of B then the multiples of C need to be checked ; Driver code","#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; } int lcm ( int A , int B ) { return ( A * B ) / gcd ( A , B ) ; } int checkA ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } int checkB ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } int checkC ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } int findKthMultiple ( int A , int B , int C , int K ) { int res = checkA ( A , B , C , K ) ; if ( res == -1 ) res = checkB ( A , B , C , K ) ; if ( res == -1 ) res = checkC ( A , B , C , K ) ; return res ; } int main ( ) { int A = 2 , B = 4 , C = 5 , K = 5 ; cout << findKthMultiple ( A , B , C , K ) ; return 0 ; }","Kth number from the set of multiples of numbers A , B and C."
115,Add elements in start to sort the array | Variation of Stalin Sort | C ++ implementation to sort the array by using the variation of the Stalin sort ; Function to sort the array ; Iterator < Integer > index = arr . iterator ( ) ; ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void variationStalinsort ( vector < int > arr ) { int j = 0 ; while ( true ) { int moved = 0 ; for ( int i = 0 ; i < ( arr . size ( ) - 1 - j ) ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { vector < int > :: iterator index ; int temp ; index = arr . begin ( ) + i + 1 ; temp = arr [ i + 1 ] ; arr . erase ( index ) ; arr . insert ( arr . begin ( ) + moved , temp ) ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { vector < int > arr = { 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 } ; variationStalinsort ( arr ) ; }",Add elements in start to sort the array.
116,Sort an Array which contain 1 to N values in O ( N ) using Cycle Sort | C ++ program for the above approach ; Function to swap two a & b value ; Function to print array element ; Traverse the array ; Function to sort the array in O ( N ) ; Traverse the array ; If the current element is at correct position ; Else swap the current element with it 's correct position ; Driver Code ; Function call to sort the array ; Function call to print the array,"#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } void sortArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { swap ( & arr [ i ] , & arr [ arr [ i ] - 1 ] ) ; } } } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArray ( arr , N ) ; printArray ( arr , N ) ; return 0 ; }",Sort an Array which contain 1 to N values in O ( N ) using Cycle Sort.
117,Maximum sum of values of N items in 0 | C ++ Program to implement the above approach ; Function to find the maximum value ; base condition ; K elements already reduced to half of their weight ; Dont include item ; If weight of the item is less than or equal to the remaining weight then include the item ; Return the maximum of both cases ; If the weight reduction to half is possible ; Skip the item ; Include item with full weight if weight of the item is less than the remaining weight ; Include item with half weight if half weight of the item is less than the remaining weight ; Return the maximum of all 3 cases ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index , int val_len ) { if ( index >= val_len ) { return 0 ; } if ( flag == K ) { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } return max ( full , skip ) ; } else { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; int half = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } if ( weight [ index ] / 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 , val_len ) ; } return max ( full , max ( skip , half ) ) ; } } int main ( ) { int value [ ] = { 17 , 20 , 10 , 15 } ; int weight [ ] = { 4 , 2 , 7 , 5 } ; int K = 1 ; int W = 4 ; int val_len = sizeof ( value ) / sizeof ( value [ 0 ] ) ; cout << ( maximum ( value , weight , W , 0 , K , 0 , val_len ) ) ; return 0 ; }",Maximum sum of values of N items in 0.
118,d | C ++ program to find the size of the minimum dominating set of the tree ; Definition of a tree node ; Helper function that allocates a new node ; DP array to precompute and store the results ; minDominatingSettion to return the size of the minimum dominating set of the array ; Base case ; Setting the compulsory value if needed ; Check if the answer is already computed ; If it is compulsory to select the node ; Choose the node and set its children as covered ; If it is covered ; If the current node is neither covered nor needs to be selected compulsorily ; Store the result ; Driver code ; initialising the DP array ; Constructing the tree,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1005 NEW_LINE struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ( ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int dp [ N ] [ 5 ] [ 5 ] ; int minDominatingSet ( Node * root , int covered , int compulsory ) { if ( ! root ) return 0 ; if ( ! root -> left and ! root -> right and ! covered ) compulsory = true ; if ( dp [ root -> data ] [ covered ] [ compulsory ] != -1 ) return dp [ root -> data ] [ covered ] [ compulsory ] ; if ( compulsory ) { return dp [ root -> data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; } if ( covered ) { return dp [ root -> data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; if ( root -> left ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 1 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } if ( root -> right ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 1 ) ) ; } return dp [ root -> data ] [ covered ] [ compulsory ] = ans ; } signed main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 5 ) ; root -> left -> left -> left -> left = newNode ( 6 ) ; root -> left -> left -> left -> right = newNode ( 7 ) ; root -> left -> left -> left -> right -> right = newNode ( 10 ) ; root -> left -> left -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> left -> left -> right = newNode ( 9 ) ; cout << minDominatingSet ( root , 0 , 0 ) << endl ; return 0 ; }",d.
119,"Number of subsets with zero sum |  ; variable to store states of dp ; To find the number of subsets with sum equal to 0 Since S can be negative , we will maxSum to it to make it positive ; Base cases ; Returns the value if a state is already solved ; If the state is not visited , then continue ; Recurrence relation ; Returning the value ; Driver function","#include <bits/stdc++.h> NEW_LINE #define maxSum  100 NEW_LINE #define arrSize  51 NEW_LINE using namespace std ; int dp [ arrSize ] [ maxSum ] ; bool visit [ arrSize ] [ maxSum ] ; int SubsetCnt ( int i , int s , int arr [ ] , int n ) { if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; } if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ; visit [ i ] [ s + maxSum ] = 1 ; dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + maxSum ] ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , -4 , -4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << SubsetCnt ( 0 , 0 , arr , n ) ; }",Number of subsets with zero sum.
120,"Number of Binary Strings of length N with K adjacent Set Bits | C ++ program to find the number of Bit Strings of length N with K adjacent set bits ; Function to find the number of Bit Strings of length N with K adjacent set bits ; Base Case when we form bit string of length n ; if f ( bit string ) = k , count this way ; Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset ; set the bit at currentIndex ; unset the bit at currentIndex ; Driver Code ; dp [ i ] [ j ] [ k ] represents bit strings of length i with f ( bit string ) = j and last bit as k ; initializer the dp ; total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int waysToKAdjacentSetBits ( int dp [ ] [ MAX ] [ 2 ] , int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } if ( dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] != -1 ) { return dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] = noOfWays ; return noOfWays ; } int main ( ) { int n = 5 , k = 2 ; int dp [ MAX ] [ MAX ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; int totalWays = waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 0 ) ; cout << "" Number ▁ of ▁ ways ▁ = ▁ "" << totalWays << "" STRNEWLINE "" ; return 0 ; }",Number of Binary Strings of length N with K adjacent Set Bits.
121,"Tetranacci Numbers | A space optimized based CPP program to print the nth tetranacci number ; Function to print the N - th tetranacci number ; Initialize first four numbers to base cases ; declare a current variable ; Loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively ; Driver code","#include <iostream> NEW_LINE using namespace std ; void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } cout << curr ; } } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; }",Tetranacci Numbers.
122,"Count ways to reach the nth stair using step 1 , 2 or 3 | A C ++ program to count number of ways to reach n 't stair when ; A recursive function used by countWays ; Driver program to test above functions",#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; },"Count ways to reach the nth stair using step 1 , 2 or 3."
123,"Count ways to reach the nth stair using step 1 , 2 or 3 | A C ++ program to count number of ways to reach nth stair when ; A recursive function used by countWays ; Declaring three variables and holding the ways for first three stairs ; fourth variable ; Starting from 4 as already counted for 3 stairs ; Driver program to test above functions","#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }","Count ways to reach the nth stair using step 1 , 2 or 3."
124,Subset Sum Problem in O ( sum ) space |  ; Initializing with 1 as sum 0 is always possible ; Loop to go through every element of the elements array ; To change the values of all possible sum values to 1 ; If sum is possible then return 1 ; Driver code,"#include <iostream> NEW_LINE using namespace std ; bool isPossible ( int elements [ ] , int sum , int n ) { int dp [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; } int main ( ) { int elements [ ] = { 6 , 2 , 5 } ; int n = sizeof ( elements ) / sizeof ( elements [ 0 ] ) ; int sum = 7 ; if ( isPossible ( elements , sum , n ) ) cout << ( "" YES "" ) ; else cout << ( "" NO "" ) ; return 0 ; }",Subset Sum Problem in O ( sum ) space.
125,"Dynamic Programming | High | A naive recursive C ++ program to find maximum tasks . ; Returns the maximum among the 2 numbers ; Returns maximum amount of task that can be done till day n ; If n is less than equal to 0 , then no solution exists ; Determines which task to choose on day n , then returns the maximum till that day ; Driver code","#include <iostream> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ? x : y ) ; } int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; } int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; cout << maxTasks ( high , low , n ) ; return 0 ; }",Dynamic Programming.
126,"Binomial Coefficient | DP | C ++ program to find gcd of two numbers in O ( log ( min ( a , b ) ) ) ; function to find gcd of two numbers in O ( log ( min ( a , b ) ) ) ; base case ; C ( n , r ) = C ( n , n - r ) ; array of elements from n - r + 1 to n ; for numbers from 1 to r find arr [ j ] , such that gcd ( i , arr [ j ] ) > 1 ; if gcd > 1 , divide both by gcd ; if i becomes 1 , no need to search arr ; single pass to multiply the numerator ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int nCr ( int n , int r ) { if ( r > n ) return 0 ; if ( r > n - r ) r = n - r ; int mod = 1000000007 ; int arr [ r ] ; for ( int i = n - r + 1 ; i <= n ; i ++ ) { arr [ i + r - n - 1 ] = i ; } long int ans = 1 ; for ( int k = 1 ; k < r + 1 ; k ++ ) { int j = 0 , i = k ; while ( j < r ) { int x = gcd ( i , arr [ j ] ) ; if ( x > 1 ) { arr [ j ] /= x ; i /= x ; } if ( i == 1 ) break ; j += 1 ; } } for ( int i : arr ) ans = ( ans * i ) % mod ; return ( int ) ans ; } int main ( ) { int n = 5 , r = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << r << "" ) ▁ is ▁ "" << nCr ( n , r ) << "" STRNEWLINE "" ; return 0 ; }",Binomial Coefficient.
127,Kth character after replacing each character of String by its frequency exactly X times | C ++ program for the above approach ; Function to find the Kth character after X days ; Variable to store the KthChar ; Traverse the string ; Convert char into int ; Calculate characters ; If K is less than sum than ans = str [ i ] ; Return answer ; Driver Code ; Given Input ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; char FindKthChar ( string str , long long K , int X ) { char ans ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = str [ i ] - '0' ; int range = pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; } int main ( ) { string str = ""123"" ; long long K = 9 ; int X = 3 ; char ans = FindKthChar ( str , K , X ) ; cout << ans << "" STRNEWLINE "" ; return 0 ; }",Kth character after replacing each character of String by its frequency exactly X times.
128,"Total character pairs from two strings , with equal number of set bits in their ascii value | C ++ implementation of the approach ; Function to return the count of valid pairs ; Store frequency of number of set bits for s1 ; Store frequency of number of set bits for s2 ; Calculate total pairs ; Return the count of valid pairs ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( string s1 , string s2 ) { int count = 0 ; int arr1 [ 7 ] , arr2 [ 7 ] ; for ( int i = 1 ; i <= 6 ; i ++ ) { arr1 [ i ] = 0 ; arr2 [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s1 [ i ] ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s2 [ i ] ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) count += ( arr1 [ i ] * arr2 [ i ] ) ; return count ; } int main ( ) { string s1 = "" geeks "" ; string s2 = "" forgeeks "" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }","Total character pairs from two strings , with equal number of set bits in their ascii value."
129,"Count substrings that starts with character X and ends with character Y | C ++ implementation to count substrings starting with character X and ending with character Y ; function to count substrings starting with character X and ending with character Y ; to store total count of required substrings ; to store count of character ' x ' up to the point the string ' str ' has been traversed so far ; traverse ' str ' form left to right ; if true , increment ' count _ x ' ; if true accumulate ' count _ x ' to ' tot _ count ' ; required count ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstr ( string str , int n , char x , char y ) { int tot_count = 0 ; int count_x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) count_x ++ ; if ( str [ i ] == y ) tot_count += count_x ; } return tot_count ; } int main ( ) { string str = "" abbcaceghcak "" ; int n = str . size ( ) ; char x = ' a ' , y = ' c ' ; cout << "" Count ▁ = ▁ "" << countSubstr ( str , n , x , y ) ; return 0 ; }",Count substrings that starts with character X and ends with character Y.
130,"Count words in a given string | C ++ program to count no of words from given input string . ; returns number of words in str ; word count ; Scan all characters one by one ; If next character is a separator , set the state as OUT ; If next character is not a word separator and state is OUT , then set the state as IN and increment word count ; Move to next character ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define OUT  0 NEW_LINE #define IN  1 NEW_LINE unsigned countWords ( char * str ) { int state = OUT ; unsigned wc = 0 ; while ( * str ) { if ( * str == ' ▁ ' * str == ' ' * str == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ str ; } return wc ; } int main ( void ) { char str [ ] = "" One ▁ two TABSYMBOL three STRNEWLINE ▁ four TABSYMBOL five ▁ "" ; cout << "" No ▁ of ▁ words ▁ : ▁ "" << countWords ( str ) ; return 0 ; }",Count words in a given string.
131,Enneadecagonal number | C ++ program to find nth Enneadecagonal number ; Function to calculate Enneadecagonal number ; Formula for finding nth Enneadecagonal number ; Drivers code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthEnneadecagonal ( long int n ) { return ( 17 * n * n - 15 * n ) / 2 ; } int main ( ) { long int n = 6 ; cout << n << "" th ▁ Enneadecagonal ▁ number ▁ : "" << nthEnneadecagonal ( n ) ; return 0 ; }",Enneadecagonal number.
132,Area of a Circumscribed Circle of a Square | C ++ Program to find the area of a circumscribed circle ; Utiity function ; Driver code,"#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; } int main ( ) { float a = 6 ; printf ( "" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : ▁ % .2f ▁ "" , areacircumscribed ( a ) ) ; return 0 ; }",Area of a Circumscribed Circle of a Square.
133,Find Nth item distributed from infinite items of infinite types based on given conditions | C ++ program for the above approach ; Function to find the type of the item given out according to the given rules ; Stores the count of item given out at each step ; Iterate to find the Nth day present is given out ; Find the number of presents given on day is day * ( day + 1 ) / 2 ; Iterate over the type ; Return the resultant type ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int itemType ( int n ) { int count = 0 ; int day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; },Find Nth item distributed from infinite items of infinite types based on given conditions.
134,Check if linked list is sorted ( Iterative and Recursive ) | C ++ program to check Linked List is sorted in descending order or not ; Linked list node ; function to Check Linked List is sorted in descending order or not ; Traverse the list till last node and return false if a node is smaller than or equal its next . ; Driver program to test above,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL ) return true ; for ( Node * t = head ; t -> next != NULL ; t = t -> next ) if ( t -> data <= t -> next -> data ) return false ; return true ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Check if linked list is sorted ( Iterative and Recursive ).
135,Maximum length of consecutive 1 s or 0 s after flipping at most K characters | C ++ program for the above approach ; Function to find the maximum length continuos segment of character c after flipping at most K characters ; Stores the maximum length ; Stores the count of char ' c ' ; Start of window ; Remove the extra ' c ' from left ; Increment the value of the left ; Update the resultant maximum length of character ch ; Function to find the maximum length of consecutive 0 s or 1 s by flipping at most K characters of the string ; Print the maximum of the maximum length of 0 s or 1 s ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( string str , int n , char c , int k ) { int ans = -1 ; int cnt = 0 ; int left = 0 ; for ( int right = 0 ; right < n ; right ++ ) { if ( str [ right ] == c ) { cnt ++ ; } while ( cnt > k ) { if ( str [ left ] == c ) { cnt -- ; } left ++ ; } ans = max ( ans , right - left + 1 ) ; } return ans ; } int maxConsecutiveSegment ( string S , int K ) { int N = S . length ( ) ; return max ( maxLength ( S , N , '0' , K ) , maxLength ( S , N , '1' , K ) ) ; } int main ( ) { string S = ""1001"" ; int K = 1 ; cout << maxConsecutiveSegment ( S , K ) ; return 0 ; }",Maximum length of consecutive 1 s or 0 s after flipping at most K characters.
136,"Minimize coins required to obtain all possible values up to N | Function to find minimum count of { 1 , 2 , 5 } valued coins required to make a change of all values in the range [ 1 , N ] ; Number of 5 valueds coins required ; Number of 1 valued coins required ; Number of 2 valued coins required ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void find ( int N ) { int T , F , O ; F = int ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = floor ( ( N - 5 * F - O ) / 2 ) ; cout << "" Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ "" << F << endl ; cout << "" Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ "" << T << endl ; cout << "" Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ "" << O << endl ; } int main ( ) { int N = 8 ; find ( N ) ; return 0 ; }",Minimize coins required to obtain all possible values up to N.
137,"Replace ' ? ' to convert given string to a binary string with maximum count of '0' and ""10"" | C ++ program to implement the above approach ; Function to maximize count of 0 and 10 by replacing character ' ? ' to '0' or '1' ; Traverse the given string ; If current character is ' ? ' ; Replace str [ i ] to '0' ; Driver Code ; Given string","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxOccurence ( string str , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ? ' ) { str [ i ] = '0' ; } } cout << str << endl ; } int main ( ) { string str = ""10?0?11"" ; int N = str . length ( ) ; findMaxOccurence ( str , N ) ; return 0 ; }","Replace ' ? ' to convert given string to a binary string with maximum count of '0' and ""10""."
138,Check if given string is a substring of string formed by repeated concatenation of z to a | C ++ program for the above approach ; Function checks if a given string is valid or not and prints the output ; Boolean flag variable to mark if given string is valid ; Traverse the given string ; If adjacent character differ by 1 ; If character ' a ' is followed by 4 ; Else flip the flag and break from the loop ; Output according to flag variable ; Driver Code ; Given string ; Function Call,"#include <iostream> NEW_LINE using namespace std ; void checkInfinite ( string s ) { bool flag = 1 ; int N = s . length ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( s [ i ] == char ( int ( s [ i + 1 ] ) + 1 ) ) { continue ; } else if ( s [ i ] == ' a ' && s [ i + 1 ] == ' z ' ) { continue ; } else { flag = 0 ; break ; } } if ( flag == 0 ) cout << "" NO "" ; else cout << "" YES "" ; } int main ( ) { string s = "" ecbaz "" ; checkInfinite ( s ) ; return 0 ; }",Check if given string is a substring of string formed by repeated concatenation of z to a.
139,"Minimum change in lanes required to cross all barriers | C ++ program for the above approach ; Function to find the minimum number of changes of lane required ; If there is a barrier , then add very large value ; Add the minimum value to move forword with or without crossing barrier ; Return the minimum value of dp [ 0 ] , dp [ 1 ] and dp [ 2 ] ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) ; } int main ( ) { int barrier [ ] = { 0 , 1 , 2 , 3 , 0 } ; int N = sizeof ( barrier ) / sizeof ( barrier [ 0 ] ) ; cout << minChangeInLane ( barrier , N ) ; return 0 ; }",Minimum change in lanes required to cross all barriers.
140,Queries to count groups of N students possible having sum of ratings within given range | C ++ program for the above approach ; Function to count number of ways to get given sum groups ; Initialise dp array ; Mark all 1 st row values as 1 since the mat [ 0 ] [ i ] is all possible sums in first row ; Fix the ith row ; Fix the sum ; Iterate through all values of ith row ; If sum can be obtained ; Find the prefix sum of last row ; Traverse each query ; No of ways to form groups ; Driver Code ; Given n batches and k students ; Given ratings ; Given Queries ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void numWays ( int ratings [ n ] [ k ] , int queries [ ] [ 2 ] ) { int dp [ n ] [ 10000 + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int sum = 0 ; sum <= 10000 ; sum ++ ) { for ( int j = 0 ; j < k ; j ++ ) { if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } } for ( int sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; } for ( int q = 0 ; q < 2 ; q ++ ) { int a = queries [ q ] [ 0 ] ; int b = queries [ q ] [ 1 ] ; cout << dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] << "" ▁ "" ; } } int main ( ) { #define n  2 NEW_LINE #define k  3 NEW_LINE int ratings [ n ] [ k ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; int queries [ ] [ 2 ] = { { 6 , 6 } , { 1 , 6 } } ; numWays ( ratings , queries ) ; return 0 ; }",Queries to count groups of N students possible having sum of ratings within given range.
141,Number of permutation with K inversions | Set 2 | C ++ program for the above approach ; Function to count permutations with K inversions ; Store number of permutations with K inversions ; If N = 1 only 1 permutation with no inversion ; For K = 0 only 1 permutation with no inversion ; Otherwise Update each dp state as per the reccurrance relation formed ; Print final count ; Driver Code ; Given N and K ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfPermWithKInversion ( int N , int K ) { int dp [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) dp [ i % 2 ] [ j ] = ( j == 0 ) ; else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; ; } } cout << dp [ N % 2 ] [ K ] ; } int main ( ) { int N = 3 , K = 2 ; numberOfPermWithKInversion ( N , K ) ; return 0 ; }",Number of permutation with K inversions.
142,"Maximum sum path in a Matrix | No of rows and columns ; Declaring the matrix of maximum 100 rows and 100 columns ; Variable visited is used to keep track of all the visited positions Variable dp is used to store maximum sum till current position ; For storing current sum ; For continuous update of maximum sum required ; Function to Input the matrix of size n * m ; Function to calculate maximum sum of path ; Checking boundary condition ; Checking whether or not ( i , j ) is visited ; Marking ( i , j ) is visited ; Checking whether the position hasn 't  visited the last row or the last column.  Making recursive call for all the possible  moves from the current cell and then adding the  maximum returned by the calls and updating it. ; Checking whether position has reached last row ; If the position is in the last column ; Returning the updated maximum value ; Driver Code ; Calling the implemented function","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE int n , m ; int a [ N ] [ N ] ; vector < vector < int > > dp ( N , vector < int > ( N ) ) , visited ( N , vector < int > ( N ) ) ; int current_sum = 0 ; int total_sum = 0 ; void inputMatrix ( ) { n = 3 ; m = 3 ; a [ 0 ] [ 0 ] = 500 ; a [ 0 ] [ 1 ] = 100 ; a [ 0 ] [ 2 ] = 230 ; a [ 1 ] [ 0 ] = 1000 ; a [ 1 ] [ 1 ] = 300 ; a [ 1 ] [ 2 ] = 100 ; a [ 2 ] [ 0 ] = 200 ; a [ 2 ] [ 1 ] = 1000 ; a [ 2 ] [ 2 ] = 200 ; } int maximum_sum_path ( int i , int j ) { if ( i == n - 1 && j == m - 1 ) return a [ i ] [ j ] ; if ( visited [ i ] [ j ] ) return dp [ i ] [ j ] ; visited [ i ] [ j ] = 1 ; int & total_sum = dp [ i ] [ j ] ; if ( i < n - 1 & j < m - 1 ) { int current_sum = max ( maximum_sum_path ( i , j + 1 ) , max ( maximum_sum_path ( i + 1 , j + 1 ) , maximum_sum_path ( i + 1 , j ) ) ) ; total_sum = a [ i ] [ j ] + current_sum ; } else if ( i == n - 1 ) total_sum = a [ i ] [ j ] + maximum_sum_path ( i , j + 1 ) ; else total_sum = a [ i ] [ j ] + maximum_sum_path ( i + 1 , j ) ; return dp [ i ] [ j ] = total_sum ; } int main ( ) { inputMatrix ( ) ; int maximum_sum = maximum_sum_path ( 0 , 0 ) ; cout << maximum_sum ; return 0 ; }",Maximum sum path in a Matrix.
143,Treasure and Cities | k is current index and col is previous color . ; base case ; check if color of this city is equal to prev visited city ; return max of both options ; Driver code ; Initially begin with color 0,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }",Treasure and Cities.
144,Tetranacci Numbers | A simple recursive CPP program to print the nth tetranacci numbers . ; Function to return the N - th tetranacci number ; base cases ; base cases ; base cases ; function to print the nth tetranacci number ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int printTetraRec ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; } void printTetra ( int n ) { cout << printTetraRec ( n ) << "" ▁ "" ; } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; }",Tetranacci Numbers.
145,Sum of products of all combination taken ( 1 to n ) at a time | Program to find SOP of all combination taken ( 1 to N ) at a time using brute force ; to store sum of every combination ; if we have reached sufficient depth ; find the product of combination ; add the product into sum ; recursion to produce different combination ; function to print sum of products of all combination taken 1 - N at a time ; creating temporary array for storing combination ; call combination with r = i for combination taken i at a time ; displaying sum ; Driver 's code ; storing numbers from 1 - N in array ; calling allCombination,"#include <iostream> NEW_LINE using namespace std ; int sum = 0 ; void Combination ( int a [ ] , int combi [ ] , int n , int r , int depth , int index ) { if ( index == r ) { int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } } void allCombination ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int * combi = new int [ i ] ; Combination ( a , combi , n , i , 0 , 0 ) ; cout << "" f ( "" << i << "" ) ▁ - - > ▁ "" << sum << "" STRNEWLINE "" ; sum = 0 ; free ( combi ) ; } } int main ( ) { int n = 5 ; int * a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; allCombination ( a , n ) ; return 0 ; }",Sum of products of all combination taken ( 1 to n ) at a time.
146,"Dynamic Programming | High | A DP based C ++ program to find maximum tasks . ; Returns the maximum among the 2 numbers ; Returns maximum amount of task that can be done till day n ; An array task_dp that stores the maximum task done ; If n = 0 , no solution exists ; If n = 1 , high effort task on that day will be the solution ; Fill the entire array determining which task to choose on day i ; Driver program to test above function","#include <iostream> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ? x : y ) ; } int maxTasks ( int high [ ] , int low [ ] , int n ) { int task_dp [ n + 1 ] ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; } int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; cout << maxTasks ( high , low , n ) ; return 0 ; }",Dynamic Programming.
147,Permutation Coefficient | A O ( n ) time and O ( 1 ) extra space solution to calculate the Permutation Coefficient ; Compute n * ( n - 1 ) * ( n - 2 ) . ... ( n - k + 1 ) ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int PermutationCoeff ( int n , int k ) { int P = 1 ; for ( int i = 0 ; i < k ; i ++ ) P *= ( n - i ) ; return P ; } int main ( ) { int n = 10 , k = 2 ; cout << "" Value ▁ of ▁ P ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << PermutationCoeff ( n , k ) ; return 0 ; }",Permutation Coefficient.
148,"Partition problem | DP | A Dynamic Programming based C ++ program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; initialize top row as true ; initialize leftmost column , except part [ 0 ] [ 0 ] , as 0 ; Fill the partition table in bottom up manner ; uncomment this part to print table ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] [ n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ sum / 2 ] [ n ] ; } int main ( ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }",Partition problem.
149,Minimum number of Appends of X or Y characters from the end to the front required to obtain given string | C ++ program for the above approach ; Function to find the minimum operations required to get the given string after appending m or n characters from the end to the front of the string in each operation ; Store the original string ; Stores the count of operations ; Traverse the string ; Cut m letters from end ; Add cut m letters to beginning ; Update j ; Check if strings are the same ; Cut n letters from end ; Add cut n letters to beginning ; Update j ; Check if strings are the same ; Update the turn ; Driver Code ; Given string S ; Function Call,"#include <iostream> NEW_LINE using namespace std ; int minimumOperations ( string orig_str , int m , int n ) { string orig = orig_str ; int turn = 1 ; int j = 1 ; for ( auto i : orig_str ) { string m_cut = orig_str . substr ( orig_str . length ( ) - m ) ; orig_str . erase ( orig_str . length ( ) - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( orig != orig_str ) { turn = turn + 1 ; string n_cut = orig_str . substr ( orig_str . length ( ) - n ) ; orig_str . erase ( orig_str . length ( ) - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig == orig_str ) { break ; } turn = turn + 1 ; } cout << turn ; } int main ( ) { string S = "" GeeksforGeeks "" ; int X = 5 , Y = 3 ; minimumOperations ( S , X , Y ) ; return 0 ; }",Minimum number of Appends of X or Y characters from the end to the front required to obtain given string.
150,"Minimum rotations required to get the same String | Set | C ++ implementation of the above approach ; Prints occurrences of txt [ ] in pat [ ] ; Create lps [ ] that will hold the longest prefix suffix values for pattern ; Preprocess the pattern ( calculate lps [ ] array ) ; Index for txt [ ] , index for pat [ ] ; Mismatch after j matches ; Do not match lps [ 0. . lps [ j - 1 ] ] characters , they will match anyway ; Fills lps [ ] for given pattern pat [ 0. . M - 1 ] ; Length of the previous longest prefix suffix ; lps [ 0 ] is always 0 ; The loop calculates lps [ i ] for i = 1 to M - 1 ; ( pat [ i ] != pat [ len ] ) ; This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step . ; Returns count of rotations to get the same string back ; Form a string excluding the first character and concatenating the string at the end ; Convert the string to character array ; Use the KMP search algorithm to find it in O ( N ) time ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void computeLPSArray ( char * pat , int M , int * lps ) ; int KMPSearch ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int lps [ M ] ; computeLPSArray ( pat , M , lps ) ; int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; j = lps [ j - 1 ] ; } else if ( i < N && pat [ j ] != txt [ i ] ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } } void computeLPSArray ( char * pat , int M , int * lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } } int countRotations ( string s ) { string s1 = s . substr ( 1 , s . size ( ) - 1 ) + s ; char pat [ s . length ( ) ] , text [ s1 . length ( ) ] ; strcpy ( pat , s . c_str ( ) ) ; strcpy ( text , s1 . c_str ( ) ) ; return 1 + KMPSearch ( pat , text ) ; } int main ( ) { string s1 = "" geeks "" ; cout << countRotations ( s1 ) ; return 0 ; }",Minimum rotations required to get the same String.
151,"DFA for Strings not ending with "" THE "" | C ++ program to implement DFS that accepts all string that do not end with "" THE "" ; dfa tells the number associated with the present state ; This function is for the starting state ( zeroth ) of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; This function is for the first state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; On receiving ' H ' or ' h ' goto second state ( 2 ) ; Else goto starting state ( 0 ) ; This function is for the second state of DFA ; On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 ) ; This function is for the third state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 ) ; Store length of string ; Driver code","#include <iostream> NEW_LINE using namespace std ; int dfa = 0 ; void start ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; } void state1 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else if ( c == ' h ' c == ' H ' ) dfa = 2 ; else dfa = 0 ; } void state2 ( char c ) { if ( c == ' e ' c == ' E ' ) dfa = 3 ; else if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } void state3 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } bool isAccepted ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; } int main ( ) { string str = "" forTHEgeeks "" ; if ( isAccepted ( str ) == true ) cout << "" ACCEPTED STRNEWLINE "" ; else cout << "" NOT ▁ ACCEPTED STRNEWLINE "" ; return 0 ; }","DFA for Strings not ending with "" THE ""."
152,"Check if one string can be converted to another | C ++ implementation of the above approach . ; Function for find from Disjoint set algorithm ; Function for the union from Disjoint set algorithm ; Function to check if one string can be converted to another . ; All the characters are checked whether it 's either not replaced or replaced  by a similar character using a map. ; To check if there are cycles . If yes , then they are not convertible . Else , they are convertible . ; Function to initialize parent array for union and find algorithm . ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int parent [ 26 ] ; int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; } void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } } bool convertible ( string s1 , string s2 ) { map < int , int > mp ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( mp . find ( s1 [ i ] - ' a ' ) == mp . end ( ) ) { mp [ s1 [ i ] - ' a ' ] = s2 [ i ] - ' a ' ; } else { if ( mp [ s1 [ i ] - ' a ' ] != s2 [ i ] - ' a ' ) return false ; } } for ( auto it : mp ) { if ( it . first == it . second ) continue ; else { if ( find ( it . first ) == find ( it . second ) ) return false ; else join ( it . first , it . second ) ; } } return true ; } void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } } int main ( ) { string s1 , s2 ; s1 = "" abbcaa "" ; s2 = "" bccdbb "" ; initialize ( ) ; if ( convertible ( s1 , s2 ) ) cout << "" Yes "" << endl ; else cout << "" No "" << endl ; return 0 ; }",Check if one string can be converted to another.
153,"Print characters having prime frequencies in order of occurrence | C ++ implementation of the approach ; Function to create Sieve to check primes ; false here indicates that it is not prime ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to print the prime frequency characters in the order of their occurrence ; Function to create Sieve to check primes ; To store the frequency of each of the character of the string ; Initialize all elements of freq [ ] to 0 ; Update the frequency of each character ; Traverse str character by character ; If frequency of current character is prime ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } void printChar ( string str , int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , str . length ( ) + 1 ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ freq [ str [ i ] - ' a ' ] ] ) { cout << str [ i ] ; } } } int main ( ) { string str = "" geeksforgeeks "" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }",Print characters having prime frequencies in order of occurrence.
154,Print characters having even frequencies in order of occurrence | C ++ implementation of the approach ; Function to print the even frequency characters in the order of their occurrence ; To store the frequency of each of the character of the string ; Initialize all elements of freq [ ] to 0 ; Update the frequency of each character ; Traverse str character by character ; If frequency of current character is even ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { cout << str [ i ] ; } } } int main ( ) { string str = "" geeksforgeeks "" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }",Print characters having even frequencies in order of occurrence.
155,"Compare two strings considering only alphanumeric characters | Function to check alphanumeric equality of both strings ; variable declaration ; Length of first string ; Length of second string ; To check each and every characters of both string ; If the current character of the first string is not an alphanumeric character , increase the pointer i ; If the current character of the second string is not an alphanumeric character , increase the pointer j ; if all alphanumeric characters of both strings are same then return true ; if any alphanumeric characters of both strings are not same then return false ; If current character matched , increase both pointers to check the next character ; If not same , then return false ; Function to print Equal or Unequal if strings are same or not ; check alphanumeric equality of both strings ; if both are alphanumeric equal , print Equal ; otherwise print Unequal ; Driver code","#include <iostream> NEW_LINE using namespace std ; bool CompareAlphanumeric ( string & str1 , string & str2 ) { int i , j ; i = 0 ; j = 0 ; int len1 = str1 . size ( ) ; int len2 = str2 . size ( ) ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] >= ' a ' && str2 [ j ] <= ' z ' ) || ( str2 [ j ] >= ' A ' && str2 [ j ] <= ' Z ' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) return true ; else if ( str1 [ i ] != str2 [ j ] ) return false ; else { i ++ ; j ++ ; } } return false ; } void CompareAlphanumericUtil ( string str1 , string str2 ) { bool res ; res = CompareAlphanumeric ( str1 , str2 ) ; if ( res == true ) cout << "" Equal "" << endl ; else cout << "" Unequal "" << endl ; } int main ( ) { string str1 , str2 ; str1 = "" Ram , ▁ Shyam "" ; str2 = "" ▁ Ram ▁ - ▁ Shyam . "" ; CompareAlphanumericUtil ( str1 , str2 ) ; str1 = "" abc123"" ; str2 = ""123abc "" ; CompareAlphanumericUtil ( str1 , str2 ) ; return 0 ; }",Compare two strings considering only alphanumeric characters.
156,Queries to print the character that occurs the maximum number of times in a given range | C ++ program to find the sum of the addition of all possible subsets . ; Function that answers all the queries ; Length of the string ; Number of queries ; Prefix array ; Iterate for all the characters ; Increase the count of the character ; Presum array for all 26 characters ; Update the prefix array ; Answer every query ; Range ; Iterate for all characters ; Times the lowercase character j occurs till r - th index ; Subtract the times it occurred till ( l - 1 ) th index ; Max times it occurs ; Print the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void solveQueries ( string str , vector < vector < int > > & query ) { int len = str . size ( ) ; int Q = query . size ( ) ; int pre [ len ] [ 26 ] ; memset ( pre , 0 , sizeof pre ) ; for ( int i = 0 ; i < len ; i ++ ) { pre [ i ] [ str [ i ] - ' a ' ] ++ ; if ( i ) { for ( int j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } } for ( int i = 0 ; i < Q ; i ++ ) { int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int maxi = 0 ; char c = ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { int times = pre [ r ] [ j ] ; if ( l ) times -= pre [ l - 1 ] [ j ] ; if ( times > maxi ) { maxi = times ; c = char ( ' a ' + j ) ; } } cout << "" Query ▁ "" << i + 1 << "" : ▁ "" << c << endl ; } } int main ( ) { string str = "" striver "" ; vector < vector < int > > query ; query . push_back ( { 0 , 1 } ) ; query . push_back ( { 1 , 6 } ) ; query . push_back ( { 5 , 6 } ) ; solveQueries ( str , query ) ; }",Queries to print the character that occurs the maximum number of times in a given range.
157,Check whether given string can be generated after concatenating given strings | C ++ implementation of the approach ; Function that return true if pre is a prefix of str ; While there are characters to match ; If characters differ at any position ; str starts with pre ; Function that return true if suff is a suffix of str ; While there are characters to match ; If characters differ at any position ; str ends with suff ; Function that returns true if str = a + b or str = b + a ; str cannot be generated by concatenating a and b ; If str starts with a i . e . a is a prefix of str ; Check if the rest of the characters are equal to b i . e . b is a suffix of str ; If str starts with b i . e . b is a prefix of str ; Check if the rest of the characters are equal to a i . e . a is a suffix of str ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool startsWith ( string str , string pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 , j = 0 ; while ( i < strLen && j < preLen ) { if ( str [ i ] != pre [ j ] ) return false ; i ++ ; j ++ ; } return true ; } bool endsWith ( string str , string suff ) { int i = str . length ( ) - 0 ; int j = suff . length ( ) - 0 ; while ( i >= 0 && j >= 0 ) { if ( str [ i ] != suff [ j ] ) return false ; i -- ; j -- ; } return true ; } bool checkString ( string str , string a , string b ) { if ( str . length ( ) != a . length ( ) + b . length ( ) ) return false ; if ( startsWith ( str , a ) ) { if ( endsWith ( str , b ) ) return true ; } if ( startsWith ( str , b ) ) { if ( endsWith ( str , a ) ) return true ; } return false ; } int main ( ) { string str = "" GeeksforGeeks "" ; string a = "" Geeksfo "" ; string b = "" rGeeks "" ; if ( checkString ( str , a , b ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check whether given string can be generated after concatenating given strings.
158,Print characters having odd frequencies in order of occurrence | C ++ implementation of the approach ; Function to print the odd frequency characters in the order of their occurrence ; To store the frequency of each of the character of the string ; Initialize all elements of freq [ ] to 0 ; Update the frequency of each character ; Traverse str character by character ; If frequency of current character is odd ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { cout << str [ i ] ; } } } int main ( ) { string str = "" geeksforgeeks "" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }",Print characters having odd frequencies in order of occurrence.
159,Minimum number of operations to move all uppercase characters before all lower case characters | C ++ implementation of the approach ; Function to return the minimum number of operations required ; To store the indices of the last uppercase and the first lowercase character ; Find the last uppercase character ; Find the first lowercase character ; If all the characters are either uppercase or lowercase ; Count of uppercase characters that appear after the first lowercase character ; Count of lowercase characters that appear before the last uppercase character ; Return the minimum operations required ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string str , int n ) { int i , lastUpper = -1 , firstLower = -1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == -1 firstLower == -1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return min ( countLower , countUpper ) ; } int main ( ) { string str = "" geEksFOrGEekS "" ; int n = str . length ( ) ; cout << minOperations ( str , n ) << endl ; }",Minimum number of operations to move all uppercase characters before all lower case characters.
160,Find the sum of all Betrothed numbers up to N | C ++ program to find the sum of the all betrothed numbers up to N ; Function to find the sum of the all betrothed numbers ; To store the betrothed numbers ; Calculate sum of number_1 's divisors  1 is always a divisor ; i = 2 because we don 't  want to include  1 as a divisor. ; Sum all betrothed numbers up to N ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int Betrothed_Sum ( int n ) { vector < int > Set ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 and number_1 <= n && number_2 <= n ) { Set . push_back ( number_1 ) ; Set . push_back ( number_2 ) ; } } } int Summ = 0 ; for ( auto i : Set ) { if ( i <= n ) Summ += i ; } return Summ ; } int main ( ) { int n = 78 ; cout << Betrothed_Sum ( n ) ; return 0 ; },Find the sum of all Betrothed numbers up to N.
161,Probability of rain on N + 1 th day | C ++ code to find the probability of rain on n + 1 - th day when previous day 's data is given ; Function to find the probability ; count 1 ; find probability ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; } int main ( ) { int a [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << rainDayProbability ( a , n ) ; return 0 ; }",Probability of rain on N + 1 th day.
162,Program to find the sum of a Series 1 + 1 / 2 ^ 2 + 1 / 3 ^ 3 + â €¦ . . + 1 / n ^ n | C ++ program to calculate the following series ; Function to calculate the following series ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; } int main ( ) { int n = 3 ; double res = Series ( n ) ; cout << res ; return 0 ; }",Program to find the sum of a Series 1 + 1 / 2 ^ 2 + 1 / 3 ^ 3 + â €¦ . . + 1 / n ^ n.
163,"Lexicographically largest string formed in minimum moves by replacing characters of given String | C ++ program for the above approach ; Function to print the lexicographically the largest string obtained in process of obtaining a string containing first N lower case english alphabtes ; Store the frequency of each character ; Traverse the string S ; Stores the characters which are not appearing in S ; Stores the index of the largest character in the array V , that need to be replaced ; Traverse the string , S ; If frequency of S [ i ] is greater than 1 or it is outside the range ; Decrement its frequency by 1 ; Update S [ i ] ; Decrement j by 1 ; Traverse the string , S ; Decrement its frequency by 1 ; Update S [ i ] ; increment l by 1 ; Return S ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; string lexicographicallyMaximum ( string S , int N ) { unordered_map < char , int > M ; for ( int i = 0 ; i < N ; ++ i ) { M [ S [ i ] ] ++ ; } vector < char > V ; for ( char i = ' a ' ; i < ( char ) ( ' a ' + min ( N , 25 ) ) ; ++ i ) { if ( M [ i ] == 0 ) { V . push_back ( i ) ; } } int j = V . size ( ) - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { if ( V [ j ] < S [ i ] ) continue ; M [ S [ i ] ] -- ; S [ i ] = V [ j ] ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { M [ S [ i ] ] -- ; S [ i ] = V [ l ] ; l ++ ; } } return S ; } int main ( ) { string S = "" abccefghh "" ; int N = S . length ( ) ; cout << lexicographicallyMaximum ( S , N ) ; return 0 ; }",Lexicographically largest string formed in minimum moves by replacing characters of given String.
164,Check if any subarray can be made palindromic by replacing less than half of its elements | C ++ program for the above approach ; A Utility Function to check if a subarray can be palindromic by replacing less than half of the elements present in it ; Stores frequency of array elements ; Traverse the array ; Update frequency of each array element ; Iterator over the Map ; If frequency of any element exceeds 1 ; If no repetition is found ; Function to check and print if any subarray can be made palindromic by replacing less than half of its elements ; Driver Code ; Given array arr [ ] ; Size of array ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isConsistingSubarrayUtil ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } map < int , int > :: iterator it ; for ( it = mp . begin ( ) ; it != mp . end ( ) ; ++ it ) { if ( it -> second > 1 ) { return true ; } } return false ; } void isConsistingSubarray ( int arr [ ] , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isConsistingSubarray ( arr , N ) ; return 0 ; }",Check if any subarray can be made palindromic by replacing less than half of its elements.
165,Count composite fibonacci numbers from given array | C ++ program to implement the above approach ; Function to find all Fibonacci numbers up to Max ; Store all Fibonacci numbers upto Max ; Stores previous element of Fibonacci sequence ; Stores previous element of Fibonacci sequence ; Insert prev into hashmap ; Insert all the Fibonacci numbers up to Max ; Insert curr into hashmap ; Stores curr into temp ; Update curr ; Update prev ; Function to find all Composite numbers up to Max ; isPrime [ i ] : Stores if i is a prime number or not ; Calculate all prime numbers up to Max using Sieve of Eratosthenes ; If P is a prime number ; Set all multiple of P as non - prime ; Update isPrime ; Function to find the numbers which is both a composite and Fibonacci number ; Stores the largest element of the array ; Traverse the array arr [ ] ; Update Max ; isPrim [ i ] check i is a prime number or not ; Stores all the Fibonacci numbers ; Traverse the array arr [ ] ; current element is not a composite number ; If current element is a Fibonacci and composite number ; Print current element ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; set < int > createhashmap ( int Max ) { set < int > hashmap ; int curr = 1 ; int prev = 0 ; hashmap . insert ( prev ) ; while ( curr <= Max ) { hashmap . insert ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; } vector < bool > SieveOfEratosthenes ( int Max ) { vector < bool > isPrime ( Max , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; } int cntFibonacciPrime ( int arr [ ] , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = max ( Max , arr [ i ] ) ; } vector < bool > isPrime = SieveOfEratosthenes ( Max ) ; set < int > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . count ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { cout << arr [ i ] << "" ▁ "" ; } } } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cntFibonacciPrime ( arr , N ) ; return 0 ; }",Count composite fibonacci numbers from given array.
166,Reduce a given number to form a key by the given operations | C ++ program of the above approach ; Function to find the key of the given number ; Convert the integer to String ; Iterate the num - string to get the result ; Check if digit is even or odd ; Iterate until odd sum is obtained by adding consecutive digits ; Check if sum becomes odd ; Add the result in ans ; Assign the digit index to num string ; If the number is odd ; Iterate until odd sum is obtained by adding consecutive digits ; Check if sum becomes even ; Add the result in ans ; assign the digit index to main numstring ; Check if all digits are visited or not ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int key ( int N ) { string num = "" "" + to_string ( N ) ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . length ( ) ; j ++ ) { if ( ( num [ j ] - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num [ num . length ( ) - 1 ] - 48 ; } } int main ( ) { int N = 1667848271 ; cout << key ( N ) ; return 0 ; }",Reduce a given number to form a key by the given operations.
167,Sentinel Linear Search | C ++ implementation of the approach ; Function to search x in the given array ; Last element of the array ; Element to be searched is placed at the last index ; Put the last element back ; Driver code,"#include <iostream> NEW_LINE using namespace std ; void sentinelSearch ( int arr [ ] , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) cout << key << "" ▁ is ▁ present ▁ at ▁ index ▁ "" << i ; else cout << "" Element ▁ Not ▁ found "" ; } int main ( ) { int arr [ ] = { 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 180 ; sentinelSearch ( arr , n , key ) ; return 0 ; }",Sentinel Linear Search.
168,Maximum possible middle element of the array after deleting exactly k elements | C ++ implementation of the approach ; Function to calculate maximum possible middle value of the array after deleting exactly k elements ; Initialize answer as - 1 ; Calculate range of elements that can give maximum possible middle value of the array since index of maximum possible middle value after deleting exactly k elements from array will lie in between low and high ; Find maximum element of the array in range low and high ; since indexing is 1 based so check element at index i - 1 ; Return the maximum possible middle value of the array after deleting exactly k elements from the array ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = -1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = max ( ans , arr [ i - 1 ] ) ; } return ans ; } int main ( ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; cout << maximum_middle_value ( n , k , arr ) << endl ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; cout << maximum_middle_value ( n , k , arr1 ) << endl ; return 0 ; }",Maximum possible middle element of the array after deleting exactly k elements.
169,"Ternary Search | C ++ program to illustrate recursive approach to ternary search ; Function to perform Ternary Search ; Find the mid1 and mid2 ; Check if key is present at any mid ; Since key is not present at mid , check in which region it is present then repeat the Search operation in that region ; The key lies in between l and mid1 ; The key lies in between mid2 and r ; The key lies in between mid1 and mid2 ; Key not found ; Driver code ; Get the array Sort the array if not sorted ; Starting index ; length of array ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result","#include <bits/stdc++.h> NEW_LINE using namespace std ; int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return -1 ; } int main ( ) { int l , r , p , key ; int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; cout << "" Index ▁ of ▁ "" << key << "" ▁ is ▁ "" << p << endl ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; cout << "" Index ▁ of ▁ "" << key << "" ▁ is ▁ "" << p << endl ; }",Ternary Search.
170,Minimum number of points to be removed to get remaining points on one side of axis | CPP program to find minimum points to be moved so that all points are on same side . ; Structure to store the coordinates of a point . ; Function to find the minimum number of points ; Number of points on the left of Y - axis . ; Number of points on the right of Y - axis . ; Number of points above X - axis . ; Number of points below X - axis . ; Driver Function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; struct Point { int x , y ; } ; int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return min ( { a , b , c , d } ) ; } int main ( ) { Point p [ ] = { { 1 , 1 } , { 2 , 2 } , { -1 , -1 } , { -2 , 2 } } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << findmin ( p , n ) ; return 0 ; }",Minimum number of points to be removed to get remaining points on one side of axis.
171,Maximum number of pair reductions possible on a given triplet | C ++ program for the above approach ; Function to count the maximum number of pair reductions possible on a given triplet ; Convert them into an array ; Stores count of operations ; Sort the array ; If the first two array elements reduce to 0 ; Apply the operations ; Increment count ; Print the maximum count ; Driver Code ; Given triplet,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxOps ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; int count = 0 ; while ( 1 ) { sort ( arr , arr + 3 ) ; if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } cout << count ; } int main ( ) { int a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ; return 0 ; }",Maximum number of pair reductions possible on a given triplet.
172,Case | C ++ implementation of the approach ; Function to return the sorted string ; To store the frequencies of the lowercase and the uppercase characters in the given string ; If current character is lowercase then increment its frequency in the lower [ ] array ; Else increment in the upper [ ] array ; Pointers that point to the smallest lowercase and the smallest uppercase characters respectively in the given string ; For every character in the given string ; If the current character is lowercase then replace it with the smallest lowercase character available ; Decrement the frequency of the used character ; Else replace it with the smallest uppercase character available ; Decrement the frequency of the used character ; Return the sorted string ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE string getSortedString ( string s , int n ) { int lower [ MAX ] = { 0 } ; int upper [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( islower ( s [ i ] ) ) lower [ s [ i ] - ' a ' ] ++ ; else if ( isupper ( s [ i ] ) ) upper [ s [ i ] - ' A ' ] ++ ; } int i = 0 , j = 0 ; while ( i < MAX && lower [ i ] == 0 ) i ++ ; while ( j < MAX && upper [ j ] == 0 ) j ++ ; for ( int k = 0 ; k < n ; k ++ ) { if ( islower ( s [ k ] ) ) { while ( lower [ i ] == 0 ) i ++ ; s [ k ] = ( char ) ( i + ' a ' ) ; lower [ i ] -- ; } else if ( isupper ( s [ k ] ) ) { while ( upper [ j ] == 0 ) j ++ ; s [ k ] = ( char ) ( j + ' A ' ) ; upper [ j ] -- ; } } return s ; } int main ( ) { string s = "" gEeksfOrgEEkS "" ; int n = s . length ( ) ; cout << getSortedString ( s , n ) ; return 0 ; }",Case.
173,Print characters and their frequencies in order of occurrence | C ++ implementation to print the character and its frequency in order of its occurrence ; function to print the character and its frequency in order of its occurrence ; size of the string ' str ' ; ' freq [ ] ' implemented as hash table ; initialize all elements of freq [ ] to 0 ; accumulate frequency of each character in ' str ' ; traverse ' str ' from left to right ; if frequency of character str [ i ] is not equal to 0 ; print the character along with its frequency ; update frequency of str [ i ] to 0 so that the same character is not printed again ; Driver program to test above,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printCharWithFreq ( string str ) { int n = str . size ( ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { cout << str [ i ] << freq [ str [ i ] - ' a ' ] << "" ▁ "" ; freq [ str [ i ] - ' a ' ] = 0 ; } } } int main ( ) { string str = "" geeksforgeeks "" ; printCharWithFreq ( str ) ; return 0 ; }",Print characters and their frequencies in order of occurrence.
174,Reverse words in a given string | C ++ program to reverse a string s = input ( ),"#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { string s [ ] = { "" i "" , "" like "" , "" this "" , "" program "" , "" very "" , "" much "" } ; string ans = "" "" ; for ( int i = 5 ; i >= 0 ; i -- ) { ans += s [ i ] + "" ▁ "" ; } cout << ( "" Reversed ▁ String : "" ) << endl ; cout << ( ans . substr ( 0 , ans . length ( ) - 1 ) ) << endl ; return 0 ; }",Reverse words in a given string.
175,"Segregate Prime and Non | C ++ program for the above approach ; Function to generate prime numbers using Sieve of Eratosthenes ; If prime [ p ] is unchanged , then it is a prime ; Update all multiples of p ; Function to segregate the primes and non - primes ; Generate all primes till 10 ^ 7 ; Initialize left and right ; Traverse the array ; Increment left while array element at left is prime ; Decrement right while array element at right is non - prime ; If left < right , then swap arr [ left ] and arr [ right ] ; Swap arr [ left ] and arr [ right ] ; Print segregated array ; Driver code ; Function Call","#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool prime [ 10000001 ] ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } void segregatePrimeNonPrime ( int arr [ ] , int N ) { SieveOfEratosthenes ( 10000000 ) ; int left = 0 , right = N - 1 ; while ( left < right ) { while ( prime [ arr [ left ] ] ) left ++ ; while ( ! prime [ arr [ right ] ] ) right -- ; if ( left < right ) { swap ( & arr [ left ] , & arr [ right ] ) ; left ++ ; right -- ; } } for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregatePrimeNonPrime ( arr , N ) ; return 0 ; }",Segregate Prime and Non.
176,Calculate depth of a full Binary tree from Preorder | C ++ program to find height of full binary tree using preorder ; function to return max of left subtree height or right subtree height ; calc height of left subtree ( In preorder left subtree is processed before right ) ; calc height of right subtree ; Wrapper over findDepthRec ( ) ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDepthRec ( char tree [ ] , int n , int & index ) { if ( index >= n tree [ index ] == ' l ' ) return 0 ; index ++ ; int left = findDepthRec ( tree , n , index ) ; index ++ ; int right = findDepthRec ( tree , n , index ) ; return max ( left , right ) + 1 ; } int findDepth ( char tree [ ] , int n ) { int index = 0 ; findDepthRec ( tree , n , index ) ; } int main ( ) { char tree [ ] = "" nlnnlll "" ; int n = strlen ( tree ) ; cout << findDepth ( tree , n ) << endl ; return 0 ; }",Calculate depth of a full Binary tree from Preorder.
177,"Largest number in BST which is less than or equal to N | C ++ code to find the largest value smaller than or equal to N ; Node structure ; To create new BST Node ; To insert a new node in BST ; if tree is empty return new node ; if key is less then or greater then node value then recur down the tree ; return the ( unchanged ) node pointer ; function to find max value less then N ; Base cases ; If root 's value is smaller, try in right  subtree ; If root 's key is greater, return value  from left subtree. ; Driver code ; creating following BST 5 / \ 2 12 / \ / \ 1 3 9 21 / \ 19 25","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } int findMaxforN ( Node * root , int N ) { if ( root == NULL ) return -1 ; if ( root -> key == N ) return N ; else if ( root -> key < N ) { int k = findMaxforN ( root -> right , N ) ; if ( k == -1 ) return root -> key ; else return k ; } else if ( root -> key > N ) return findMaxforN ( root -> left , N ) ; } int main ( ) { int N = 4 ; Node * root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; printf ( "" % d "" , findMaxforN ( root , N ) ) ; return 0 ; }",Largest number in BST which is less than or equal to N.
178,Largest number in BST which is less than or equal to N | C ++ code to find the largest value smaller than or equal to N ; To create new BST Node ; To insert a new node in BST ; if tree is empty return new node ; if key is less then or greater then node value then recur down the tree ; return the ( unchanged ) node pointer ; function to find max value less then N ; Start from root and keep looking for larger ; If root is smaller go to right side ; If root is greater go to left side ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } void findMaxforN ( Node * root , int N ) { while ( root != NULL && root -> right != NULL ) { if ( N > root -> key && N >= root -> right -> key ) root = root -> right ; else if ( N < root -> key ) root = root -> left ; else break ; } if ( root == NULL root -> key > N ) cout << -1 ; else cout << root -> key ; } int main ( ) { int N = 50 ; Node * root = insert ( root , 5 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; findMaxforN ( root , N ) ; return 0 ; }",Largest number in BST which is less than or equal to N.
179,Maximum element between two nodes of BST | C ++ program to find maximum element in the path between two Nodes of Binary Search Tree . ; Create and return a pointer of new Node . ; Insert a new Node in Binary Search Tree . ; Return the maximum element between a Node and its given ancestor . ; Traversing the path between ansector and Node and finding maximum element . ; Return maximum element in the path between two given Node of BST . ; Finding the LCA of Node x and Node y ; Checking if both the Node lie on the left side of the parent p . ; Checking if both the Node lie on the right side of the parent p . ; Return the maximum of maximum elements occur in path from ancestor to both Node . ; Driver Code ; Creating the root of Binary Search Tree ; Inserting Nodes in Binary Search Tree,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int data ; } ; Node * createNode ( int x ) { Node * p = new Node ; p -> data = x ; p -> left = p -> right = NULL ; return p ; } void insertNode ( struct Node * root , int x ) { Node * p = root , * q = NULL ; while ( p != NULL ) { q = p ; if ( p -> data < x ) p = p -> right ; else p = p -> left ; } if ( q == NULL ) p = createNode ( x ) ; else { if ( q -> data < x ) q -> right = createNode ( x ) ; else q -> left = createNode ( x ) ; } } int maxelpath ( Node * q , int x ) { Node * p = q ; int mx = INT_MIN ; while ( p -> data != x ) { if ( p -> data > x ) { mx = max ( mx , p -> data ) ; p = p -> left ; } else { mx = max ( mx , p -> data ) ; p = p -> right ; } } return max ( mx , x ) ; } int maximumElement ( struct Node * root , int x , int y ) { Node * p = root ; while ( ( x < p -> data && y < p -> data ) || ( x > p -> data && y > p -> data ) ) { if ( x < p -> data && y < p -> data ) p = p -> left ; else if ( x > p -> data && y > p -> data ) p = p -> right ; } return max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; } int main ( ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct Node * root = createNode ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; cout << maximumElement ( root , a , b ) << endl ; return 0 ; }",Maximum element between two nodes of BST.
180,"Threaded Binary Tree | Insertion | Insertion in Threaded Binary Search Tree . ; True if left pointer points to predecessor in Inorder Traversal ; True if right pointer points to successor in Inorder Traversal ; Insert a Node in Binary Threaded Tree ; Searching for a Node with given value ; Parent of key to be inserted ; If key already exists , return ; Update parent pointer ; Moving on left subtree . ; Moving on right subtree . ; Create a new node ; Returns inorder successor using rthread ; If rthread is set , we can quickly find ; Else return leftmost child of right subtree ; Printing the threaded tree ; Reach leftmost node ; One by one print successors ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ; struct Node * insert ( struct Node * root , int ikey ) { Node * ptr = root ; Node * par = NULL ; while ( ptr != NULL ) { if ( ikey == ( ptr -> info ) ) { printf ( "" Duplicate ▁ Key ▁ ! STRNEWLINE "" ) ; return root ; } par = ptr ; if ( ikey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } Node * tmp = new Node ; tmp -> info = ikey ; tmp -> lthread = true ; tmp -> rthread = true ; if ( par == NULL ) { root = tmp ; tmp -> left = NULL ; tmp -> right = NULL ; } else if ( ikey < ( par -> info ) ) { tmp -> left = par -> left ; tmp -> right = par ; par -> lthread = false ; par -> left = tmp ; } else { tmp -> left = par ; tmp -> right = par -> right ; par -> rthread = false ; par -> right = tmp ; } return root ; } struct Node * inorderSuccessor ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } void inorder ( struct Node * root ) { if ( root == NULL ) printf ( "" Tree ▁ is ▁ empty "" ) ; struct Node * ptr = root ; while ( ptr -> lthread == false ) ptr = ptr -> left ; while ( ptr != NULL ) { printf ( "" % d ▁ "" , ptr -> info ) ; ptr = inorderSuccessor ( ptr ) ; } } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ; return 0 ; }",Threaded Binary Tree.
181,Threaded Binary Search Tree | Deletion |  ; True if left pointer points to predecessor in Inorder Traversal ; True if right pointer points to predecessor in Inorder Traversal,"struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ;",Threaded Binary Search Tree.
182,Threaded Binary Search Tree | Deletion | Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node . ; If Node to be deleted is root ; If Node to be deleted is left of its parent,"struct Node * caseA ( struct Node * root , struct Node * par , struct Node * ptr ) { if ( par == NULL ) root = NULL ; else if ( ptr == par -> left ) { par -> lthread = true ; par -> left = ptr -> left ; } else { par -> rthread = true ; par -> right = ptr -> right ; } free ( ptr ) ; return root ; }",Threaded Binary Search Tree.
183,Threaded Binary Search Tree | Deletion | Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node . ; Initialize child Node to be deleted has left child . ; Node to be deleted has right child . ; Node to be deleted is root Node . ; Node is left child of its parent . ; Find successor and predecessor ; If ptr has left subtree . ; If ptr has right subtree .,"struct Node * caseB ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * child ; if ( ptr -> lthread == false ) child = ptr -> left ; else child = ptr -> right ; if ( par == NULL ) root = child ; else if ( ptr == par -> left ) par -> left = child ; else par -> right = child ; Node * s = inSucc ( ptr ) ; Node * p = inPred ( ptr ) ; if ( ptr -> lthread == false ) p -> right = s ; else { if ( ptr -> rthread == false ) s -> left = p ; } free ( ptr ) ; return root ; }",Threaded Binary Search Tree.
184,"Threaded Binary Search Tree | Deletion | Complete C ++ program to demonstrate deletion in threaded BST ; True if left pointer points to predecessor in Inorder Traversal ; True if right pointer points to predecessor in Inorder Traversal ; Insert a Node in Binary Threaded Tree ; Searching for a Node with given value ; Parent of key to be inserted ; If key already exists , return ; Update parent pointer ; Moving on left subtree . ; Moving on right subtree . ; Create a new Node ; Returns inorder successor using left and right children ( Used in deletion ) ; Returns inorder successor using rthread ( Used in inorder ) ; If rthread is set , we can quickly find ; Else return leftmost child of right subtree ; Printing the threaded tree ; Reach leftmost Node ; One by one print successors ; Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node . ; If Node to be deleted is root ; If Node to be deleted is left of its parent ; Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node . ; Initialize child Node to be deleted has left child . ; Node to be deleted has right child . ; Node to be deleted is root Node . ; Node is left child of its parent . ; Find successor and predecessor ; If ptr has left subtree . ; If ptr has right subtree . ; Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node . ; Find inorder successor and its parent . ; Find leftmost child of successor ; Deletes a key from threaded BST with given root and returns new root of BST . ; Initialize parent as NULL and ptrent Node as root . ; Set true if key is found ; Search key in BST : find Node and its parent . ; Two Children ; Only Left Child ; Only Right Child ; No child ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ; struct Node * insert ( struct Node * root , int ikey ) { Node * ptr = root ; Node * par = NULL ; while ( ptr != NULL ) { if ( ikey == ( ptr -> info ) ) { printf ( "" Duplicate ▁ Key ▁ ! STRNEWLINE "" ) ; return root ; } par = ptr ; if ( ikey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } Node * tmp = new Node ; tmp -> info = ikey ; tmp -> lthread = true ; tmp -> rthread = true ; if ( par == NULL ) { root = tmp ; tmp -> left = NULL ; tmp -> right = NULL ; } else if ( ikey < ( par -> info ) ) { tmp -> left = par -> left ; tmp -> right = par ; par -> lthread = false ; par -> left = tmp ; } else { tmp -> left = par ; tmp -> right = par -> right ; par -> rthread = false ; par -> right = tmp ; } return root ; } struct Node * inSucc ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } struct Node * inorderSuccessor ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } void inorder ( struct Node * root ) { if ( root == NULL ) printf ( "" Tree ▁ is ▁ empty "" ) ; struct Node * ptr = root ; while ( ptr -> lthread == false ) ptr = ptr -> left ; while ( ptr != NULL ) { printf ( "" % d ▁ "" , ptr -> info ) ; ptr = inorderSuccessor ( ptr ) ; } } struct Node * inPred ( struct Node * ptr ) { if ( ptr -> lthread == true ) return ptr -> left ; ptr = ptr -> left ; while ( ptr -> rthread == false ) ptr = ptr -> right ; return ptr ; } struct Node * caseA ( struct Node * root , struct Node * par , struct Node * ptr ) { if ( par == NULL ) root = NULL ; else if ( ptr == par -> left ) { par -> lthread = true ; par -> left = ptr -> left ; } else { par -> rthread = true ; par -> right = ptr -> right ; } free ( ptr ) ; return root ; } struct Node * caseB ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * child ; if ( ptr -> lthread == false ) child = ptr -> left ; else child = ptr -> right ; if ( par == NULL ) root = child ; else if ( ptr == par -> left ) par -> left = child ; else par -> right = child ; Node * s = inSucc ( ptr ) ; Node * p = inPred ( ptr ) ; if ( ptr -> lthread == false ) p -> right = s ; else { if ( ptr -> rthread == false ) s -> left = p ; } free ( ptr ) ; return root ; } struct Node * caseC ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * parsucc = ptr ; struct Node * succ = ptr -> right ; while ( succ -> lthread == false ) { parsucc = succ ; succ = succ -> left ; } ptr -> info = succ -> info ; if ( succ -> lthread == true && succ -> rthread == true ) root = caseA ( root , parsucc , succ ) ; else root = caseB ( root , parsucc , succ ) ; return root ; } struct Node * delThreadedBST ( struct Node * root , int dkey ) { struct Node * par = NULL , * ptr = root ; int found = 0 ; while ( ptr != NULL ) { if ( dkey == ptr -> info ) { found = 1 ; break ; } par = ptr ; if ( dkey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } if ( found == 0 ) printf ( "" dkey ▁ not ▁ present ▁ in ▁ tree STRNEWLINE "" ) ; else if ( ptr -> lthread == false && ptr -> rthread == false ) root = caseC ( root , par , ptr ) ; else if ( ptr -> lthread == false ) root = caseB ( root , par , ptr ) ; else if ( ptr -> rthread == false ) root = caseB ( root , par , ptr ) ; else root = caseA ( root , par , ptr ) ; return root ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; root = delThreadedBST ( root , 20 ) ; inorder ( root ) ; return 0 ; }",Threaded Binary Search Tree.
185,"Check horizontal and vertical symmetry in binary matrix | C ++ program to find if a matrix is symmetric . ; Initializing as both horizontal and vertical symmetric . ; Checking for Horizontal Symmetry . We compare first row with last row , second row with second last row and so on . ; Checking each cell of a column . ; check if every cell is identical ; Checking for Vertical Symmetry . We compare first column with last column , second xolumn with second last column and so on . ; Checking each cell of a row . ; check if every cell is identical ; Driven Program","#include <bits/stdc++.h> NEW_LINE #define MAX  1000 NEW_LINE using namespace std ; void checkHV ( int arr [ ] [ MAX ] , int N , int M ) { bool horizontal = true , vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { vertical = false ; break ; } } } if ( ! horizontal && ! vertical ) cout << "" NO STRNEWLINE "" ; else if ( horizontal && ! vertical ) cout << "" HORIZONTAL STRNEWLINE "" ; else if ( vertical && ! horizontal ) cout << "" VERTICAL STRNEWLINE "" ; else cout << "" BOTH STRNEWLINE "" ; } int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; return 0 ; }",Check horizontal and vertical symmetry in binary matrix.
186,Replace every matrix element with maximum of GCD of row or column | C ++ program to replace each each element with maximum of GCD of row or column . ; returning the greatest common divisor of two number ; Finding GCD of each row and column and replacing with each element with maximum of GCD of row or column . ; Calculating GCD of each row and each column in O ( mn ) and store in arrays . ; Replacing matrix element ; Driven Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  4 NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void replacematrix ( int mat [ R ] [ C ] , int n , int m ) { int rgcd [ R ] = { 0 } , cgcd [ C ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) ; } int main ( ) { int m [ R ] [ C ] = { 1 , 2 , 3 , 3 , 4 , 5 , 6 , 6 , 7 , 8 , 9 , 9 , } ; replacematrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) cout << m [ i ] [ j ] << "" ▁ "" ; cout << endl ; } return 0 ; }",Replace every matrix element with maximum of GCD of row or column.
187,"Program for addition of two matrices | C ++ program for addition of two matrices ; This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; cout << "" Result ▁ matrix ▁ is ▁ "" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << "" ▁ "" ; cout << endl ; } return 0 ; }",Program for addition of two matrices.
188,"Program for subtraction of matrices | C ++ program for subtraction of matrices ; This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; cout << "" Result ▁ matrix ▁ is ▁ "" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << "" ▁ "" ; cout << endl ; } return 0 ; }",Program for subtraction of matrices.
189,Find a Fixed Point ( Value equal to index ) in a given array | C ++ program to check fixed point in an array using linear search ; If no fixed point present then return - 1 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Fixed ▁ Point ▁ is ▁ "" << linearSearch ( arr , n ) ; return 0 ; }",Find a Fixed Point ( Value equal to index ) in a given array.
190,Find a Fixed Point ( Value equal to index ) in a given array | C ++ program to check fixed point in an array using binary search ; low + ( high - low ) / 2 ; ; Return - 1 if there is no Fixed Point ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; } int main ( ) { int arr [ 10 ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Fixed ▁ Point ▁ is ▁ "" << binarySearch ( arr , 0 , n - 1 ) ; return 0 ; }",Find a Fixed Point ( Value equal to index ) in a given array.
191,Maximum triplet sum in array | C ++ code to find maximum triplet sum ; Initialize sum with INT_MIN ; Driven code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }",Maximum triplet sum in array.
192,Maximum triplet sum in array | C ++ code to find maximum triplet sum ; This function assumes that there are at least three elements in arr [ ] . ; sort the given array ; After sorting the array . Add last three element of the given array ; Driven code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }",Maximum triplet sum in array.
193,"Maximum triplet sum in array | C ++ code to find maximum triplet sum ; This function assumes that there are at least three elements in arr [ ] . ; Initialize Maximum , second maximum and third maximum element ; Update Maximum , second maximum and third maximum element ; Update second maximum and third maximum element ; Update third maximum element ; Driven code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }",Maximum triplet sum in array.
194,"Linear Search | C ++ code to linearly search x in arr [ ] . If x is present then return its location , otherwise return - 1 ; Driver code ; Function call","#include <iostream> NEW_LINE using namespace std ; int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = search ( arr , n , x ) ; ( result == -1 ) ? cout << "" Element ▁ is ▁ not ▁ present ▁ in ▁ array "" : cout << "" Element ▁ is ▁ present ▁ at ▁ index ▁ "" << result ; return 0 ; }",Linear Search.
195,Linear Search | C ++ program for linear search ; Run loop from 0 to right ; If search_element is found with left variable ; If search_element is found with right variable ; If element not found ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( vector < int > arr , int search_Element ) { int left = 0 ; int length = arr . size ( ) ; int position = -1 ; int right = length - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; cout << "" Element ▁ found ▁ in ▁ Array ▁ at ▁ "" << position + 1 << "" ▁ Position ▁ with ▁ "" << left + 1 << "" ▁ Attempt "" ; break ; } if ( arr [ right ] == search_Element ) { position = right ; cout << "" Element ▁ found ▁ in ▁ Array ▁ at ▁ "" << position + 1 << "" ▁ Position ▁ with ▁ "" << length - right << "" ▁ Attempt "" ; break ; } left ++ ; right -- ; } if ( position == -1 ) cout << "" Not ▁ found ▁ in ▁ Array ▁ with ▁ "" << left << "" ▁ Attempt "" ; } int main ( ) { vector < int > arr { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ; search ( arr , search_element ) ; }",Linear Search.
196,"Counting Sort | C ++ Program for counting sort ; The main function that sort the given string arr [ ] in alphabetical order ; The output character array that will have sorted arr ; Create a count array to store count of individual characters and initialize count array as 0 ; Store count of each character ; Change count [ i ] so that count [ i ] now contains actual position of this character in output array ; Build the output character array ; Copy the output array to arr , so that arr now contains sorted characters ; Driver code","#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; #define RANGE  255 NEW_LINE void countSort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; } int main ( ) { char arr [ ] = "" geeksforgeeks "" ; countSort ( arr ) ; cout << "" Sorted ▁ character ▁ array ▁ is ▁ "" << arr ; return 0 ; }",Counting Sort.
197,Counting Sort | Counting sort which takes negative numbers as well ; The function that sorts the given arr [ ] ; function to print array ; Driver code,"#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void countSort ( vector < int > & arr ) { int max = * max_element ( arr . begin ( ) , arr . end ( ) ) ; int min = * min_element ( arr . begin ( ) , arr . end ( ) ) ; int range = max - min + 1 ; vector < int > count ( range ) , output ( arr . size ( ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) count [ arr [ i ] - min ] ++ ; for ( int i = 1 ; i < count . size ( ) ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( int i = arr . size ( ) - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) arr [ i ] = output [ i ] ; } void printArray ( vector < int > & arr ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << "" ▁ "" ; cout << "" STRNEWLINE "" ; } int main ( ) { vector < int > arr = { -5 , -10 , 0 , -3 , 8 , 5 , -1 , 10 } ; countSort ( arr ) ; printArray ( arr ) ; return 0 ; }",Counting Sort.
198,"Binomial Coefficient | DP | A naive recursive C ++ implementation ; Returns value of Binomial Coefficient C ( n , k ) ; Base Cases ; Recur ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } int main ( ) { int n = 5 , k = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << binomialCoeff ( n , k ) ; return 0 ; }",Binomial Coefficient.
199,Binomial Coefficient | DP | C ++ program for space optimized Dynamic Programming Solution of Binomial Coefficient ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 5 , k = 2 ; printf ( "" Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ "" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }",Binomial Coefficient.
200,Binomial Coefficient | DP | C ++ program for the above approach ; Function to find binomial coefficient ; Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007 ; for 1 / ( r ! ) part ; for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << r << "" ) ▁ is ▁ "" << binomialCoeff ( n , r ) << endl ; return 0 ; }",Binomial Coefficient.
201,"Partition problem | DP | A Dynamic Programming based C ++ program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; Initialze the part array as 0 ; Fill the partition table in bottom up manner ; the element to be included in the sum cannot be greater than the sum ; check if sum - arr [ i ] could be formed from a subset using elements before index i ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }",Partition problem.
202,"Dynamic Programming | A recursive solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following : ( a ) including the last element ( b ) excluding the last element ; Driver code","#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ) ; else printf ( "" No ▁ subset ▁ with ▁ given ▁ sum "" ) ; return 0 ; }",Dynamic Programming.
203,"Dynamic Programming | A Dynamic Programming solution for subset sum problem ; Returns true if there is a subset of set [ ] with sun equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in botton up manner ; print table ; Driver code","#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( "" % 4d "" , subset [ i ] [ j ] ) ; printf ( "" STRNEWLINE "" ) ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( "" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum "" ) ; else printf ( "" No ▁ subset ▁ with ▁ given ▁ sum "" ) ; return 0 ; }",Dynamic Programming.
204,"How to print maximum number of A 's using given four keys | A recursive C ++ program to print maximum number of A 's using following four keys  ; A recursive function that returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; Initialize result ; TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way . ; If the breakpoint is s at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ "" << N << "" ▁ keystrokes ▁ is ▁ "" << findoptimal ( N ) << endl ; }",How to print maximum number of A 's using given four keys.
205,"How to print maximum number of A 's using given four keys | A Dynamic Programming based C program to find maximum number of A 's that can be printed using four keys  ; this function returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; An array to store result of subproblems ; To pick a breakpoint ; Initializing the optimal lengths array for uptil 6 input strokes . ; Solve all subproblems in bottom manner ; Initialize length of optimal string for n keystrokes ; For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way . ; if the breakpoint is at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","#include <iostream> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ "" << N << "" ▁ keystrokes ▁ is ▁ "" << findoptimal ( N ) << endl ; }",How to print maximum number of A 's using given four keys.
206,"How to print maximum number of A 's using given four keys | A Dynamic Programming based C ++ program to find maximum number of A 's that can be printed using four keys ; This function returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; An array to store result of subproblems ; To pick a breakpoint ; Initializing the optimal lengths array for uptil 6 input strokes . ; Solve all subproblems in bottom - up manner ; for any keystroke n , we will need to choose between : - 1. pressing Ctrl - V once after copying the A ' s ▁ obtained ▁ by ▁ n - 3 ▁ keystrokes . ▁ ▁ 2 . ▁ pressing ▁ Ctrl - V ▁ twice ▁ after ▁ copying ▁ the ▁ A ' s obtained by n - 4 keystrokes . 3. pressing Ctrl - V thrice after copying the A 's  obtained by n-5 keystrokes. ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) printf ( "" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ % d ▁ keystrokes ▁ is ▁ % d STRNEWLINE "" , N , findoptimal ( N ) ) ; }",How to print maximum number of A 's using given four keys.
207,"Write a program to calculate pow ( x , n ) | C ++ program to calculate pow ( x , n ) ; Function to calculate x raised to the power y ; Driver code","#include <iostream> NEW_LINE using namespace std ; class gfg { public : int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } } ; int main ( ) { gfg g ; int x = 2 ; unsigned int y = 3 ; cout << g . power ( x , y ) ; return 0 ; }","Write a program to calculate pow ( x , n )."
208,"Write a program to calculate pow ( x , n ) | Function to calculate x raised to the power y in O ( logn )","int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }","Write a program to calculate pow ( x , n )."
209,"Write a program to calculate pow ( x , n ) | Extended version of power function that can work for float x and negative y ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } int main ( ) { float x = 2 ; int y = -3 ; cout << power ( x , y ) ; return 0 ; }","Write a program to calculate pow ( x , n )."
210,"Write a program to calculate pow ( x , n ) | C ++ program for the above approach ; If x ^ 0 return 1 ; If we need to find of 0 ^ y ; For all other cases ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }","Write a program to calculate pow ( x , n )."
211,"Write a program to calculate pow ( x , n ) | C ++ program for the above approach ; return type of pow ( ) function is double ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { return ( int ) pow ( x , y ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }","Write a program to calculate pow ( x , n )."
212,Babylonian method for square root |  ; Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e decides the accuracy level ; Driver program to test above function,"#include <iostream> NEW_LINE using namespace std ; class gfg { public : float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } } ; int main ( ) { gfg g ; int n = 50 ; cout << "" Square ▁ root ▁ of ▁ "" << n << "" ▁ is ▁ "" << g . squareRoot ( n ) ; getchar ( ) ; }",Babylonian method for square root.
213,Average of a stream of numbers |  ; Returns the new average after including x ; Prints average of a stream of numbers ; Driver program to test above functions,"#include <stdio.h> NEW_LINE float getAvg ( float prev_avg , int x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; } void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; printf ( "" Average ▁ of ▁ % d ▁ numbers ▁ is ▁ % f ▁ STRNEWLINE "" , i + 1 , avg ) ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }",Average of a stream of numbers.
214,Average of a stream of numbers |  ; Returns the new average after including x ; Prints average of a stream of numbers ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float getAvg ( int x ) { static int sum , n ; sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( arr [ i ] ) ; cout << "" Average ▁ of ▁ "" << i + 1 << "" ▁ numbers ▁ is ▁ "" << fixed << setprecision ( 1 ) << avg << endl ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }",Average of a stream of numbers.
215,"Space and time efficient Binomial Coefficient | Program to calculate C ( n , k ) ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ] ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 8 , k = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << k << "" ) ▁ is ▁ "" << binomialCoeff ( n , k ) ; return 0 ; }",Space and time efficient Binomial Coefficient.
216,"Efficient program to print all prime factors of a given number | C ++ program to print all prime factors ; A function to print all prime factors of a given number n ; Print the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void primeFactors ( int n ) { while ( n % 2 == 0 ) { cout << 2 << "" ▁ "" ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { cout << i << "" ▁ "" ; n = n / i ; } } if ( n > 2 ) cout << n << "" ▁ "" ; } int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }",Efficient program to print all prime factors of a given number.
217,"Print all possible combinations of r elements in a given array of size n | C ++ program to print all combination of size r in an array of size n ; The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed ; Current combination is ready to be printed , print it ; replace index with all possible elements . The condition "" end - i + 1 ▁ > = ▁ r - index "" makes sure that including one element at index will make a combination with remaining elements at remaining positions ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << "" ▁ "" ; cout << endl ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; }",Print all possible combinations of r elements in a given array of size n.
218,"Print all possible combinations of r elements in a given array of size n | C ++ Program to print all combination of size r in an array of size n ; The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array n -- -> Size of input array r -- -> Size of a combination to be printed index -- -> Current index in data [ ] data [ ] -- -> Temporary array to store current combination i -- -> index of current element in arr [ ] ; Current combination is ready , print it ; When no more elements are there to put in data [ ] ; current is included , put next at next location ; current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed ) ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << "" ▁ "" ; cout << endl ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; return 0 ; }",Print all possible combinations of r elements in a given array of size n.
219,"Count all possible groups of size 2 or 3 that have sum as multiple of 3 | C ++ Program to count all possible groups of size 2 or 3 that have sum as multiple of 3 ; Returns count of all possible groups that can be formed from elements of a [ ] . ; Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i ; To store the result ; Count elements with remainder 0 , 1 and 2 ; Case 3. a : Count groups of size 2 from 0 remainder elements ; Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder ; Case 4. a : Count groups of size 3 with all 0 remainder elements ; Case 4. b : Count groups of size 3 with all 1 remainder elements ; Case 4. c : Count groups of size 3 with all 2 remainder elements ; Case 4. c : Count groups of size 3 with different remainders ; Return total count stored in res ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Required ▁ number ▁ of ▁ groups ▁ are ▁ "" << findgroups ( arr , n ) << endl ; return 0 ; }",Count all possible groups of size 2 or 3 that have sum as multiple of 3.
220,Smallest power of 2 greater than or equal to n | C ++ program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.
221,Smallest power of 2 greater than or equal to n | C ++ program to find smallest power of 2 greater than or equal to n ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.
222,Smallest power of 2 greater than or equal to n | C ++ program to Finds next power of two for n . If n itself is a power of two then returns n ; Finds next power of two for n . If n itself is a power of two then returns n ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; },Smallest power of 2 greater than or equal to n.
223,Segregate 0 s and 1 s in an array | C ++ code to Segregate 0 s and 1 s in an array ; Function to segregate 0 s and 1 s ; Counts the no of zeros in arr ; Loop fills the arr with 0 until count ; Loop fills remaining arr space with 1 ; Function to print segregated array ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; } void print ( int arr [ ] , int n ) { cout << "" Array ▁ after ▁ segregation ▁ is ▁ "" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , n ) ; print ( arr , n ) ; return 0 ; }",Segregate 0 s and 1 s in an array.
224,Segregate 0 s and 1 s in an array | C ++ program to sort a binary array in one pass ; Function to put all 0 s on left and all 1 s on right ; Initialize left and right indexes ; Increment left index while we see 0 at left ; Decrement right index while we see 1 at right ; If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ] ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << "" Array ▁ after ▁ segregation ▁ "" ; for ( i = 0 ; i < 6 ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Segregate 0 s and 1 s in an array.
225,Segregate 0 s and 1 s in an array | C ++ program to sort a binary array in one pass ; Function to put all 0 s on left and all 1 s on right ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << "" Array ▁ after ▁ segregation ▁ is ▁ "" ; for ( i = 0 ; i < arr_size ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Segregate 0 s and 1 s in an array.
226,Distinct adjacent elements in an array | C ++ program to check if we can make neighbors distinct . ; map used to count the frequency of each element occurring in the array ; In this loop we count the frequency of element through map m . ; mx store the frequency of element which occurs most in array . ; In this loop we calculate the maximum frequency and store it in variable mx . ; By swapping we can adjust array only when the frequency of the element which occurs most is less than or equal to ( n + 1 ) / 2 . ; Driver program to test the above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void distinctAdjacentElement ( int a [ ] , int n ) { map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) m [ a [ i ] ] ++ ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( mx < m [ a [ i ] ] ) mx = m [ a [ i ] ] ; if ( mx > ( n + 1 ) / 2 ) cout << "" NO "" << endl ; else cout << "" YES "" << endl ; } int main ( ) { int a [ ] = { 7 , 7 , 7 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; distinctAdjacentElement ( a , n ) ; return 0 ; }",Distinct adjacent elements in an array.
227,"Given an array arr [ ] , find the maximum j | CPP program for the above approach ; For a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ] ; Driver program to test above functions","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxDiff = maxIndexDiff ( arr , n ) ; cout << "" STRNEWLINE "" << maxDiff ; return 0 ; }","Given an array arr [ ] , find the maximum j."
228,"Given an array arr [ ] , find the maximum j | For a given array arr [ ] , calculates the maximum j a i such that arr [ j ] > arr [ i ] ; create an array maxfromEnd ; We store this as current answer and look for further larger number to the right side ; keeping a track of the maximum difference in indices","#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { vector < long long int > v { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . size ( ) ; vector < long long int > maxFromEnd ( n + 1 , INT_MIN ) ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int low = i + 1 , high = v . size ( ) - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= maxFromEnd [ mid ] ) { ans = max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = max ( result , ans - i ) ; } cout << result << endl ; }","Given an array arr [ ] , find the maximum j."
229,"Given an array arr [ ] , find the maximum j | C ++ implementation of the hashmap approach ; Function to find maximum index difference ; Initilaise unordered_map ; Iterate from 0 to n - 1 ; Sort arr ; Iterate from 0 to n - 1 ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( vector < int > & arr , int n ) { unordered_map < int , vector < int > > hashmap ; for ( int i = 0 ; i < n ; i ++ ) { hashmap [ arr [ i ] ] . push_back ( i ) ; } sort ( arr . begin ( ) , arr . end ( ) ) ; int maxDiff = INT_MIN ; int temp = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap [ arr [ i ] ] [ 0 ] ) { temp = hashmap [ arr [ i ] ] [ 0 ] ; } maxDiff = max ( maxDiff , hashmap [ arr [ i ] ] [ hashmap [ arr [ i ] ] . size ( ) - 1 ] - temp ) ; } return maxDiff ; } int main ( ) { int n = 9 ; vector < int > arr { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int ans = maxIndexDiff ( arr , n ) ; cout << "" The ▁ maxIndexDiff ▁ is ▁ : ▁ "" << ans << endl ; return 1 ; }","Given an array arr [ ] , find the maximum j."
230,Print sorted distinct elements of array | CPP program to print sorted distinct elements . ; Create a set using array elements ; Print contents of the set . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { set < int > s ( arr , arr + size ) ; for ( auto x : s ) cout << x << "" ▁ "" ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , n ) ; return 0 ; }",Print sorted distinct elements of array.
231,Minimum swaps to make two arrays identical | C ++ program to make an array same to another using minimum number of swap ; Function returns the minimum number of swaps required to sort the array This method is taken from below post www . geeksforgeeks . org / minimum - number - swaps - required - sort - array / https : ; Create an array of pairs where first element is array element and second element is position of first element ; Sort the array by array element values to get right position of every element as second element of pair . ; To keep track of visited elements . Initialize all elements as not visited or false . ; Initialize result ; Traverse array elements ; already swapped and corrected or already present at correct pos ; find out the number of node in this cycle and add in ans ; move to next node ; Update answer by adding current cycle . ; Return result ; method returns minimum number of swap to make array B same as array A ; map to store position of elements in array B we basically store element to index mapping . ; now we 're storing position of array A elements  in array B. ; returing minimum swap for sorting in modified array B as final answer ; Driver code to test above methods,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwapsToSort ( int arr [ ] , int n ) { pair < int , int > arrPos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrPos [ i ] . first = arr [ i ] ; arrPos [ i ] . second = i ; } sort ( arrPos , arrPos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] . second == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arrPos [ j ] . second ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; } int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ b [ i ] ] = i ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp [ a [ i ] ] ; return minSwapsToSort ( b , n ) ; } int main ( ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << minSwapToMakeArraySame ( a , b , n ) ; return 0 ; }",Minimum swaps to make two arrays identical.
232,k |  ; Function to find k - th missing element ; interating over the array ; check if i - th and ( i + 1 ) - th element are not consecutive ; save their difference ; check for difference and given k ; if found ; Driver code ; Input array ; k - th missing element to be found in the array ; calling function to find missing element,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = 1 ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; } int main ( ) { int a [ ] = { 1 , 5 , 11 , 19 } ; int k = 11 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int missing = missingK ( a , k , n ) ; cout << missing << endl ; return 0 ; }",k.
233,"k | CPP program for above approach ; Function to find kth missing number ; If the total missing number count is equal to k we can iterate backwards for the first missing number and that will be the answer . ; To further optimize we check if the previous element ' s ▁ ▁ missing ▁ number ▁ count ▁ is ▁ equal ▁ ▁ to ▁ k . ▁ Eg : ▁ arr ▁ = ▁ [ 4,5,6,7,8 ] ▁ ▁ If ▁ you ▁ observe ▁ in ▁ the ▁ example ▁ array , ▁ ▁ the ▁ total ▁ count ▁ of ▁ missing ▁ numbers ▁ for ▁ all ▁ ▁ the ▁ indices ▁ are ▁ same , ▁ and ▁ we ▁ are ▁ ▁ aiming ▁ to ▁ narrow ▁ down ▁ the ▁ ▁ search ▁ window ▁ and ▁ achieve ▁ O ( logn ) ▁ ▁ time ▁ complexity ▁ which ▁ ▁ otherwise ▁ would ' ve been O ( n ) . ; Else we return arr [ mid ] - 1. ; Here we appropriately narrow down the search window . ; In case the upper limit is - ve it means the missing number set is 1 , 2 , . . , k and hence we directly return k . ; Else we find the residual count of numbers which we 'd then add to  arr[u] and get the missing kth number. ; Return arr [ u ] + k ; Driver Code ; Function Call","#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int missingK ( vector < int > & arr , int k ) { int n = arr . size ( ) ; int l = 0 , u = n - 1 , mid ; while ( l <= u ) { mid = ( l + u ) / 2 ; int numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ; if ( numbers_less_than_mid == k ) { if ( mid > 0 && ( arr [ mid - 1 ] - ( mid ) ) == k ) { u = mid - 1 ; continue ; } return arr [ mid ] - 1 ; } if ( numbers_less_than_mid < k ) { l = mid + 1 ; } else if ( k < numbers_less_than_mid ) { u = mid - 1 ; } } if ( u < 0 ) return k ; int less = arr [ u ] - ( u + 1 ) ; k -= less ; return arr [ u ] + k ; } int main ( ) { vector < int > arr = { 2 , 3 , 4 , 7 , 11 } ; int k = 5 ; cout << "" Missing ▁ kth ▁ number ▁ = ▁ "" << missingK ( arr , k ) << endl ; return 0 ; }",k.
234,Alternate Odd and Even Nodes in a Singly Linked List | CPP program to rearrange nodes as alternate odd even nodes in a Singly Linked List ; Structure node ; A utility function to print linked list ; Function to create newNode in a linkedlist ; Function to insert at beginning ; Function to rearrange the odd and even nodes ; Odd Value in Even Position Add pointer to current node in odd stack ; Even Value in Odd Position Add pointer to current node in even stack ; Swap Data at the top of two stacks ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << "" ▁ "" ; node = node -> next ; } cout << endl ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * insertBeg ( Node * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = head ; head = temp ; return head ; } void rearrangeOddEven ( Node * head ) { stack < Node * > odd ; stack < Node * > even ; int i = 1 ; while ( head != nullptr ) { if ( head -> data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head -> data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head -> next ; i ++ ; } while ( ! odd . empty ( ) && ! even . empty ( ) ) { swap ( odd . top ( ) -> data , even . top ( ) -> data ) ; odd . pop ( ) ; even . pop ( ) ; } } int main ( ) { Node * head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; cout << "" Linked ▁ List : "" << endl ; printList ( head ) ; rearrangeOddEven ( head ) ; cout << "" Linked ▁ List ▁ after ▁ "" << "" Rearranging : "" << endl ; printList ( head ) ; return 0 ; }",Alternate Odd and Even Nodes in a Singly Linked List.
235,"Alternate Odd and Even Nodes in a Singly Linked List | Cpp program to rearrange nodes as alternate odd even nodes in a Singly Linked List ; Structure node ; A utility function to print linked list ; Function to create newNode in a linkedlist ; Function to insert at beginning ; Function to rearrange the odd and even nodes ; Step 1 : Segregate even and odd nodes Step 2 : Split odd and even lists Step 3 : Merge even list into odd list ; Step 1 : Segregate Odd and Even Nodes ; Backup next pointer of temp ; If temp is odd move the node to beginning of list ; Advance Temp Pointer ; Step 2 Split the List into Odd and even ; End the odd List ( Make last node null ) ; Step 3 : Merge Even List into odd ; While both lists are not exhausted Backup next pointers of i and j ; ptr points to the latest node added ; Advance i and j pointers ; Odd list exhausts before even , append remainder of even list to odd . ; The case where even list exhausts before odd list is automatically handled since we merge the even list into the odd list ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << "" ▁ "" ; node = node -> next ; } cout << endl ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * insertBeg ( Node * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = head ; head = temp ; return head ; } void rearrange ( Node * * head ) { Node * even ; Node * temp , * prev_temp ; Node * i , * j , * k , * l , * ptr ; temp = ( * head ) -> next ; prev_temp = * head ; while ( temp != nullptr ) { Node * x = temp -> next ; if ( temp -> data % 2 != 0 ) { prev_temp -> next = x ; temp -> next = ( * head ) ; ( * head ) = temp ; } else { prev_temp = temp ; } temp = x ; } temp = ( * head ) -> next ; prev_temp = ( * head ) ; while ( temp != nullptr && temp -> data % 2 != 0 ) { prev_temp = temp ; temp = temp -> next ; } even = temp ; prev_temp -> next = nullptr ; i = * head ; j = even ; while ( j != nullptr && i != nullptr ) { k = i -> next ; l = j -> next ; i -> next = j ; j -> next = k ; ptr = j ; i = k ; j = l ; } if ( i == nullptr ) { ptr -> next = j ; } } int main ( ) { Node * head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; cout << "" Linked ▁ List : "" << endl ; printList ( head ) ; cout << "" Rearranged ▁ List "" << endl ; rearrange ( & head ) ; printList ( head ) ; }",Alternate Odd and Even Nodes in a Singly Linked List.
236,"Rotate all Matrix elements except the diagonal K times by 90 degrees in clockwise direction | C ++ program for the above approach ; Function to print the matrix ; Iterate over the rows ; Iterate over the columns ; Print the value ; Function to perform the swapping of matrix elements in clockwise manner ; Stores the last row ; Stores the last column ; Perform the swaps ; Function to rotate non - diagonal elements of the matrix K times in clockwise direction ; Update K to K % 4 ; Iterate until K is positive ; Iterate each up to N / 2 - th row ; Iterate each column from i to N - i - 1 ; Check if the element at i , j is not a diagonal element ; Perform the swapping ; Print the matrix ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( vector < vector < int > > & mat ) { for ( int i = 0 ; i < mat . size ( ) ; i ++ ) { for ( int j = 0 ; j < mat [ 0 ] . size ( ) ; j ++ ) cout << setw ( 3 ) << mat [ i ] [ j ] ; cout << "" STRNEWLINE "" ; } } void performSwap ( vector < vector < int > > & mat , int i , int j ) { int N = mat . size ( ) ; int ei = N - 1 - i ; int ej = N - 1 - j ; int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; } void rotate ( vector < vector < int > > & mat , int N , int K ) { K = K % 4 ; while ( K -- ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; } int main ( ) { int K = 5 ; vector < vector < int > > mat = { { 1 , 2 , 3 , 4 } , { 6 , 7 , 8 , 9 } , { 11 , 12 , 13 , 14 } , { 16 , 17 , 18 , 19 } , } ; int N = mat . size ( ) ; rotate ( mat , N , K ) ; return 0 ; }",Rotate all Matrix elements except the diagonal K times by 90 degrees in clockwise direction.
237,Minimum rotations required to get the same string | C ++ program to determine minimum number of rotations required to yield same string . ; Returns count of rotations to get the same string back . ; tmp is the concatenated string . ; substring from i index of original string size . ; if substring matches with original string then we will come out of the loop . ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int findRotations ( string str ) { string tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { string substring = tmp . substr ( i , str . size ( ) ) ; if ( str == substring ) return i ; } return n ; } int main ( ) { string str = "" abc "" ; cout << findRotations ( str ) << endl ; return 0 ; }",Minimum rotations required to get the same string.
238,Count of elements which are power of 2 in a given range subarray for Q queries | C ++ implementation to find elements that are a power of two ; prefix [ i ] is going to store the number of elements which are a power of two till i ( including i ) . ; Function to find the maximum range whose sum is divisible by M . ; Calculate the prefix sum ; Function to return the number of elements which are a power of two in a subarray ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prefix [ MAX + 1 ] ; bool isPowerOfTwo ( int x ) { if ( x && ( ! ( x & ( x - 1 ) ) ) ) return true ; return false ; } void computePrefix ( int n , int a [ ] ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } } int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; } int main ( ) { int A [ ] = { 3 , 8 , 5 , 2 , 5 , 10 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int Q = 2 ; computePrefix ( N , A ) ; cout << query ( 0 , 4 ) << "" STRNEWLINE "" ; cout << query ( 3 , 5 ) << "" STRNEWLINE "" ; return 0 ; }",Count of elements which are power of 2 in a given range subarray for Q queries.
239,Count of integral coordinates that lies inside a Square | C ++ program for the above approach ; Function to calculate the integral points inside a square ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; } int main ( ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; return 0 ; }",Count of integral coordinates that lies inside a Square.
240,Find Next number having distinct digits from the given number N | C ++ implementation to find the next distinct digits number ; Function to find the next distinct digits number ; Loop to find the distinct digits using hash array and the number of digits ; Loop to find the most significant distinct digit of the next number ; Condition to check if the number is possible with the same number of digits count ; Condition to check if the desired most siginificant distinct digit is found ; Loop to find the minimum next digit which is not present in the number ; Computation of the number ; Condition to check if the number is greater than the given number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNextNumber ( int n ) { int h [ 10 ] = { 0 } ; int i = 0 , msb = n , rem = 0 ; int next_num = -1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == -1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) cout << next_num << "" STRNEWLINE "" ; else cout << "" Not ▁ Possible ▁ STRNEWLINE "" ; } else { cout << "" Not ▁ Possible ▁ STRNEWLINE "" ; } } int main ( ) { int n = 2019 ; findNextNumber ( n ) ; return 0 ; }",Find Next number having distinct digits from the given number N.
241,"Find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is equal to N | C ++ program for the above approach ; Function to find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is N ; Iterate over the range [ 0 , N7 ] ; Iterate over the range [ 0 , N5 ] ; Find the value of A ; If A is greater than or equal to 0 and divisible by 3 ; Otherwise , print - 1 ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { int A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { cout << "" A ▁ = ▁ "" << A / 3 << "" , ▁ B ▁ = ▁ "" << B << "" , ▁ C ▁ = ▁ "" << C << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 19 ; CalculateValues ( 19 ) ; return 0 ; }","Find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is equal to N."
242,Minimize total time taken by two persons to visit N cities such that none of them meet | C ++ program for the above approach ; Function to find the minimum time to visit all the cities such that both the person never meets ; Initialize sum as 0 ; Find the maximum element ; Traverse the array ; Increment sum by arr [ i ] ; Print maximum of 2 * T and sum ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumTime ( arr , N ) ; return 0 ; }",Minimize total time taken by two persons to visit N cities such that none of them meet.
243,"Lexicographically largest string possible by reversing substrings having even number of 1 s | C ++ program for the above approach ; Function to find the lexicographically maximum string by reversing substrings having even numbers of 1 s ; Store size of string ; Traverse the string ; Count the number of 1 s ; Stores the starting index ; Stores the end index ; Increment count , when 1 is encountered ; Traverse the remaining string ; Reverse the string from starting and end index ; Printing the string ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexicographicallyMax ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int beg = i ; int end = i ; if ( s [ i ] == '1' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } } reverse ( s . begin ( ) + beg , s . begin ( ) + end + 1 ) ; } cout << s << "" STRNEWLINE "" ; } int main ( ) { string S = ""0101"" ; lexicographicallyMax ( S ) ; return 0 ; }",Lexicographically largest string possible by reversing substrings having even number of 1 s.
244,Count maximum possible pairs from an array having sum K | C ++ program for the above approach ; Function to count the maximum number of pairs from given array with sum K ; Sort array in increasing order ; Stores the final result ; Initialize the left and right pointers ; Traverse array until start < end ; Decrement right by 1 ; Increment left by 1 ; Increment result and left pointer by 1 and decrement right pointer by 1 ; Print the result ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPairs ( int nums [ ] , int n , int k ) { sort ( nums , nums + n ) ; int result = 0 ; int start = 0 , end = n - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } cout << result << endl ; ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; maxPairs ( arr , n , K ) ; return 0 ; }",Count maximum possible pairs from an array having sum K.
245,"Count maximum possible pairs from an array having sum K | C ++ program for the above approach ; Function to find the maximum number of pairs with a sum K such that same element can 't be used twice ; Initialize a hashm ; Store the final result ; Iterate over the array nums [ ] ; Decrement its frequency in m and increment the result by 1 ; Increment its frequency by 1 if it is already present in m . Otherwise , set its frequency to 1 ; Print the result ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; void maxPairs ( vector < int > nums , int k ) { map < int , int > m ; int result = 0 ; for ( auto i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { m [ k - i ] = m [ k - i ] + 1 ; } } cout << result ; } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 4 } ; int K = 5 ; maxPairs ( arr , K ) ; }",Count maximum possible pairs from an array having sum K.
246,Print indices of array elements whose removal makes the sum of odd and even | C ++ program to implement the above approach ; Function to find indices of array elements whose removal makes the sum of odd and even indexed array elements equal ; Stores size of array ; Store prefix sum of odd index array elements ; Store prefix sum of even index array elements ; Update even [ 0 ] ; Traverse the given array ; Update odd [ i ] ; Update even [ i ] ; If the current index is an even number ; Update even [ i ] ; If the current index is an odd number ; Update odd [ i ] ; Check if at least one index found or not that satisfies the condition ; Store odd indices sum by removing 0 - th index ; Store even indices sum by removing 0 - th index ; If p and q are equal ; Traverse the array arr [ ] ; If i is an even number ; Update p by removing the i - th element ; Update q by removing the i - th element ; Update q by removing the i - th element ; Update p by removing the i - th element ; If odd index values sum is equal to even index values sum ; Set the find variable ; Print the current index ; If no index found ; Print not possible ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeIndicesToMakeSumEqual ( vector < int > & arr ) { int N = arr . size ( ) ; vector < int > odd ( N , 0 ) ; vector < int > even ( N , 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = 0 ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { cout << ""0 ▁ "" ; find = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = 1 ; cout << i << "" ▁ "" ; } } if ( ! find ) { cout << -1 ; } } int main ( ) { vector < int > arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; return 0 ; }",Print indices of array elements whose removal makes the sum of odd and even.
247,"Minimum removals required to make a given array Bitonic | C ++ program to implement the above approach ; Function to coutnt minimum array elements required to be removed to make an array bitonic ; left [ i ] : Stores the length of LIS up to i - th index ; right [ i ] : Stores the length of decreasing subsequence over the range [ i , N ] ; Calculate the length of LIS up to i - th index ; Traverse the array upto i - th index ; If arr [ j ] is less than arr [ i ] ; Update left [ i ] ; Calculate the length of decreasing subsequence over the range [ i , N ] ; Traverse right [ ] array ; If arr [ i ] is greater than arr [ j ] ; Update right [ i ] ; Stores length of the longest bitonic array ; Traverse left [ ] and right [ ] array ; Update maxLen ; Function to print minimum removals required to make given array bitonic ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void min_element_removal ( int arr [ ] , int N ) { vector < int > left ( N , 1 ) ; vector < int > right ( N , 1 ) ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { left [ i ] = max ( left [ i ] , left [ j ] + 1 ) ; } } } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ i ] > arr [ j ] ) { right [ i ] = max ( right [ i ] , right [ j ] + 1 ) ; } } } int maxLen = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxLen = max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } cout << ( N - maxLen ) << "" STRNEWLINE "" ; } void makeBitonic ( int arr [ ] , int N ) { if ( N == 1 ) { cout << ""0"" << endl ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) cout << ""0"" << endl ; else cout << ""1"" << endl ; return ; } min_element_removal ( arr , N ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makeBitonic ( arr , N ) ; return 0 ; }",Minimum removals required to make a given array Bitonic.
248,Count subarrays having an equal count of 0 s and 1 s segregated | C ++ program for the above approach ; Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together ; Stores the count of subarrays ; If current element is different from the next array element ; Increment count ; Count the frequency of 1 s and 0 s ; Increment count ; Print the final count ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } cout << ans << "" STRNEWLINE "" ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }",Count subarrays having an equal count of 0 s and 1 s segregated.
249,Count quadruples of given type from given array | C ++ program of the above approach ; lcount [ i ] [ j ] : Stores the count of i on left of index j ; rcount [ i ] [ j ] : Stores the count of i on right of index j ; Function to count unique elements on left and right of any index ; Find the maximum array element ; Calculate prefix sum of counts of each value ; Calculate suffix sum of counts of each value ; Function to count quadruples of the required type ; Driver Code,"#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; const int maxN = 2002 ; int lcount [ maxN ] [ maxN ] ; int rcount [ maxN ] [ maxN ] ; void fill_counts ( int a [ ] , int n ) { int i , j ; int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } memset ( lcount , 0 , sizeof ( lcount ) ) ; memset ( rcount , 0 , sizeof ( rcount ) ) ; for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } } int countSubsequence ( int a [ ] , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequence ( a , 7 ) ; return 0 ; }",Count quadruples of given type from given array.
250,Reduce string by removing outermost parenthesis from each primitive substring | C ++ program to implement the above approach ; Function to remove the outermost parentheses of every primitive substring from the given string ; Stores the resultant string ; Stores the count of opened parentheses ; Traverse the string ; If opening parenthesis is encountered and their count exceeds 0 ; Include the character ; If closing parenthesis is encountered and their count is less than count of opening parentheses ; Include the character ; Return the resultant string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOuterParentheses ( string S ) { string res ; int count = 0 ; for ( char c : S ) { if ( c == ' ( ' && count ++ > 0 ) res += c ; if ( c == ' ) ' && count -- > 1 ) res += c ; } return res ; } int main ( ) { string S = "" ( ( ) ( ) ) ( ( ) ) ( ) "" ; cout << removeOuterParentheses ( S ) ; }",Reduce string by removing outermost parenthesis from each primitive substring.
251,Length of longest subarray with increasing contiguous elements | C ++ implementation for the above approach ; Function to find the longest subarray with increasing contiguous elements ; Stores the length of required longest subarray ; Stores the length of length of longest such subarray from ith index ; If consecutive elements are increasing and differ by 1 ; Otherwise ; Update the longest subarray obtained so far ; Return the length obtained ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = max ( maxi , cnt ) ; i = j ; } return maxi ; } int main ( ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; cout << maxiConsecutiveSubarray ( arr , N ) ; return 0 ; }",Length of longest subarray with increasing contiguous elements.
252,Length of longest subsequence having sum of digits of each element as a Composite Number | C ++ implementation of the above approach ; Function to generate prime numbers using Sieve of Eratosthenes ; Set 0 and 1 as non - prime ; If p is a prime ; Set all multiples of p as non - prime ; Function to find the digit sum of a given number ; Stores the sum of digits ; Extract digits and add to the sum ; Return the sum of the digits ; Function to find the longest subsequence with sum of digits of each element equal to a composite number ; Calculate sum of digits of current array element ; If sum of digits equal to 1 ; If sum of digits is a prime ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int digitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number /= 10 ; } return sum ; } void longestCompositeDigitSumSubsequence ( int arr [ ] , int n ) { int count = 0 ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( ! prime [ res ] ) { count ++ ; } } cout << count << endl ; } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; longestCompositeDigitSumSubsequence ( arr , n ) ; return 0 ; }",Length of longest subsequence having sum of digits of each element as a Composite Number.
253,Sum of specially balanced nodes from a given Binary Tree | C ++ program for the above approach ; Structure of Binary Tree ; Function to create a new node ; Return the created node ; Function to insert a node in the tree ; Left insertion ; Right insertion ; Return the root node ; Function to find sum of specially balanced nodes in the Tree ; Base Case ; Find the left subtree sum ; Find the right subtree sum ; Condition of specially balanced node ; Condition of specially balanced node ; Return the sum ; Function to build the binary tree ; Form root node of the tree ; Insert nodes into tree ; Create a new Node ; Insert the node ; Return the root of the Tree ; Function to find the sum of specially balanced nodes ; Build Tree ; Stores the sum of specially balanced node ; Function Call ; Print required sum ; Driver Code ; Given nodes ; Given root ; Given path info of nodes from root ; Given node values ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newnode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } Node * insert ( string s , int i , int N , Node * root , Node * temp ) { if ( i == N ) return temp ; if ( s [ i ] == ' L ' ) root -> left = insert ( s , i + 1 , N , root -> left , temp ) ; else root -> right = insert ( s , i + 1 , N , root -> right , temp ) ; return root ; } int SBTUtil ( Node * root , int & sum ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ; int left = SBTUtil ( root -> left , sum ) ; int right = SBTUtil ( root -> right , sum ) ; if ( root -> left && root -> right ) { if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root -> data ; } } return left + right + root -> data ; } Node * build_tree ( int R , int N , string str [ ] , int values [ ] ) { Node * root = newnode ( R ) ; int i ; for ( i = 0 ; i < N - 1 ; i ++ ) { string s = str [ i ] ; int x = values [ i ] ; Node * temp = newnode ( x ) ; root = insert ( s , 0 , s . size ( ) , root , temp ) ; } return root ; } void speciallyBalancedNodes ( int R , int N , string str [ ] , int values [ ] ) { Node * root = build_tree ( R , N , str , values ) ; int sum = 0 ; SBTUtil ( root , sum ) ; cout << sum << "" ▁ "" ; } int main ( ) { int N = 7 ; int R = 12 ; string str [ N - 1 ] = { "" L "" , "" R "" , "" RL "" , "" RR "" , "" RLL "" , "" RLR "" } ; int values [ N - 1 ] = { 17 , 16 , 4 , 9 , 2 , 3 } ; speciallyBalancedNodes ( R , N , str , values ) ; return 0 ; }",Sum of specially balanced nodes from a given Binary Tree.
254,Pair having all other given pairs lying between its minimum and maximum | C ++ program for the above approach ; Function to find the position of the pair that covers every pair in the array arr [ ] [ ] ; Stores the index of the resultant pair ; To count the occurences ; Iterate to check every pair ; Set count to 0 ; Condition to checked for overlapping of pairs ; If that pair can cover all other pairs then store its position ; If position not found ; Otherwise ; Driver Code ; Given array of pairs ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == -1 ) { cout << pos ; } else { cout << pos + 1 ; } } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }",Pair having all other given pairs lying between its minimum and maximum.
255,"Pair having all other given pairs lying between its minimum and maximum | C ++ program for the above approach ; Function to find the position of the pair that covers every pair in the array arr [ ] [ ] ; Position to store the index ; Stores the maximum second value ; Stores the minimum first value ; Iterate over the array of pairs ; Update right maximum ; Update left minimum ; Iterate over the array of pairs ; If any pair exists with value { left , right } then store it ; Print the answer ; Driver Code ; Given array of pairs ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int right = INT_MIN ; int left = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] > right ) { right = arr [ i ] [ 1 ] ; } if ( arr [ i ] [ 0 ] < left ) { left = arr [ i ] [ 0 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] == left && arr [ i ] [ 1 ] == right ) { pos = i + 1 ; } } cout << pos << endl ; } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }",Pair having all other given pairs lying between its minimum and maximum.
256,Minimize count of given operations required to make two given strings permutations of each other | C ++ program to implement the above approach ; Function to minimize the count of operations to make str1 and str2 permutations of each other ; Store the frequency of each character of str1 ; Store the frequency of each character of str2 ; Traverse the freq1 [ ] and freq2 [ ] ; If frequency of character in str1 is greater than str2 ; Otherwise ; Store sum of freq1 [ ] ; Store sum of freq2 [ ] ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ; int freq1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int freq2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return max ( sum1 , sum2 ) ; } int main ( ) { string str1 = "" geeksforgeeks "" ; string str2 = "" geeksforcoder "" ; cout << ctMinEdits ( str1 , str2 ) ; }",Minimize count of given operations required to make two given strings permutations of each other.
257,"Count pairs ( i , j ) from arrays arr [ ] & brr [ ] such that arr [ i ] | C ++ program for the above approach ; Function to count the pairs such that given condition is satisfied ; Stores the sum of element at each corresponding index ; Find the sum of each index of both array ; Stores frequency of each element present in sumArr ; Initialize number of pairs ; Add possible vaid pairs ; Return Number of Pairs ; Driver Code ; Given array arr [ ] and brr [ ] ; Size of given array ; Function calling","#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int * a , int * b , int n ) { int C [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } map < int , int > freqCount ; for ( int i = 0 ; i < n ; i ++ ) { freqCount [ C [ i ] ] ++ ; } int NoOfPairs = 0 ; for ( auto x : freqCount ) { int y = x . second ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } cout << NoOfPairs ; } int main ( ) { int arr [ ] = { 1 , 4 , 20 , 3 , 10 , 5 } ; int brr [ ] = { 9 , 6 , 1 , 7 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; CountPairs ( arr , brr , N ) ; return 0 ; }","Count pairs ( i , j ) from arrays arr [ ] & brr [ ] such that arr [ i ]."
258,Change in Median of given array after deleting given elements | C ++ program for the above approach ; Function to find the median change after removing elements from arr2 [ ] ; To store the median ; If N is odd ; If N is even ; Find the current element in arr1 ; Erase the element ; Decrement N ; If N is odd ; If N is even ; Print the corresponding difference of median ; Driven Code ; Given arrays ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) { int N = arr1 . size ( ) ; vector < float > median ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } for ( auto & x : arr2 ) { auto it = find ( arr1 . begin ( ) , arr1 . end ( ) , x ) ; arr1 . erase ( it ) ; N -- ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { cout << median [ i + 1 ] - median [ i ] << ' ▁ ' ; } } int main ( ) { vector < int > arr1 = { 2 , 4 , 6 , 8 , 10 } ; vector < int > arr2 = { 4 , 6 } ; medianChange ( arr1 , arr2 ) ; return 0 ; }",Change in Median of given array after deleting given elements.
259,"NFA to accept strings that has atleast one character occurring in a multiple of 3 | C ++ implementation of the above approach ; NFA variable that keeps track of the state while transaction . ; This checks for invalid input . ; Function for the state Q2 ; State transitions ' a ' takes to Q4 , and ' b ' and ' c ' remain at Q2 ; Function for the state Q3 ; State transitions ' a ' takes to Q3 , and ' b ' and ' c ' remain at Q4 ; Function for the state Q4 ; State transitions ' a ' takes to Q2 , and ' b ' and ' c ' remain at Q3 ; Function for the state Q5 ; State transitions ' b ' takes to Q6 , and ' a ' and ' c ' remain at Q5 ; Function for the state Q6 ; State transitions ' b ' takes to Q7 , and ' a ' and ' c ' remain at Q7 ; Function for the state Q7 ; State transitions ' b ' takes to Q5 , and ' a ' and ' c ' remain at Q7 ; Function for the state Q8 ; State transitions ' c ' takes to Q9 , and ' a ' and ' b ' remain at Q8 ; Function for the state Q9 ; State transitions ' c ' takes to Q10 , and ' a ' and ' b ' remain at Q9 ; Function for the state Q10 ; State transitions ' c ' takes to Q8 , and ' a ' and ' b ' remain at Q10 ; Function to check for 3 a 's ; Function to check for 3 b 's ; Function to check for 3 c 's ; Driver Code ; If any of the states is true , that is , if either the number of a ' s ▁ or ▁ number ▁ of ▁ b ' s or number of c 's  is a multiple of three, then the string is accepted","#include <bits/stdc++.h> NEW_LINE int nfa = 1 ; int flag = 0 ; using namespace std ; void state1 ( char c ) { if ( c == ' a ' ) nfa = 2 ; else if ( c == ' b ' c == ' c ' ) nfa = 1 ; else flag = 1 ; } void state2 ( char c ) { if ( c == ' a ' ) nfa = 3 ; else if ( c == ' b ' c == ' c ' ) nfa = 2 ; else flag = 1 ; } void state3 ( char c ) { if ( c == ' a ' ) nfa = 1 ; else if ( c == ' b ' c == ' c ' ) nfa = 3 ; else flag = 1 ; } void state4 ( char c ) { if ( c == ' b ' ) nfa = 5 ; else if ( c == ' a ' c == ' c ' ) nfa = 4 ; else flag = 1 ; } void state5 ( char c ) { if ( c == ' b ' ) nfa = 6 ; else if ( c == ' a ' c == ' c ' ) nfa = 5 ; else flag = 1 ; } void state6 ( char c ) { if ( c == ' b ' ) nfa = 4 ; else if ( c == ' a ' c == ' c ' ) nfa = 6 ; else flag = 1 ; } void state7 ( char c ) { if ( c == ' c ' ) nfa = 8 ; else if ( c == ' b ' c == ' a ' ) nfa = 7 ; else flag = 1 ; } void state8 ( char c ) { if ( c == ' c ' ) nfa = 9 ; else if ( c == ' b ' c == ' a ' ) nfa = 8 ; else flag = 1 ; } void state9 ( char c ) { if ( c == ' c ' ) nfa = 7 ; else if ( c == ' b ' c == ' a ' ) nfa = 9 ; else flag = 1 ; } bool checkA ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } } bool checkB ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } } bool checkC ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } } int main ( ) { string s = "" bbbca "" ; int x = 5 ; if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { cout << "" ACCEPTED "" ; } else { if ( flag == 0 ) { cout << "" NOT ▁ ACCEPTED "" ; return 0 ; } else { cout << "" INPUT ▁ OUT ▁ OF ▁ DICTIONARY . "" ; return 0 ; } } }",NFA to accept strings that has atleast one character occurring in a multiple of 3.
260,Count positions such that all elements before it are greater | C ++ Program to count positions such that all elements before it are greater ; Function to count positions such that all elements before it are greater ; Count is initially 1 for the first element ; Initial Minimum ; Traverse the array ; If current element is new minimum ; Update minimum ; Increment count ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; } int main ( ) { int a [ ] = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getPositionCount ( a , n ) ; return 0 ; }",Count positions such that all elements before it are greater.
261,Maximum length L such that the sum of all subarrays of length L is less than K | C ++ implementation of the approach ; Function to return the maximum sum in a subarray of size k ; k must be greater ; Compute sum of first window of size k ; Compute sums of remaining windows by removing first element of previous window and adding last element of current window . ; Function to return the length of subarray Sum of all the subarray of this length is less than or equal to K ; Binary search from l to r as all the array elements are positive so that the maximum subarray sum is monotonically increasing ; Check if the subarray sum is greater than K or not ; Update the maximum length ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n , int k ) { if ( n < k ) { return -1 ; } int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ; int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = max ( res , curr_sum ) ; } return res ; } int solve ( int arr [ ] , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 10 ; cout << solve ( arr , n , k ) ; return 0 ; }",Maximum length L such that the sum of all subarrays of length L is less than K.
262,Count of triplets in an array that satisfy the given conditions | C ++ implementation of the approach ; All possible solutions of the equation 1 / a + 1 / b + 1 / c = 1 ; Function to find the triplets ; Storing indices of the elements ; Check if y can act as the middle element of triplet with the given solution of 1 / a + 1 / b + 1 / c = 1 ; Binary search to find the number of possible values of the first element ; Binary search to find the number of possible values of the third element ; Contribution to the answer would be the multiplication of the possible values for the first and the third element ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define MAX  100001 NEW_LINE #define ROW  10 NEW_LINE #define COl  3 NEW_LINE vector < int > indices [ MAX ] ; int test [ ROW ] [ COl ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ; int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push_back ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; ll z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != -1 && third != -1 ) { answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; } int main ( ) { int array [ ] = { 2 , 4 , 5 , 6 , 7 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << find_triplet ( array , n ) ; return 0 ; }",Count of triplets in an array that satisfy the given conditions.
263,"Distinct adjacent elements in a binary array | C ++ implementation of the above approach ; if array has only one element , return 1 ; For first element compare with only next element ; For remaining elements compare with both prev and next elements ; For last element compare with only prev element ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinct ( int arr [ ] , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distinct ( arr , n ) ; return 0 ; }",Distinct adjacent elements in a binary array.
264,Check if an array of pairs can be sorted by swapping pairs with different first elements | C ++ program for the above approach ; Function to check if an array is sorted or not ; Traverse the array arr [ ] ; Return true ; Function to check if it is possible to sort the array w . r . t . first element ; Stores the ID of the first element ; Traverse the array arr [ ] ; If arr [ i ] . second is not equal to that of the group ; If array is sorted ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSorted ( pair < int , int > * arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . first > arr [ i - 1 ] . first ) { return false ; } } return true ; } string isPossibleToSort ( pair < int , int > * arr , int N ) { int group = arr [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . second != group ) { return "" Yes "" ; } } if ( isSorted ( arr , N ) ) { return "" Yes "" ; } else { return "" No "" ; } } int main ( ) { pair < int , int > arr [ ] = { { 340000 , 2 } , { 45000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << isPossibleToSort ( arr , N ) ; return 0 ; }",Check if an array of pairs can be sorted by swapping pairs with different first elements.
265,Find the Alpha Score of the Given Steps ( Using BST ) | C ++ program to implement the above approach ; Structure of a node ; Function to calculate and return the Alpha Score of the journey ; Traverse left subtree ; Calculate the alpha score of the current step ; Update alpha score of the journey ; Traverse right subtree ; Return ; Function to construct a BST from the sorted array arr [ ] ; Insert root ; Construct left subtree ; Construct right subtree ; Return root ; Driver Code ; Sort the array ; Construct BST from the sorted array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ; struct Node { Node * left , * right ; int data ; Node ( int x ) { data = x ; left = NULL ; right = NULL ; } } ; long getAlphaScore ( Node * node ) { if ( node -> left != NULL ) getAlphaScore ( node -> left ) ; sum = ( sum + node -> data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node -> right != NULL ) getAlphaScore ( node -> right ) ; return total_sum ; } Node * constructBST ( int arr [ ] , int start , int end , Node * root ) { if ( start > end ) return NULL ; int mid = ( start + end ) / 2 ; if ( root == NULL ) root = new Node ( arr [ mid ] ) ; root -> left = constructBST ( arr , start , mid - 1 , root -> left ) ; root -> right = constructBST ( arr , mid + 1 , end , root -> right ) ; return root ; } int main ( ) { int arr [ ] = { 10 , 11 , 12 } ; int length = 3 ; sort ( arr , arr + length ) ; Node * root = NULL ; root = constructBST ( arr , 0 , length - 1 , root ) ; cout << ( getAlphaScore ( root ) ) ; }",Find the Alpha Score of the Given Steps ( Using BST ).
266,Sorting element of an array by frequency in decreasing order | C ++ program to sort an array in decreasing order of their frequency ; Function that return the index upto all the array elements are updated . ; Initialise maxE = - 1 ; Find the maximum element of arr [ ] ; Create frequency array freq [ ] ; Update the frequency array as per the occurrence of element in arr [ ] ; Initialise cnt to 0 ; Traversing freq [ ] ; If freq of an element is greater than 0 update the value of arr [ ] at index cnt & increment cnt ; Return cnt ; Function that print array arr [ ] elements in sorted order ; Traversing arr [ ] till index cnt ; Find frequency of elements ; Find value at index i ; Traversing till frequency to print value at index i ; Driver code ; Size of array arr [ ] ; Function call to get cnt ; Sort the arr [ ] in decreasing order ; Function that prints elements in decreasing order,"#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; int sortByFreq ( int * arr , int n ) { int maxE = -1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = max ( maxE , arr [ i ] ) ; } int freq [ maxE + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } void printSortedArray ( int * arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { cout << value << ' ▁ ' ; } } } int main ( ) { int arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int cnt = sortByFreq ( arr , n ) ; sort ( arr , arr + cnt , greater < int > ( ) ) ; printSortedArray ( arr , cnt ) ; return 0 ; }",Sorting element of an array by frequency in decreasing order.
267,Check if N rectangles of equal area can be formed from ( 4 * N ) integers | C ++ implementation of the approach ; Function to check whether we can make n rectangles of equal area ; Sort the array ; Find the area of any one rectangle ; Check whether we have two equal sides for each rectangle and that area of each rectangle formed is the same ; Update the answer to false if any condition fails ; If possible ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkRectangles ( int * arr , int n ) { bool ans = true ; sort ( arr , arr + 4 * n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Check if N rectangles of equal area can be formed from ( 4 * N ) integers.
268,Count of elements which are not at the correct position | C ++ implementation of the approach ; Function to return the count of elements which are not in the correct position when sorted ; To store a copy of the original array ; Copy the elements of the given array to the new array ; To store the required count ; Sort the original array ; If current element was not at the right position ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int copy_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntElements ( arr , n ) ; return 0 ; }",Count of elements which are not at the correct position.
269,Find k ordered pairs in array with minimum difference d | C ++ implementation of the approach ; Function to find the required pairs ; There has to be atleast 2 * k elements ; To store the pairs ; Sort the given array ; For every possible pair ; If the current pair is valid ; Insert it into the pair vector ; If k pairs are not possible ; Print the pairs ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr [ ] , int n , int k , int d ) { if ( n < 2 * k ) { cout << -1 ; return ; } vector < pair < int , int > > pairs ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ n - k + i ] - arr [ i ] >= d ) { pair < int , int > p = make_pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . push_back ( p ) ; } } if ( pairs . size ( ) < k ) { cout << -1 ; return ; } for ( auto v : pairs ) { cout << "" ( "" << v . first << "" , ▁ "" << v . second << "" ) "" << endl ; } } int main ( ) { int arr [ ] = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; return 0 ; }",Find k ordered pairs in array with minimum difference d.
270,Count pairs with given sum | Set 2 | C ++ implementation of the approach ; Function to return the count of pairs from arr [ ] with the given sum ; To store the count of pairs ; Sort the given array ; Take two pointers ; If sum is greater ; If sum is lesser ; If sum is equal ; Find the frequency of arr [ i ] ; Find the frequency of arr [ j ] ; If arr [ i ] and arr [ j ] are same then remove the extra number counted ; Return the required answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j and arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i and arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , 5 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << pairs_count ( arr , n , sum ) ; return 0 ; }",Count pairs with given sum.
271,"Check if the string contains consecutive letters and each letter occurs exactly once | C ++ program to implement the above approach ; For all the characters of the string ; Find the ascii value of the character ; Check if if its a valid character , if not then return false ; Calculate sum of all the characters ascii values ; Find minimum ascii value from the string ; Find maximum ascii value from the string ; To get the previous element of the minimum ASCII value ; Take the expected sum from the above equation ; Check if the expected sum is equals to the calculated sum or not ; Driver code ; 1 st example ; 2 nd example","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str ) { int min = INT_MAX ; int max = - INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int ascii = str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; } int main ( ) { string str = "" dcef "" ; if ( check ( str ) ) cout << ( "" Yes "" ) ; else cout << ( "" No "" ) ; string str1 = "" xyza "" ; if ( check ( str1 ) ) cout << ( "" Yes "" else cout << ( "" No "" }",Check if the string contains consecutive letters and each letter occurs exactly once.
272,"k | C ++ implementation of the above approach ; Function to find the sum of minimum of all subarrays ; Insert all the elements in a set ; Find the maximum and minimum element ; Traverse from the minimum to maximum element ; Check if "" i "" is missing ; Check if it is kth missing ; If no kth element is missing ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findKth ( int arr [ ] , int n , int k ) { unordered_set < int > missing ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) missing . insert ( arr [ i ] ) ; int maxm = * max_element ( arr , arr + n ) ; int minm = * min_element ( arr , arr + n ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( missing . find ( i ) == missing . end ( ) ) count ++ ; if ( count == k ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 2 , 10 , 9 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << findKth ( arr , n , k ) ; return 0 ; }",k.
273,Sort Linked List containing values from 1 to N | C ++ program to sort linked list containing values from 1 to N ; A linked list node ; Function to sort linked list ; Function to add a node at the beginning of Linked List ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; This function prints contents of linked list starting from the given node ; Driver program to test above function ; The constructed linked list is : 3 -> 5 -> 4 -> 6 -> 1 -> 2,"#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool sortList ( struct Node * head ) { int startVal = 1 ; while ( head != NULL ) { head -> data = startVal ; startVal ++ ; head = head -> next ; } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << "" ▁ "" ; node = node -> next ; } } int main ( ) { struct Node * start = NULL ; push ( & start , 2 ) ; push ( & start , 1 ) ; push ( & start , 6 ) ; push ( & start , 4 ) ; push ( & start , 5 ) ; push ( & start , 3 ) ; sortList ( start ) ; printList ( start ) ; return 0 ; }",Sort Linked List containing values from 1 to N.
274,Check if linked list is sorted ( Iterative and Recursive ) | C ++ program to recursively check Linked List is sorted in descending order or not ; Linked list node ; function to Check Linked List is sorted in descending order or not ; Base cases ; Check first two nodes and recursively check remaining . ; Driver program to test above,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return true ; return ( head -> data > head -> next -> data && isSortedDesc ( head -> next ) ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Check if linked list is sorted ( Iterative and Recursive ).
275,Rearrange an array to minimize sum of product of consecutive pair elements | C ++ program to sort an array such that sum of product of alternate element is minimum . ; create evenArr [ ] and oddArr [ ] ; sort main array in ascending order ; Put elements in oddArr [ ] and evenArr [ ] as per desired value . ; sort evenArr [ ] in descending order ; merge both sub - array and calculate minimum sum of product of alternate elements ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) oddArr . push_back ( arr [ i ] ) ; else evenArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) , greater < int > ( ) ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Minimum ▁ required ▁ sum ▁ = ▁ "" << minSum ( arr , n ) ; cout << "" Sorted array in required format : "" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << "" ▁ "" ; return 0 ; }",Rearrange an array to minimize sum of product of consecutive pair elements.
276,Minimum time required to print given string from a circular container based on given conditions | C ++ implementation for the above approach ; Function to calculate minimum time to print all characters in the string ; Current element where the pointer is pointing ; Find index of that element ; Calculate absolute difference between pointer index and character index as clockwise distance ; Subtract clockwise time from 26 to get anti - clockwise time ; Add minimum of both times to the answer ; Add one unit time to print the character ; Print the final answer ; Driver code ; Given string word ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minTime ( string word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = word [ i ] - ' a ' ; int a = abs ( curr - k ) ; int b = 26 - abs ( curr - k ) ; ans += min ( a , b ) ; ans ++ ; curr = word [ i ] - ' a ' ; } cout << ans ; } int main ( ) { string str = "" zjpc "" ; minTime ( str ) ; return 0 ; }",Minimum time required to print given string from a circular container based on given conditions.
277,Minimum decrements or division by a proper divisor required to reduce N to 1 | C ++ program for the above approach ; Function to find the minimum number of steps required to reduce N to 1 ; Stores the number of steps required ; If the value of N is equal to 2 or N is odd ; Decrement N by 1 ; Increment cnt by 1 ; If N is even ; Update N ; Increment cnt by 1 ; Return the number of steps obtained ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int reduceToOne ( long long int N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 or ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; } int main ( ) { long long int N = 35 ; cout << reduceToOne ( N ) ; return 0 ; },Minimum decrements or division by a proper divisor required to reduce N to 1.
278,Maximum number of diamonds that can be gained in K minutes | C ++ program for the above approach ; Function to find the maximum number of diamonds that can be gained in exactly K minutes ; Stores all the array elements ; Push all the elements to the priority queue ; Stores the required result ; Loop while the queue is not empty and K is positive ; Store the top element from the pq ; Pop it from the pq ; Add it to the answer ; Divide it by 2 and push it back to the pq ; Print the answer ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDiamonds ( int A [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } int ans = 0 ; while ( ! pq . empty ( ) && K -- ) { int top = pq . top ( ) ; pq . pop ( ) ; ans += top ; top = top / 2 ; pq . push ( top ) ; } cout << ans ; } int main ( ) { int A [ ] = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maxDiamonds ( A , N , K ) ; return 0 ; }",Maximum number of diamonds that can be gained in K minutes.
279,Minimize cost of increments or decrements such that same indexed elements become multiple of each other | C ++ program for the above approach ; Function to find the minimum cost to make A [ i ] multiple of B [ i ] or vice - versa for every array element ; Stores the minimum cost ; Traverse the array ; Case 1 : Update A [ i ] ; Case 2 : Update B [ i ] ; Add the minimum of the above two cases ; Return the resultant cost ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = min ( mod_B , B [ i ] - mod_B ) ; totalCost += min ( totalCost_A , totalCost_B ) ; } return totalCost ; } int main ( ) { int A [ ] = { 3 , 6 , 3 } ; int B [ ] = { 4 , 8 , 13 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MinimumCost ( A , B , N ) ; return 0 ; }",Minimize cost of increments or decrements such that same indexed elements become multiple of each other.
280,Largest number divisible by 50 that can be formed from a given set of N digits consisting of 0 s and 7 s only | C ++ Program for the above approach ; Print the largest number divisible by 50 ; Counting number of 0 s and 7 s ; If count of 7 is divisible by 50 ; If count of 7 is less than 5 ; If count of 7 is not divisible by 50 ; Count of groups of 5 in which count of 7 s can be grouped ; Driver Code ; Given array ; Size of the array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLargestDivisible ( int arr [ ] , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 -- ) cout << 7 ; while ( count0 -- ) cout << 0 ; } else if ( count7 < 5 ) { if ( count0 == 0 ) cout << "" No "" ; else cout << ""0"" ; } else { count7 = count7 - count7 % 5 ; while ( count7 -- ) cout << 7 ; while ( count0 -- ) cout << 0 ; } } int main ( ) { int arr [ ] = { 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLargestDivisible ( arr , N ) ; return 0 ; }",Largest number divisible by 50 that can be formed from a given set of N digits consisting of 0 s and 7 s only.
281,"Rearrange array to maximize sum of GCD of array elements with their respective indices | C ++ program to implement the above approach ; Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array ; Sort the array in ascending order ; Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements ; Generate all possible permutations of the array ; Stores sum of GCD ( arr [ i ] , i ) ; Traverse the array ; Update sum ; Update res ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = max ( res , sum ) ; } while ( next_permutation ( arr , arr + N ) ) ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }",Rearrange array to maximize sum of GCD of array elements with their respective indices.
282,Minimum removals required to make frequency of each array element equal to its value | C ++ program to implement the above approach ; Function to find the minimum count of elements required to be removed such that frequency of arr [ i ] equal to arr [ i ] ; Stores frequency of each element of the array ; Traverse the array ; Update frequency of arr [ i ] ; Stores minimum count of removals ; Traverse the map ; Stores key value of the map ; If frequency of i is less than i ; Update cntMinRem ; If frequency of i is greater than i ; Update cntMinRem ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_elements ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int cntMinRem = 0 ; for ( auto it : mp ) { int i = it . first ; if ( mp [ i ] < i ) { cntMinRem += mp [ i ] ; } else if ( mp [ i ] > i ) { cntMinRem += ( mp [ i ] - i ) ; } } return cntMinRem ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_elements ( arr , N ) ; return 0 ; }",Minimum removals required to make frequency of each array element equal to its value.
283,Minimum increments to make all array elements equal with sum same as the given array after exactly one removal | C ++ program to implement the above approach ; Function to check if an array of equal elements with sum equal to the given array can be obtained or not ; Base case ; Stores sum of array elements ; Stores second largest array element ; Stores the largest array element ; Traverse the array ; Update secMax ; Update Max ; Update secMax ; Update totalSum ; If totalSum is less than secMax * ( N - 1 ) ) ; If totalSum is not divisible by ( N - 1 ) ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool CheckAllarrayEqual ( int arr [ ] , int N ) { if ( N == 1 ) { return true ; } int totalSum = arr [ 0 ] ; int secMax = INT_MIN ; int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) ) { return false ; } return true ; } int main ( ) { int arr [ ] = { 6 , 2 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( CheckAllarrayEqual ( arr , N ) ) { cout << "" YES "" ; } else { cout << "" NO "" ; } }",Minimum increments to make all array elements equal with sum same as the given array after exactly one removal.
284,"Count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element | C ++ program for the above approach ; Function to count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element ; Stores xor of odd and even indexed elements from the end ; Stores xor of odd and even indexed elements from the start ; Stores the required count ; Traverse the array in reverse ; If i is odd ; If i is even ; Traverse the array ; If i is odd ; If i is even ; Removing arr [ i ] , post_even stores XOR of odd indexed elements ; Removing arr [ i ] , post_odd stores XOR of even indexed elements ; Check if they are equal ; If i is odd , xor it with curr_odd ; If i is even , xor it with curr_even ; Finally print res ; Drivers Code ; Given array ; Given size ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Remove_one_element ( arr , N ) ; return 0 ; }",Count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element.
285,Count ways to make sum of odd and even indexed elements equal by removing an array element | C ++ program to implement the above approach ; Function to count array indices whose removal makes sum of odd and even indexed elements equal ; If size of the array is 1 ; If size of the array is 2 ; Stores sum of even - indexed elements of the given array ; Stores sum of odd - indexed elements of the given array ; Traverse the array ; If i is an even number ; Update sumEven ; If i is an odd number ; Update sumOdd ; Stores sum of even - indexed array elements till i - th index ; Stores sum of odd - indexed array elements till i - th index ; Stores count of indices whose removal makes sum of odd and even indexed elements equal ; Stores sum of even - indexed elements after removing the i - th element ; Stores sum of odd - indexed elements after removing the i - th element ; Traverse the array ; If i is an odd number ; Update currOdd ; Update newEvenSum ; Update newOddSum ; If i is an even number ; Update currEven ; Update newOddSum ; Update newEvenSum ; If newEvenSum is equal to newOddSum ; Increase the count ; If sum of even - indexed and odd - indexed elements is equal by removing the first element ; Increase the count ; If length of the array is an odd number ; If sum of even - indexed and odd - indexed elements is equal by removing the last element ; Increase the count ; If length of the array is an even number ; If sum of even - indexed and odd - indexed elements is equal by removing the last element ; Increase the count ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntIndexesToMakeBalance ( int arr [ ] , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntIndexesToMakeBalance ( arr , n ) ; return 0 ; }",Count ways to make sum of odd and even indexed elements equal by removing an array element.
286,"Find two numbers from their sum and XOR | Set 2 | C ++ program for the above approach ; Function to find the value of A and B whose sum is X and xor is Y ; Initialize the two numbers ; Case 1 : X < Y ; Case 2 : X - Y is odd ; Case 3 : If both Sum and XOR are equal ; Case 4 : If above cases fails ; Update the value of A ; Check if A & Y value is 0 ; If true , update B ; Otherwise assign - 1 to A , - 1 to B ; Print the numbers A and B ; Driver Code ; Given Sum and XOR of 2 numbers ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNums ( int X , int Y ) { int A , B ; if ( X < Y ) { A = -1 ; B = -1 ; } else if ( abs ( X - Y ) & 1 ) { A = -1 ; B = -1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = -1 ; B = -1 ; } } cout << A << "" ▁ "" << B ; } int main ( ) { int X = 17 , Y = 13 ; findNums ( X , Y ) ; return 0 ; }",Find two numbers from their sum and XOR.
287,Queries to check if count of increasing and decreasing subarrays is same in given range | C ++ program for the above approach ; Function to check if given range have equal number of increasing as well as decreasing subarrays ; Traverse each query ; For 0 - based indexing ; Condition for same count of increasing & decreasing subarray ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- , R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { cout << "" Yes STRNEWLINE "" ; } else { cout << "" No STRNEWLINE "" ; } } } int main ( ) { int arr [ ] = { 11 , 13 , 12 , 14 } ; int Q [ ] [ 2 ] = { { 1 , 4 } , { 2 , 4 } } ; int q = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; checkCount ( arr , Q , q ) ; return 0 ; }",Queries to check if count of increasing and decreasing subarrays is same in given range.
288,Mean of array generated by products of all pairs of the given array | C ++ program for the above approach ; Function to find the mean of pair product array of arr [ ] ; Store product of pairs ; Generate all unordered pairs ; Store product of pairs ; Size of pairArray ; Store sum of pairArray ; Stores the mean of pairArray [ ] ; Find mean of pairArray [ ] ; Return the resultant mean ; Driver Code ; Given array arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { vector < int > pairArray ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . push_back ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }",Mean of array generated by products of all pairs of the given array.
289,Find the player who is the last to remove any character from the beginning of a Binary String | C ++ program for the above approach ; Function to find the player who loses the game ; Moves for the first player ; Moves for the second player ; Iterate over array of strings ; Check if the first and last character are the same ; Check if string start and end with character '0' ; If first player have less moves ; Driver Code ; Given array of strings ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPlayer ( string str [ ] , int n ) { int move_first = 0 ; int move_sec = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . length ( ) - 1 ] ) { if ( str [ i ] [ 0 ] == 48 ) move_first ++ ; else move_sec ++ ; } } if ( move_first <= move_sec ) { cout << "" Player ▁ 2 ▁ wins "" ; } else { cout << "" Player ▁ 1 ▁ wins "" ; } } int main ( ) { string str [ ] = { ""010"" , ""101"" } ; int N = sizeof ( str ) / sizeof ( str [ 0 ] ) ; findPlayer ( str , N ) ; return 0 ; }",Find the player who is the last to remove any character from the beginning of a Binary String.
290,Smallest number exceeding N whose Kth bit is set | C ++ program for the above approach ; Function to find the number greater than n whose Kth bit is set ; Iterate from N + 1 ; Check if Kth bit is set or not ; Increment M for next number ; Return the minimum value ; Driver Code ; Given N and K ; Function Call,"#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; int find_next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1ll << k ) ) break ; M ++ ; } return M ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }",Smallest number exceeding N whose Kth bit is set.
291,Smallest number exceeding N whose Kth bit is set | C ++ program for the above approach ; Function to find the number greater than n whose Kth bit is set ; Stores the resultant number ; If Kth bit is not set ; cur will be the sum of all powers of 2 < k ; If the current bit is set ; Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set ; If the kth bit is set ; First unset bit position ; sum of bits that are set ; Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set ; If Kth bit became unset then set it again ; Return the resultant number ; Driver Code ; Print ans,"#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; int find_next ( int n , int k ) { int ans = 0 ; if ( ( n & ( 1ll << k ) ) == 0 ) { int cur = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( n & ( 1ll << i ) ) cur += 1ll << i ; } ans = n - cur + ( 1ll << k ) ; } else { int first_unset_bit = -1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( n & ( 1ll << i ) ) == 0 ) { first_unset_bit = i ; break ; } else cur += ( 1ll << i ) ; } ans = n - cur + ( 1ll << first_unset_bit ) ; if ( ( ans & ( 1ll << k ) ) == 0 ) ans += ( 1ll << k ) ; } return ans ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }",Smallest number exceeding N whose Kth bit is set.
292,Lexicographically largest possible String after removal of K characters | C ++ Program to implement the above approach ; final result string ; If the current char exceeds the character at the top of the stack ; Remove from the end of the string ; Decrease k for the removal ; Insert current character ; Perform remaining K deletions from the end of the string ; Return the string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestString ( string num , int k ) { string ans = "" "" ; for ( auto i : num ) { while ( ans . length ( ) && ans . back ( ) < i && k > 0 ) { ans . pop_back ( ) ; k -- ; } ans . push_back ( i ) ; } while ( ans . length ( ) and k -- ) { ans . pop_back ( ) ; } return ans ; } int main ( ) { string str = "" zyxedcba "" ; int k = 1 ; cout << largestString ( str , k ) << endl ; }",Lexicographically largest possible String after removal of K characters.
293,Maximum length of subarray consisting of same type of element on both halves of sub | C ++ program for the above approach ; Function that finds the maximum length of the sub - array that contains equal element on both halves of sub - array ; To store continuous occurence of the element ; To store continuous forward occurence ; To store continuous backward occurence ; To store the maximum length ; Find maximum length ; Print the result ; Driver Code ; Given array ; Size of the array ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLengthSubArray ( int A [ ] , int N ) { int forward [ N ] , backward [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxLengthSubArray ( arr , N ) ; return 0 ; }",Maximum length of subarray consisting of same type of element on both halves of sub.
294,Smallest N digit number divisible by all possible prime digits | C ++ implementation of the above approach ; Function to find the minimum number of n digits divisible by all prime digits ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; } int main ( ) { int n = 5 ; minNum ( n ) ; return 0 ; }",Smallest N digit number divisible by all possible prime digits.
295,Smallest number greater than Y with sum of digits equal to X | C ++ program for the above approach ; Function to return the minimum string of length d having the sum of digits s ; Return a string of length d ; Greedily put 9 's in the end ; Put remaining sum ; Function to find the smallest number greater than Y whose sum of digits is X ; Convert number y to string ; Maintain prefix sum of digits ; Iterate over Y from the back where k is current length of suffix ; Stores current digit ; Increase current digit ; Sum upto current prefix ; Return answer if remaining sum can be obtained in suffix ; Find suffix of length k having sum of digits x - r ; Append current character ; Return the result ; Driver Code ; Given Number and Sum ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string helper ( int d , int s ) { string ans ( d , '0' ) ; for ( int i = d - 1 ; i >= 0 ; i -- ) { if ( s >= 9 ) { ans [ i ] = '9' ; s -= 9 ; } else { char c = ( char ) s + '0' ; ans [ i ] = c ; s = 0 ; } } return ans ; } string findMin ( int x , int Y ) { string y = to_string ( Y ) ; int n = y . size ( ) ; vector < int > p ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = y [ i ] - '0' ; if ( i > 0 ) p [ i ] += p [ i - 1 ] ; } for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) { int d = 0 ; if ( i >= 0 ) d = y [ i ] - '0' ; for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = ( i > 0 ) * p [ i - 1 ] + j ; if ( x - r >= 0 and x - r <= 9 * k ) { string suf = helper ( k , x - r ) ; string pre = "" "" ; if ( i > 0 ) pre = y . substr ( 0 , i ) ; char cur = ( char ) j + '0' ; pre += cur ; return pre + suf ; } } } } int main ( ) { int x = 18 ; int y = 99 ; cout << findMin ( x , y ) << endl ; return 0 ; }",Smallest number greater than Y with sum of digits equal to X.
296,"Largest number made up of X and Y with count of X divisible by Y and of Y by X | C ++ program to implement the above approach ; Function to generate and return the largest number ; Store the smaller in Y ; Store the larger in X ; Stores respective counts ; If N is divisible by Y ; Append X , N times to the answer ; Reduce N to zero ; Reduce N by X ; Append Y , X times to the answer ; If number can be formed ; Otherwise ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestNumber ( int n , int X , int Y ) { int maxm = max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) cout << X ; while ( Ys -- > 0 ) cout << Y ; } else cout << "" - 1"" ; } int main ( ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; return 0 ; }",Largest number made up of X and Y with count of X divisible by Y and of Y by X.
297,Minimum flips required to generate continuous substrings of 0 â €™ s and 1 â €™ s | C ++ implementation of the above approach ; Traverse input string and store the count of 0 ; Traverse the input string again to find minimum number of flips ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChanges ( string str , int N ) { int res ; int count0 = 0 , count1 = 0 ; for ( char x : str ) { count0 += ( x == '0' ) ; } res = count0 ; for ( char x : str ) { count0 -= ( x == '0' ) ; count1 += ( x == '1' ) ; res = min ( res , count1 + count0 ) ; } return res ; } int main ( ) { int N = 9 ; string str = ""000101001"" ; cout << minChanges ( str , N ) ; return 0 ; }",Minimum flips required to generate continuous substrings of 0 â €™ s and 1 â €™ s.
298,Missing occurrences of a number in an array such that maximum absolute difference of adjacent elements is minimum | C ++ implementation of the missing number such that maximum absolute difference between adjacent element is minimum ; Function to find the missing number such that maximum absolute difference is minimum ; Loop to find the maximum and minimum adjacent element to missing number ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingnumber ( int n , int arr [ ] ) { int mn = INT_MAX , mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == -1 && arr [ i - 1 ] != -1 ) { mn = min ( mn , arr [ i - 1 ] ) ; mx = max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { mn = min ( mn , arr [ i + 1 ] ) ; mx = max ( mx , arr [ i + 1 ] ) ; } } long long int res = ( mx + mn ) / 2 ; return res ; } int main ( ) { int n = 5 ; int arr [ 5 ] = { -1 , 10 , -1 , 12 , -1 } ; int ans = 0 ; int res = missingnumber ( n , arr ) ; cout << res ; return 0 ; }",Missing occurrences of a number in an array such that maximum absolute difference of adjacent elements is minimum.
299,"Maximize [ length ( X ) / 2 ^ ( XOR ( X , Y ) ) ] by choosing substrings X and Y from string A and B respectively | C ++ program for the above approach ; Function to find the length of the longest common substring of the string X and Y ; LCSuff [ i ] [ j ] stores the lengths of the longest common suffixes of substrings ; Itearate over strings A and B ; If first row or column ; If matching is found ; Otherwise , if matching is not found ; Finally , return the resultant maximum value LCS ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCSubStr ( char * A , char * B , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; } int main ( ) { char A [ ] = ""0110"" ; char B [ ] = ""1101"" ; int M = strlen ( A ) ; int N = strlen ( B ) ; cout << LCSubStr ( A , B , M , N ) ; return 0 ; }","Maximize [ length ( X ) / 2 ^ ( XOR ( X , Y ) ) ] by choosing substrings X and Y from string A and B respectively."
300,Count ways to split array into pair of subsets with difference between their sum equal to K | C ++ program for the above approach ; To store the states of DP ; Function to find count of subsets with a given sum ; Base case ; If an already computed subproblem occurs ; Set the state as solved ; Recurrence relation ; Function to count ways to split array into pair of subsets with difference K ; Store the total sum of element of the array ; Traverse the array ; Calculate sum of array elements ; Store the required sum ; Print the number of subsets with sum equal to S1 ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxSum  50 NEW_LINE #define minSum  50 NEW_LINE #define base  50 NEW_LINE int dp [ maxN ] [ maxSum + minSum ] ; bool v [ maxN ] [ maxSum + minSum ] ; int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; } void countSubsets ( int * arr , int K , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int S1 = ( sum + K ) / 2 ; cout << findCnt ( arr , 0 , S1 , n ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 1 ; countSubsets ( arr , K , N ) ; return 0 ; }",Count ways to split array into pair of subsets with difference between their sum equal to K.
301,Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers | C ++ program for above approach ; Function to calculate the probability for the given sum to be equal to sum in N throws of dice ; Base cases ; Driver Code ; Calculate probability of all sums from a to b ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }",Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers.
302,Minimum steps to reduce N to 0 by given operations | C ++ program for the above approach ; Function to find the minimum number to steps to reduce N to 0 ; Dictionary for storing the precomputed sum ; Bases Cases ; Check if n is not in dp then only call the function so as to reduce no of recursive calls ; Return the answer ; Driver Code ; Given number N ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { map < int , int > dp ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; if ( ( dp . find ( n ) == dp . end ( ) ) ) dp [ n ] = 1 + min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ; return dp [ n ] ; } int main ( ) { int N = 6 ; cout << count ( N ) ; }",Minimum steps to reduce N to 0 by given operations.
303,Minimum count of increment of K size subarrays required to form a given Array | C ++ implementation to find the minimum number of operations required to change an array of all zeros such that every element is greater than the given array ; Function to find the minimum number of operations required to change all the array of zeros such that every element is greater than the given array ; Declaring the difference array of size N ; Number of operations ; First update the D [ i ] value with the previous value ; The index i has to be incremented ; We have to perform ( b [ i ] - d [ i ] ) operations more ; Increment the range i to i + k by need ; Check if i + k is valid index ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_minimum_operations ( int n , int b [ ] , int k ) { int d [ n + 1 ] = { 0 } ; int operations = 0 , need ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } cout << operations << endl ; } int main ( ) { int n = 5 ; int b [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ; find_minimum_operations ( n , b , k ) ; return 0 ; }",Minimum count of increment of K size subarrays required to form a given Array.
304,"Number of ways of cutting a Matrix such that atleast one cell is filled in each part | CPP implementation to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell ; Function to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell ; Loop to find prefix sum of the given matrix ; dp ( r , c , 1 ) = 1 if preSum [ r ] else 0 ; Loop to iterate over the dp table of the given matrix ; Check if can cut horizontally at r1 , at least one apple in matrix ( r , c ) -> r1 , C - 1 ; Check if we can cut vertically at c1 , at least one apple in matrix ( r , c ) -> R - 1 , c1 ; Driver code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int ways ( vector < vector < int > > & arr , int K ) { int R = arr . size ( ) ; int C = arr [ 0 ] . size ( ) ; int preSum [ R ] [ C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } int dp [ K + 1 ] [ R ] [ C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; } int main ( ) { vector < vector < int > > arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ; cout << ways ( arr , k ) << endl ; return 0 ; }",Number of ways of cutting a Matrix such that atleast one cell is filled in each part.
305,"Product of all sorted subsets of size K using elements whose index divide K completely | C ++ implementation of the above approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; If y is odd , multiply x with result ; y must be even now ; Iterative Function to calculate ( nCr ) % p and save in f [ n ] [ r ] ; If j > i then C ( i , j ) = 0 ; If iis equal to j then C ( i , j ) = 1 ; Function calculate the Final answer ; Initialize ans ; x is count of occurence of arr [ i ] in different set such that index of arr [ i ] in those sets divides K completely . ; Finding the count of arr [ i ] by placing it at index which divides K completely ; By Fermat 's theorem ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int p = 1000000007 ; long long int power ( long long int x , long long int y , long long int p ) { long long int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } void nCr ( long long int n , long long int p , int f [ ] [ 100 ] , int m ) { for ( long long int i = 0 ; i <= n ; i ++ ) { for ( long long int j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i ] [ j ] = 0 ; } else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } } void ProductOfSubsets ( int arr [ ] , int n , int m ) { int f [ n + 1 ] [ 100 ] ; nCr ( n , p - 1 , f , m ) ; sort ( arr , arr + n ) ; long long int ans = 1 ; for ( long long int i = 0 ; i < n ; i ++ ) { long long int x = 0 ; for ( long long int j = 1 ; j <= m ; j ++ ) { if ( m % j == 0 ) { x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } cout << ans << endl ; } int main ( ) { int arr [ ] = { 4 , 5 , 7 , 9 , 3 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ProductOfSubsets ( arr , N , K ) ; return 0 ; }",Product of all sorted subsets of size K using elements whose index divide K completely.
306,Number of ways to write N as a sum of K non | C ++ program for the above approach ; Function to count the number of ways to write N as sum of k non - negative integers ; Initialise dp [ ] [ ] array ; Only 1 way to choose the value with sum K ; Initialise sum ; Count the ways from previous states ; Update the sum ; Return the final count of ways ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }",Number of ways to write N as a sum of K non.
307,"Number of ways to write N as a sum of K non | C ++ program for the above approach ; Function to count the number of ways to write N as sum of k non - negative integers ; Initialise dp [ ] [ ] array ; Fill the dp [ ] [ ] with sum = m ; Iterate the dp [ ] [ ] to fill the dp [ ] [ ] array ; Condition for first column ; Else fill the dp [ ] [ ] with sum till ( i , j ) ; If reach the end , then return the value ; Update at current index ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }",Number of ways to write N as a sum of K non.
308,Longest subsequence such that every element in the subsequence is formed by multiplying previous element with a prime | C ++ program to implement the above approach ; Function to pre - store primes ; Sieve method to check if prime or not ; Multiples ; Pre - store all the primes ; Function to find the longest subsequence ; Hash map ; Call the function to pre - store the primes ; Initialize last element with 1 as that is the longest possible ; Iterate from the back and find the longest ; Get the number ; Initialize dp [ i ] as 1 as the element will only me in the subsequence . ; Iterate in all the primes and multiply to get the next element ; Next element if multiplied with it ; If exceeds the last element then break ; If the number is there in the array ; Get the maximum most element ; Hash the element ; Find the longest ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int MAX , vector < int > & primes ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( long long p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( long long i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( long long i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . push_back ( i ) ; } } int findLongest ( int A [ ] , int n ) { unordered_map < int , int > mpp ; vector < int > primes ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; dp [ n - 1 ] = 1 ; mpp [ A [ n - 1 ] ] = n - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int num = A [ i ] ; dp [ i ] = 1 ; int maxi = 0 ; for ( auto it : primes ) { int xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp [ xx ] != 0 ) { dp [ i ] = max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; } } mpp [ A [ i ] ] = i ; } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , dp [ i ] ) ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findLongest ( a , n ) ; }",Longest subsequence such that every element in the subsequence is formed by multiplying previous element with a prime.
309,"Number of Binary Strings of length N with K adjacent Set Bits | C ++ program to find the number of Bit Strings of length N with K adjacent set bits ; Function to find the number of Bit Strings of length N with K adjacent set bits ; Base Case when we form bit string of length n ; if f ( bit string ) = k , count this way ; Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset ; set the bit at currentIndex ; unset the bit at currentIndex ; Driver Code ; total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )","#include <bits/stdc++.h> NEW_LINE using namespace std ; int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; } int main ( ) { int n = 5 , k = 2 ; int totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; cout << "" Number ▁ of ▁ ways ▁ = ▁ "" << totalWays << "" STRNEWLINE "" ; return 0 ; }",Number of Binary Strings of length N with K adjacent Set Bits.
310,Sum of products of all combination taken ( 1 to n ) at a time | CPP Program to find sum of all combination takne ( 1 to N ) at a time using dynamic programming ; find the postfix sum array ; modify the array such that we don 't have to compute the products which are obtained before ; finding sum of all combination taken 1 to N at a time ; sum taken 1 at time is simply sum of 1 - N ; for sum of products for all combination ; finding postfix array ; sum of products taken i + 1 at a time ; modify the array for overlapping problem ; Driver 's Code ; storing numbers from 1 to N ; calling allCombination,"#include <iostream> NEW_LINE using namespace std ; void postfix ( int a [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } void modify ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) a [ i - 1 ] = i * a [ i ] ; } void allCombination ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i ; cout << "" f ( 1 ) ▁ - - > ▁ "" << sum << "" STRNEWLINE "" ; for ( int i = 1 ; i < n ; i ++ ) { postfix ( a , n - i + 1 ) ; sum = 0 ; for ( int j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } cout << "" f ( "" << i + 1 << "" ) ▁ - - > ▁ "" << sum << "" STRNEWLINE "" ; modify ( a , n ) ; } } int main ( ) { int n = 5 ; int * a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; allCombination ( a , n ) ; return 0 ; }",Sum of products of all combination taken ( 1 to n ) at a time.
311,"Count ways to reach the nth stair using step 1 , 2 or 3 | C ++ Program to find n - th stair using step size 1 or 2 or 3. ; Returns count of ways to reach n - th stair using 1 or 2 or 3 steps . ; Driver code",#include <iostream> NEW_LINE using namespace std ; class GFG { public : int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } } ; int main ( ) { GFG g ; int n = 4 ; cout << g . findStep ( n ) ; return 0 ; },"Count ways to reach the nth stair using step 1 , 2 or 3."
312,"Partition problem | DP | A recursive C ++ program for partition problem ; A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of the elements in array ; If sum is odd , there cannot be two subsets with equal sum ; Find if there is subset with sum equal to half of total sum ; Driver code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSubsetSum ( arr , n , sum / 2 ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ "" "" of ▁ equal ▁ sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets "" "" ▁ of ▁ equal ▁ sum "" ; return 0 ; }",Partition problem.
313,"Partition problem | DP | A Dynamic Programming based C ++ program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; Initialize the part array as 0 ; Fill the partition table in bottom up manner ; the element to be included in the sum cannot be greater than the sum ; j -- ) { check if sum - arr [ i ] could be formed from a subset using elements before index i ; Driver Code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ "" "" sum "" ; else cout << "" Can ▁ not ▁ be ▁ divided ▁ into "" << "" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum "" ; return 0 ; }",Partition problem.
314,Binomial Coefficient | DP | C ++ program for the above approach ; Function to find binomial coefficient ; Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007 ; for 1 / ( r ! ) part ; for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << "" Value ▁ of ▁ C ( "" << n << "" , ▁ "" << r << "" ) ▁ is ▁ "" << binomialCoeff ( n , r ) << endl ; return 0 ; }",Binomial Coefficient.
315,"Check if it is possible to reach ( X , Y ) from ( 1 , 1 ) by given steps | C ++ program for the above approach ; Function to find the gcd of two numbers ; Base case ; Recurse ; Function to print the answer ; GCD of X and Y ; If GCD is power of 2 ; Driver code ; Given X and Y ; Function call","#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; } void printAnswer ( int x , int y ) { int val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) cout << "" Yes "" ; else cout << "" No "" ; } int main ( ) { int x = 4 ; int y = 7 ; printAnswer ( x , y ) ; return 0 ; }","Check if it is possible to reach ( X , Y ) from ( 1 , 1 ) by given steps."
316,Find the element in the matrix generated by given rules | C ++ implementation of the approach ; Function to return the element in the rth row and cth column from the required matrix ; Condition for lower half of matrix ; Condition if element is in first row ; Starting element of AP in row r ; Common difference of AP in row r ; Position of element to find in AP in row r ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; } int main ( ) { int N = 4 , R = 3 , C = 4 ; cout << getElement ( N , R , C ) ; return 0 ; }",Find the element in the matrix generated by given rules.
317,"Find smallest number formed by inserting given digit | C ++ implementation of above approach ; Function to insert X in N and return the minimum value string ; Variable to store length of string N ; Variable to denote the position where X must be added ; If the given string N represent a negative value ; X must be place at the last index where is greater than N [ i ] ; For positive numbers , X must be placed at the last index where it is smaller than N [ i ] ; Insert X at that position ; Return the string ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; string MinValue ( string N , int X ) { int len = N . size ( ) ; int position = len + 1 ; if ( N [ 0 ] == ' - ' ) { for ( int i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] - '0' ) < X ) { position = i ; } } } else { for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] - '0' ) > X ) { position = i ; } } } N . insert ( N . begin ( ) + position , X + '0' ) ; return N ; } int main ( ) { string N = ""89"" ; int X = 1 ; cout << MinValue ( N , X ) << "" STRNEWLINE "" ; }",Find smallest number formed by inserting given digit.
318,"Check if Decimal representation of given Binary String is divisible by K or not | C ++ program for above approach ; Function to check the binary number is divisible by K ; Array poweroftwo will store pow ( 2 , i ) % k ; Initializing the first element in Array ; Storing every pow ( 2 , i ) % k value in the array ; To store the remaining ; Iterating till N ; If current bit is 1 ; Updating rem ; If completely divisible ; If not Completely divisible ; Driver Code ; Given Input ; length of string s ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; string divisibleByk ( string s , int n , int k ) { int poweroftwo [ n ] ; poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; } int rem = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ n - i - 1 ] == '1' ) { rem += ( poweroftwo [ i ] ) ; rem %= k ; } } if ( rem == 0 ) { return "" Yes "" ; } else return "" No "" ; } int main ( ) { string s = ""1010001"" ; int k = 9 ; int n = s . length ( ) ; cout << divisibleByk ( s , n , k ) ; return 0 ; }",Check if Decimal representation of given Binary String is divisible by K or not.
319,Split a Binary String such that count of 0 s and 1 s in left and right substrings is maximum | C ++ program to implement the above approach ; Function to find the maximum sum of count of 0 s in the left substring and count of 1 s in the right substring by splitting the string ; Stores count of 1 s the in binary string ; Traverse the binary string ; If current character is '1' ; Update cntOne ; Stores count of 0 s ; Stores count of 1 s ; Stores maximum sum of count of 0 s and 1 s by splitting the string ; Traverse the binary string ; If current character is '0' ; Update zero ; If current character is '1' ; Update one ; Update res ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumbySplittingstring ( string str , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) { cntOne ++ ; } } int zero = 0 ; int one = 0 ; int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { one ++ ; } res = max ( res , zero + cntOne - one ) ; } return res ; } int main ( ) { string str = ""00111"" ; int N = str . length ( ) ; cout << maxSumbySplittingstring ( str , N ) ; return 0 ; }",Split a Binary String such that count of 0 s and 1 s in left and right substrings is maximum.
320,Count removal of pairs required to be empty all Balanced Parenthesis subsequences | C ++ program to implement the above approach ; Function to find the maximum count of pairs required to be removed such that subsequence of string does not contain any valid parenthesis ; Stores count of pairs of balanced parenthesis ; Stores count of curly balanced parenthesis ; Stores count of small balanced parenthesis ; Stores count of square balanced parenthesis ; Iterate over characters of the string ; Update cntCurly ; Update cntSml ; Update cntSqr ; Update cntCurly ; Update cntPairs ; Update cntSml ; Update cntPairs ; Update cntSml ; Update cntPairs ; Driver Code ; Given String ; Function call,"#include <iostream> NEW_LINE using namespace std ; void cntBalancedParenthesis ( string s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' { ' ) { cntCurly ++ ; } else if ( s [ i ] == ' ( ' ) { cntSml ++ ; } else if ( s [ i ] == ' [ ' ) { cntSqr ++ ; } else if ( s [ i ] == ' } ' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s [ i ] == ' ) ' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s [ i ] == ' ] ' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } cout << cntPairs ; } int main ( ) { string s = "" { ( } ) "" ; int N = s . length ( ) ; cntBalancedParenthesis ( s , N ) ; return 0 ; }",Count removal of pairs required to be empty all Balanced Parenthesis subsequences.
321,Count of strings that does not contain Arc intersection | C ++ program for the above approach ; Function to check if there is arc intersection or not ; Traverse the string S ; Insert all the elements in the stack one by one ; Extract the top element ; Pop out the top element ; Check if the top element is same as the popped element ; Otherwise ; If the stack is empty ; Function to check if there is arc intersection or not for the given array of strings ; Stores count of string not having arc intersection ; Iterate through array ; Length of every string ; Function Call ; Print the desired count ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int arcIntersection ( string S , int len ) { stack < char > stk ; for ( int i = 0 ; i < len ; i ++ ) { stk . push ( S [ i ] ) ; if ( stk . size ( ) >= 2 ) { char temp = stk . top ( ) ; stk . pop ( ) ; if ( stk . top ( ) == temp ) { stk . pop ( ) ; } else { stk . push ( temp ) ; } } } if ( stk . empty ( ) ) return 1 ; return 0 ; } void countString ( string arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int len = arr [ i ] . length ( ) ; count += arcIntersection ( arr [ i ] , len ) ; } cout << count << endl ; } int main ( ) { string arr [ ] = { ""0101"" , ""0011"" , ""0110"" } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countString ( arr , N ) ; return 0 ; }",Count of strings that does not contain Arc intersection.
322,Check if decimal representation of Binary String is divisible by 9 or not | C ++ program to implement the above approach ; Function to convert the binary string into octal representation ; Stores binary representation of the decimal value [ 0 - 7 ] ; Stores the decimal values of binary strings [ 0 - 7 ] ; Stores length of S ; Update S ; Update S ; Update N ; Stores octal representation of the binary string ; Traverse the binary string ; Stores 3 consecutive characters of the binary string ; Append octal representation of temp ; Function to check if binary string is divisible by 9 or not ; Stores octal representation of S ; Stores sum of elements present at odd positions of oct ; Stores sum of elements present at odd positions of oct ; Stores length of oct ; Traverse the string oct ; Update oddSum ; Traverse the string oct ; Update evenSum ; Stores cotal representation of 9 ; If absolute value of ( oddSum - evenSum ) is divisible by Oct_9 ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string ConvertequivalentBase8 ( string S ) { map < string , char > mp ; mp [ ""000"" ] = '0' ; mp [ ""001"" ] = '1' ; mp [ ""010"" ] = '2' ; mp [ ""011"" ] = '3' ; mp [ ""100"" ] = '4' ; mp [ ""101"" ] = '5' ; mp [ ""110"" ] = '6' ; mp [ ""111"" ] = '7' ; int N = S . length ( ) ; if ( N % 3 == 2 ) { S = ""0"" + S ; } else if ( N % 3 == 1 ) { S = ""00"" + S ; } N = S . length ( ) ; string oct ; for ( int i = 0 ; i < N ; i += 3 ) { string temp = S . substr ( i , 3 ) ; oct . push_back ( mp [ temp ] ) ; } return oct ; } string binString_div_9 ( string S , int N ) { string oct ; oct = ConvertequivalentBase8 ( S ) ; int oddSum = 0 ; int evenSum = 0 ; int M = oct . length ( ) ; for ( int i = 0 ; i < M ; i += 2 ) { oddSum += int ( oct [ i ] - '0' ) ; } for ( int i = 1 ; i < M ; i += 2 ) { evenSum += int ( oct [ i ] - '0' ) ; } int Oct_9 = 11 ; if ( abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return "" Yes "" ; } return "" No "" ; } int main ( ) { string S = ""1010001"" ; int N = S . length ( ) ; cout << binString_div_9 ( S , N ) ; }",Check if decimal representation of Binary String is divisible by 9 or not.
323,Minimum cost to remove the spaces between characters of a String by rearranging the characters | C ++ program to gather characters of a string in minimum cost ; Function to calculate the minimum cost ; Stores the minimum cost ; Stores the count of characters found ; Stores the count of blank spaces found ; Stores the count of total characters ; If the count of characters is equal to 1 ; Iterate over the string ; Consider the previous character together with current character ; If not together already ; Add the cost to group them together ; Increase count of characters found ; Otherwise ; Increase count of spaces found ; Return the total cost obtained ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S ) if ( c == ' ▁ ' ) count ++ ; int n = S . size ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; } int main ( ) { string S = "" ▁ @ TABSYMBOL $ "" ; cout << min_cost ( S ) ; return 0 ; }",Minimum cost to remove the spaces between characters of a String by rearranging the characters.
324,Minimize cost to replace all the vowels of a given String by a single vowel | C ++ program for the above approach ; Function that return true if the given character is a vowel ; Function to return the minimum cost to convert all the vowels of a string to a single one ; Stores count of respective vowels ; Iterate through the string ; If a vowel is encountered ; Calculate the cost ; Return the minimum cost ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) return true ; else return false ; } int minCost ( string S ) { int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += abs ( S [ i ] - ' a ' ) ; cE += abs ( S [ i ] - ' e ' ) ; cI += abs ( S [ i ] - ' i ' ) ; cO += abs ( S [ i ] - ' o ' ) ; cU += abs ( S [ i ] - ' u ' ) ; } } return min ( min ( min ( min ( cA , cE ) , cI ) , cO ) , cU ) ; } int main ( ) { string S = "" geeksforgeeks "" ; cout << minCost ( S ) << endl ; return 0 ; }",Minimize cost to replace all the vowels of a given String by a single vowel.
325,Generate a string whose all K | C ++ program to generate a string whose substrings of length K concatenates to form given strings ; Function to return the required required string ; Iterate the given string ; Append the first character of every substring of length K ; Consider all characters from the last substring ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void decode_String ( string str , int K ) { string ans = "" "" ; for ( int i = 0 ; i < str . size ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . size ( ) - ( K - 1 ) ; i < str . size ( ) ; i ++ ) ans += str [ i ] ; cout << ans << endl ; } int main ( ) { int K = 3 ; string str = "" abcbcscsesesesd "" ; decode_String ( str , K ) ; }",Generate a string whose all K.
326,"Lexicographically smallest K | C ++ program to find lexicographically smallest K - length substring containing maximum number of vowels ; Function that prints the lexicographically smallest K - length substring containing maximum number of vowels ; Store the length of the string ; Initialize a prefix sum array ; Loop through the string to create the prefix sum array ; Store 1 at the index if it is a vowel ; Otherwise , store 0 ; Process the prefix array ; Initialize the variable to store maximum count of vowels ; Initialize the variable to store substring with maximum count of vowels ; Loop through the prefix array ; Store the current count of vowels ; Update the result if current count is greater than maximum count ; Update lexicographically smallest substring if the current count is equal to the maximum count ; Return the result ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxVowelSubString ( string str , int K ) { int N = str . length ( ) ; int pref [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i ) pref [ i ] += pref [ i - 1 ] ; } int maxCount = pref [ K - 1 ] ; string res = str . substr ( 0 , K ) ; for ( int i = K ; i < N ; i ++ ) { int currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . substr ( i - K + 1 , K ) ; } else if ( currCount == maxCount ) { string temp = str . substr ( i - K + 1 , K ) ; if ( temp < res ) res = temp ; } } return res ; } int main ( ) { string str = "" ceebbaceeffo "" ; int K = 3 ; cout << maxVowelSubString ( str , K ) ; return 0 ; }",Lexicographically smallest K.
327,Decode the string encoded with the given algorithm | C ++ implementation of the approach ; Function to decode and print the original string ; To store the decoded string ; Getting the mid element ; Storing the first element of the string at the median position ; If the length is even then store the second element also ; k represents the number of characters that are already stored in the c [ ] ; If string length is odd ; If it is even ; Print the decoded string ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void decodeStr ( string str , int len ) { char c [ len ] = "" "" ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) cout << c [ i ] ; } int main ( ) { string str = "" ofrsgkeeeekgs "" ; int len = str . length ( ) ; decodeStr ( str , len ) ; return 0 ; }",Decode the string encoded with the given algorithm.
328,Count of distinct characters in a substring by given range for Q queries | C ++ Program for Naive Approach ; counter to count distinct char ; Initializing frequency array to count characters as the appear in substring S [ L : R ] ; Iterating over S [ L ] to S [ R ] ; incrementing the count of s [ i ] character in frequency array ; if frequency of any character is > 0 then increment the counter ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCount ( string s , int L , int R ) { int distinct = 0 ; int frequency [ 26 ] = { } ; for ( int i = L ; i <= R ; i ++ ) { frequency [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] > 0 ) distinct ++ ; } cout << distinct << endl ; } int main ( ) { string s = "" geeksforgeeksisacomputerscienceportal "" ; int queries = 3 ; int Q [ queries ] [ 2 ] = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; return 0 ; }",Count of distinct characters in a substring by given range for Q queries.
329,String obtained by reversing and complementing a Binary string K times | C ++ program to perform K operations upon the string and find the modified string ; Function to perform K operations upon the string and find modified string ; Number of reverse operations ; Number of complement operations ; If rev is odd parity ; If complement is odd parity ; Complementing each position ; Return the modified string ; Driver Code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string ReverseComplement ( string s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 ) reverse ( s . begin ( ) , s . end ( ) ) ; if ( complement % 2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return s ; } int main ( ) { string str = ""10011"" ; int k = 5 ; int n = str . size ( ) ; cout << ReverseComplement ( str , n , k ) ; return 0 ; }",String obtained by reversing and complementing a Binary string K times.
330,Check if any permutation of string is a K times repeated string | C ++ implementation to check that the permutation of the given string is K times repeated string ; Function to check that permutation of the given string is a K times repeating String ; if length of string is not divisible by K ; Frequency Array ; Initially frequency of each character is 0 ; Computing the frequency of each character in the string ; Loop to check that frequency of every character of the string is divisible by K ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool repeatingString ( string s , int n , int k ) { if ( n % k != 0 ) { return false ; } int frequency [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } int main ( ) { string s = "" abcdcba "" ; int n = s . size ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { cout << "" Yes "" << endl ; } else { cout << "" No "" << endl ; } return 0 ; }",Check if any permutation of string is a K times repeated string.
331,"Find the last two missing digits of the given phone number | C ++ implementation of the approach ; Function to find the last two digits of the number and print the complete number ; Sum of the first eight digits of the number ; if sum < 10 , then the two digits are '0' and the value of sum ; if sum > 10 , then the two digits are the value of sum ; Driver code","#include <iostream> NEW_LINE using namespace std ; void findPhoneNumber ( int n ) { int temp = n ; int sum ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) cout << n << ""0"" << sum ; else cout << n << sum ; } int main ( ) { long int n = 98765432 ; findPhoneNumber ( n ) ; return 0 ; }",Find the last two missing digits of the given phone number.
332,Number of ways to split a binary number such that every part is divisible by 2 | C ++ implementation of the approach ; Function to return the required count ; If the splitting is not possible ; To store the count of zeroes ; Counting the number of zeroes ; Return the final answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_zero - 1 ) ; } int main ( ) { string s = ""10010"" ; cout << cntSplits ( s ) ; return 0 ; }",Number of ways to split a binary number such that every part is divisible by 2.
333,Count number of substrings of a string consisting of same characters | C ++ implementation of the above approach ; Function to return the number of substrings of same characters ; Size of the string ; Initialize count to 1 ; Initialize left to 0 and right to 1 to traverse the string ; Checking if consecutive characters are same and increment the count ; When we encounter a different characters ; Increment the result ; To repeat the whole process set left equals right and count variable to 1 ; Store the final value of result ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( string s ) { if ( s . empty ( ) ) return 0 ; int n = s . size ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; } int main ( ) { string s = "" bbbcbb "" ; findNumbers ( s ) ; }",Count number of substrings of a string consisting of same characters.
334,Program to duplicate Vowels in String | C ++ program for printing string with duplicate vowels ; Function to check for the Vowel ; Function to get the resultant string with vowels duplicated ; Another string to store the resultant string ; Loop to check for each character ; Driver Code ; Print the original string ; Print the resultant string,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } string duplicateVowels ( string str ) { int t = str . length ( ) ; string res = "" "" ; for ( int i = 0 ; i < t ; i ++ ) { if ( isVowel ( str [ i ] ) ) { res += str [ i ] ; } res += str [ i ] ; } return res ; } int main ( ) { string str = "" helloworld "" ; cout << "" Original ▁ String : ▁ "" << str << endl ; string res = duplicateVowels ( str ) ; cout << "" String ▁ with ▁ Vowels ▁ duplicated : ▁ "" << res << endl ; }",Program to duplicate Vowels in String.
335,"Convert a String to an Integer using Recursion | C ++ implementation of the approach ; Recursive function to convert string to integer ; If the number represented as a string contains only a single digit then returns its value ; Recursive call for the sub - string starting at the second character ; First digit of the number ; First digit multiplied by the appropriate power of 10 and then add the recursive result For example , xy = ( ( x * 10 ) + y ) ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int stringToInt ( string str ) { if ( str . length ( ) == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . substr ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * pow ( 10 , str . length ( ) - 1 ) + y ; return int ( x ) ; } int main ( ) { string str = ""1235"" ; cout << ( stringToInt ( str ) ) << endl ; }",Convert a String to an Integer using Recursion.
336,"Longest subsequence with at least one character appearing in every string | C ++ implementation of the approach ; Function to return the length of the longest sub - sequence with at least one common character in every string ; count [ 0 ] will store the number of strings which contain ' a ' , count [ 1 ] will store the number of strings which contain ' b ' and so on . . ; For every string ; Hash array to set which character is present in the current string ; If current character appears in the string then update its count ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE int largestSubSeq ( string arr [ ] , int n ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool hash [ MAX ] = { 0 } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str [ j ] - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return * ( max_element ( count , count + MAX ) ) ; } int main ( ) { string arr [ ] = { "" ab "" , "" bc "" , "" de "" } ; int n = sizeof ( arr ) / sizeof ( string ) ; cout << largestSubSeq ( arr , n ) ; return 0 ; }",Longest subsequence with at least one character appearing in every string.
337,Generate number with given operation and check if it is palindrome | CPP implementation of the approach ; Function that returns true if str is a palindrome ; Function that returns true if the generated string is a palindrome ; sub contains N as a string ; Calculate the sum of the digits ; Repeat the substring until the length of the resultant string < sum ; If length of the resultant string exceeded sum then take substring from 0 to sum - 1 ; If the generated string is a palindrome ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; } bool createStringAndCheckPalindrome ( int N ) { ostringstream out ; out << N ; string result = out . str ( ) ; string sub = "" "" + result , res_str = "" "" ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length ( ) < sum ) res_str += sub ; if ( res_str . length ( ) > sum ) res_str = res_str . substr ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; } int main ( ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) cout << ( "" Yes "" ) ; else cout << ( "" No "" ) ; }",Generate number with given operation and check if it is palindrome.
338,Minimize the length of string by removing occurrence of only one character | C ++ program to minimize the length of string by removing occurrence of only one character ; Function to find the minimum length ; Count the frequency of each alphabet ; Find the alphabets with maximum frequency ; Subtract the frequency of character from length of string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } int main ( ) { string str = "" afddewqd "" ; cout << minimumLength ( str ) ; return 0 ; }",Minimize the length of string by removing occurrence of only one character.
339,Remove all characters other than alphabets from string | CPP program to remove all the characters other then alphabets ; function to remove characters and print new string ; Finding the character whose ASCII value fall under this range ; erase function to erase the character ; driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s . erase ( i , 1 ) ; i -- ; } } cout << s ; } int main ( ) { string s = "" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? "" ; removeSpecialCharacter ( s ) ; return 0 ; }",Remove all characters other than alphabets from string.
340,Remove all characters other than alphabets from string | CPP program to remove all the characters other then alphabets ; function to remove characters and print new string ; Store only valid characters ; driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } cout << s . substr ( 0 , j ) ; } int main ( ) { string s = "" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? "" ; removeSpecialCharacter ( s ) ; return 0 ; }",Remove all characters other than alphabets from string.
341,Find repeated character present first in a string | C ++ program to find the first character that is repeated ; this is O ( N ^ 2 ) method ; Driver code,"#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; } int main ( ) { char str [ ] = "" geeksforgeeks "" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == -1 ) cout << "" Not ▁ found "" ; else cout << str [ pos ] ; return 0 ; }",Find repeated character present first in a string.
342,Print characters and their frequencies in order of occurrence | C ++ implementation to print the characters and frequencies in order of its occurrence ; Store all characters and their frequencies in dictionary ; Print characters and their frequencies in same order of their appearance ; Print only if this character is not printed before ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void prCharWithFreq ( string s ) { unordered_map < char , int > d ; for ( char i : s ) { d [ i ] ++ ; } for ( char i : s ) { if ( d [ i ] != 0 ) { cout << i << d [ i ] << "" ▁ "" ; d [ i ] = 0 ; } } } int main ( ) { string s = "" geeksforgeeks "" ; prCharWithFreq ( s ) ; }",Print characters and their frequencies in order of occurrence.
343,"Count number of strings ( made of R , G and B ) using given combination | C ++ program to count number of possible strings with n characters . ; Function to calculate number of strings ; Store factorial of numbers up to n for further computation ; Find the remaining values to be added ; Make all possible combinations of R , B and G for the remaining value ; Compute permutation of each combination one by one and add them . ; Return total no . of strings / permutation ; Drivers code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; } int main ( ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; cout << possibleStrings ( n , r , b , g ) ; return 0 ; }","Count number of strings ( made of R , G and B ) using given combination."
344,Remove minimum number of characters so that two strings become anagram | C ++ program to find minimum number of characters to be removed to make two strings anagram . ; function to calculate minimum numbers of characters to be removed to make two strings anagram ; make hash array for both string and calculate frequency of each character ; count frequency of each character in first string ; count frequency of each character in second string ; traverse count arrays to find number of characters to be removed ; Driver program to run the case,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \0' ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } int main ( ) { string str1 = "" bcadeh "" , str2 = "" hea "" ; cout << remAnagram ( str1 , str2 ) ; return 0 ; }",Remove minimum number of characters so that two strings become anagram.
345,"Check if a string has all characters with same frequency with one variation allowed | C ++ program to check if a string can be made valid by removing at most 1 character . ; Assuming only lower case characters ; To check a string S can be converted to a valid string by removing less than or equal to one character . ; freq [ ] : stores the frequency of each character of a string ; Find first character with non - zero frequency ; Find a character with frequency different from freq1 . ; If we find a third non - zero frequency or count of both frequencies become more than 1 , then return false ; else If we find a third non - zero freq ; If counts of both frequencies is more than 1 ; Return true if we reach here ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; bool isValidString ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; return false ; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; } int main ( ) { char str [ ] = "" abcbc "" ; if ( isValidString ( str ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }",Check if a string has all characters with same frequency with one variation allowed.
346,Check if a string has all characters with same frequency with one variation allowed | C ++ program to check if a string can be made valid by removing at most 1 character using hashmap . ; To check a string S can be converted to a variation string ; Run loop form 0 to length of string ; declaration of variables ; if first is true than countOfVal1 increase ; if second is true than countOfVal2 increase ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkForVariation ( string str ) { if ( str . empty ( ) || str . length ( ) != 0 ) { return true ; } map < char , int > mapp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mapp [ str [ i ] ] ++ ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; map < char , int > :: iterator itr ; for ( itr = mapp . begin ( ) ; itr != mapp . end ( ) ; ++ itr ) { int i = itr -> first ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } } int main ( ) { if ( checkForVariation ( "" abcbcvf "" ) ) cout << "" true "" << endl ; else cout << "" false "" << endl ; return 0 ; }",Check if a string has all characters with same frequency with one variation allowed.
347,"Pairs of complete strings in two sets of strings | C ++ implementation for find pairs of complete strings . ; Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ] ; Consider all pairs of both strings ; Create a concatenation of current pair ; Compute frequencies of all characters in the concatenated string . ; If frequency of any character is not greater than 0 , then this pair is not complete . ; Driver code","#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { string concat = set1 [ i ] + set2 [ j ] ; int frequency [ 26 ] = { 0 } ; for ( int k = 0 ; k < concat . length ( ) ; k ++ ) frequency [ concat [ k ] - ' a ' ] ++ ; int i ; for ( i = 0 ; i < 26 ; i ++ ) if ( frequency [ i ] < 1 ) break ; if ( i == 26 ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { "" abcdefgh "" , "" geeksforgeeks "" , "" lmnopqrst "" , "" abc "" } ; string set2 [ ] = { "" ijklmnopqrstuvwxyz "" , "" abcdefghijklmnopqrstuvwxyz "" , "" defghijklmnopqrstuvwxyz "" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }",Pairs of complete strings in two sets of strings.
348,"Pairs of complete strings in two sets of strings | C ++ program to find count of complete pairs ; Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ] ; con_s1 [ i ] is going to store an integer whose set bits represent presence / absence of characters in string set1 [ i ] . Similarly con_s2 [ i ] is going to store an integer whose set bits represent presence / absence of characters in string set2 [ i ] ; Process all strings in set1 [ ] ; initializing all bits to 0 ; Setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer . ; Process all strings in set2 [ ] ; initializing all bits to 0 ; setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer . ; assigning a variable whose all 26 ( 0. . 25 ) bits are set to 1 ; Now consider every pair of integer in con_s1 [ ] and con_s2 [ ] and check if the pair is complete . ; if all bits are set , the strings are complete ! ; Driver code","#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; int con_s1 [ n ] , con_s2 [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - ' a ' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - ' a ' ) ) ; } } long long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { "" abcdefgh "" , "" geeksforgeeks "" , "" lmnopqrst "" , "" abc "" } ; string set2 [ ] = { "" ijklmnopqrstuvwxyz "" , "" abcdefghijklmnopqrstuvwxyz "" , "" defghijklmnopqrstuvwxyz "" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }",Pairs of complete strings in two sets of strings.
349,"Find all strings that match specific pattern in a dictionary | C ++ program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary ; Function to encode given string ; for each character in given string ; If the character is occurring for the first time , assign next unique number to that char ; append the number associated with current character into the output string ; Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary ; len is length of the pattern ; Encode the string ; for each word in the dictionary ; If size of pattern is same as size of current dictionary word and both pattern and the word has same hash , print the word ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; string encodeString ( string str ) { unordered_map < char , int > map ; string res = "" "" ; int i = 0 ; for ( char ch : str ) { if ( map . find ( ch ) == map . end ( ) ) map [ ch ] = i ++ ; res += to_string ( map [ ch ] ) ; } return res ; } void findMatchedWords ( unordered_set < string > dict , string pattern ) { int len = pattern . length ( ) ; string hash = encodeString ( pattern ) ; for ( string word : dict ) { if ( word . length ( ) == len && encodeString ( word ) == hash ) cout << word << "" ▁ "" ; } } int main ( ) { unordered_set < string > dict = { "" abb "" , "" abc "" , "" xyz "" , "" xyy "" } ; string pattern = "" foo "" ; findMatchedWords ( dict , pattern ) ; return 0 ; }",Find all strings that match specific pattern in a dictionary.
350,Find all strings that match specific pattern in a dictionary | C ++ program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary ; Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary ; len is length of the pattern ; for each word in the dictionary ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string pattern , string word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; char ch [ 128 ] = { 0 } ; int len = word . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch [ pattern [ i ] ] == 0 ) ch [ pattern [ i ] ] = word [ i ] ; else if ( ch [ pattern [ i ] ] != word [ i ] ) return false ; } return true ; } void findMatchedWords ( unordered_set < string > dict , string pattern ) { int len = pattern . length ( ) ; for ( string word : dict ) { if ( check ( pattern , word ) ) cout << word << "" ▁ "" ; } } int main ( ) { unordered_set < string > dict = { "" abb "" , "" abc "" , "" xyz "" , "" xyy "" } ; string pattern = "" foo "" ; findMatchedWords ( dict , pattern ) ; return 0 ; }",Find all strings that match specific pattern in a dictionary.
351,Reverse words in a given string | C ++ program for above approach : ; temp is for word boundary ; STEP 1 of the above algorithm ; This condition is to make sure that the string start with valid character ( not space ) only ; STEP 2 of the above algorithm,"void reverseWords ( char * s ) { char * word_begin = NULL ; char * temp = s ; while ( * temp ) { if ( ( word_begin == NULL ) && ( * temp != ' ▁ ' ) ) { word_begin = temp ; } if ( word_begin && ( ( * ( temp + 1 ) == ' ▁ ' ) || ( * ( temp + 1 ) == ' \0' ) ) ) { reverse ( word_begin , temp ) ; word_begin = NULL ; } temp ++ ; } reverse ( s , temp - 1 ) ; }",Reverse words in a given string.
352,Reverse words in a given string | C ++ code to reverse a string ; Reverse the string ; Check if number of words is even ; Find the middle word ; Starting from the middle start swapping words at jth position and l - 1 - j position ; Check if number of words is odd ; Find the middle word ; Starting from the middle start swapping the words at jth position and l - 1 - j position ; Return the reversed sentence ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string RevString ( string s [ ] , int l ) { if ( l % 2 == 0 ) { int j = l / 2 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } else { int j = ( l / 2 ) + 1 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } string S = s [ 0 ] ; for ( int i = 1 ; i < 9 ; i ++ ) { S = S + "" ▁ "" + s [ i ] ; } return S ; } int main ( ) { string s = "" getting ▁ good ▁ at ▁ coding ▁ "" "" needs ▁ a ▁ lot ▁ of ▁ practice "" ; string words [ ] = { "" getting "" , "" good "" , "" at "" , "" coding "" , "" needs "" , "" a "" , "" lot "" , "" of "" , "" practice "" } ; cout << RevString ( words , 9 ) << endl ; return 0 ; }",Reverse words in a given string.
353,Print path from root to all nodes in a Complete Binary Tree | C ++ program to print path from root to all nodes in a complete binary tree . ; Function to print path of all the nodes nth node represent as given node kth node represents as left and right node ; base condition if kth node value is greater then nth node then its means kth node is not valid so we not store it into the res simply we just return ; Storing node into res ; Print the path from root to node ; store left path of a tree So for left we will go node ( kThNode * 2 ) ; right path of a tree and for right we will go node ( kThNode * 2 + 1 ) ; Function to print path from root to all of the nodes ; res is for store the path from root to particulate node ; Print path from root to all node . third argument 1 because of we have to consider root node is 1 ; Driver Code ; Given Node ; Print path from root to all node .,"#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void printPath ( vector < int > res , int nThNode , int kThNode ) { if ( kThNode > nThNode ) return ; res . push_back ( kThNode ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << "" ▁ "" ; cout << "" STRNEWLINE "" ; printPath ( res , nThNode , kThNode * 2 ) ; printPath ( res , nThNode , kThNode * 2 + 1 ) ; } void printPathToCoverAllNodeUtil ( int nThNode ) { vector < int > res ; printPath ( res , nThNode , 1 ) ; } int main ( ) { int nThNode = 7 ; printPathToCoverAllNodeUtil ( nThNode ) ; return 0 ; }",Print path from root to all nodes in a Complete Binary Tree.
354,"Array Range Queries to find the Maximum Armstrong number with updates | C ++ code to implement above approach ; A utility function to get the middle index of given range . ; Function that return true if num is armstrong else return false ; A recursive function to get the sum of values in the given range of the array . The following are parameters for this function . st -> Pointer to segment tree node -> Index of current node in the segment tree . ss & se -> Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r -> Starting and ending indexes of range query ; If segment of this node is completely part of given range , then return the max of segment . ; If segment of this node does not belong to given range ; If segment of this node is partially the part of given range ; A recursive function to update the nodes which have the given the index in their range . The following are parameters st , ss and se are same as defined above index -> index of the element to be updated . ; update value in array and in segment tree ; Return max of elements in range from index l ( query start ) to r ( query end ) . ; Check for erroneous input values ; A recursive function that constructs Segment Tree for array [ ss . . se ] . si is index of current node in segment tree st ; If there is one element in array , store it in current node of segment tree and return ; If there are more than one elements , then recur for left and right subtrees and store the max of values in this node ; Function to construct a segment tree from given array . This function allocates memory for segment tree . ; Height of segment tree ; Maximum size of segment tree ; Allocate memory ; Fill the allocated memory st ; Return the constructed segment tree ; Driver code ; Build segment tree from given array ; Print max of values in array from index 1 to 3 ; Update : set arr [ 1 ] = 153 and update corresponding segment tree nodes . ; Find max after the value is updated","#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } bool isArmstrong ( int x ) { int n = to_string ( x ) . size ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return true ; return false ; } int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se ) ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } void updateValue ( int arr [ ] , int * st , int ss , int se , int index , int value , int node ) { if ( index < ss index > se ) { cout << "" Invalid ▁ Input "" << endl ; return ; } if ( ss == se ) { arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = -1 ; } else { int mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node + 1 ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 2 ) ; st [ node ] = max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; } int getMax ( int * st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { printf ( "" Invalid ▁ Input "" ) ; return -1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = -1 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 192 , 113 , 535 , 7 , 19 , 111 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * st = constructST ( arr , n ) ; cout << "" Maximum ▁ armstrong ▁ "" << "" number ▁ in ▁ given ▁ range ▁ = ▁ "" << getMax ( st , n , 1 , 3 ) << endl ; updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ; cout << "" Updated ▁ Maximum ▁ armstrong ▁ "" << "" number ▁ in ▁ given ▁ range ▁ = ▁ "" << getMax ( st , n , 1 , 3 ) << endl ; return 0 ; }",Array Range Queries to find the Maximum Armstrong number with updates.
355,Maximum number of region in which N non | C ++ program to implement the above problem ; Function to find the maximum number of regions on a plane ; print the maximum number of regions ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; } int main ( ) { int n = 10 ; maxRegions ( n ) ; return 0 ; },Maximum number of region in which N non.
356,Check whether jigsaw puzzle solveable or not | C ++ program for the above approach ; Function to check if the jigsaw Puzzle is solveable or not ; Base Case ; By placing the blank tabs as a chain ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << "" YES "" ; else if ( m == 2 and n == 2 ) cout << "" YES "" ; else cout << "" NO "" ; } int main ( ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; }",Check whether jigsaw puzzle solveable or not.
357,"Check if it is possible to reach ( X , Y ) from ( 1 , 0 ) by given steps | C ++ program for the above approach ; Function to find the GCD of two numbers a and b ; Base Case ; Recursively find the GCD ; Function to check if ( x , y ) can be reached from ( 1 , 0 ) from given moves ; If GCD is 1 , then print "" Yes "" ; Driver Code ; Given X and Y ; Function call","#include <iostream> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; } void check ( int x , int y ) { if ( GCD ( x , y ) == 1 ) { cout << "" Yes "" ; } else { cout << "" No "" ; } } int main ( ) { int X = 2 , Y = 7 ; check ( X , Y ) ; return 0 ; }","Check if it is possible to reach ( X , Y ) from ( 1 , 0 ) by given steps."
358,"Probability of Euler 's Totient Function in a range [L, R] to be divisible by M | C ++ Program to implement the above approach ; Seieve of Erotosthenes to compute all primes ; If prime ; Mark all its multiples as non - prime ; Function to find the probability of Euler 's Totient Function in a given range ; Initializing two arrays with values from L to R for Euler 's totient ; Indexing from 0 ; If the current number is prime ; Checking if i is prime factor of numbers in range L to R ; Update all the numbers which has prime factor i ; If number in range has a prime factor > sqrt ( number ) ; Count those which are divisible by M ; Return the result ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size  1000001 NEW_LINE void seiveOfEratosthenes ( int * prime ) { prime [ 0 ] = 1 , prime [ 1 ] = 0 ; for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 1 ; } } } } float probabiltyEuler ( int * prime , int L , int R , int M ) { int * arr = new int [ size ] { 0 } ; int * eulerTotient = new int [ size ] { 0 } ; int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( int i = 2 ; i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = ( L / i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) { eulerTotient [ j - L ] = eulerTotient [ j - L ] / i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] /= i ; } } } } } for ( int i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] / arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( int i = L ; i <= R ; i ++ ) { if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } } return ( 1.0 * count / ( R + 1 - L ) ) ; } int main ( ) { int * prime = new int [ size ] { 0 } ; seiveOfEratosthenes ( prime ) ; int L = 1 , R = 7 , M = 3 ; cout << probabiltyEuler ( prime , L , R , M ) ; return 0 ; }","Probability of Euler 's Totient Function in a range [L, R] to be divisible by M."
359,Largest odd divisor Game to check which player wins | C ++ implementation to find the Largest Odd Divisor Game to check which player wins ; Function to find the Largest Odd Divisor Game to check which player wins ; Check if n == 1 then player 2 will win ; Check if n == 2 or n is odd ; While n is greater than k and divisible by 2 keep incrementing tha val ; Loop to find greatest odd divisor ; Check if n is a power of 2 ; Check if cnt is not one then player 1 wins ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) cout << "" No "" << endl ; else if ( ( n & 1 ) or n == 2 ) cout << "" Yes "" << endl ; else { int tmp = n ; int val = 1 ; while ( tmp > k and tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) cout << "" No "" << endl ; else if ( n / tmp == 2 and cnt == 1 ) cout << "" No "" << endl ; else cout << "" Yes "" << endl ; } } int main ( ) { long long n = 1 , k = 1 ; findWinner ( n , k ) ; return 0 ; }",Largest odd divisor Game to check which player wins.
360,Find all numbers up to N which are both Pentagonal and Hexagonal | C ++ Program of the above approach ; Function to print numbers upto N which are both pentagonal as well as hexagonal numbers ; Calculate i - th pentagonal number ; Check if the pentagonal number pn is hexagonal or not ; Driver Program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void pen_hex ( long long n ) { long long pn = 1 ; for ( long long int i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; long double seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == long ( seqNum ) ) cout << pn << "" , ▁ "" ; } } int main ( ) { long long int N = 1000000 ; pen_hex ( N ) ; return 0 ; }",Find all numbers up to N which are both Pentagonal and Hexagonal.
361,Check if row | C ++ implementation to check if row - major order traversal of matrix is palindrome or not ; Function to check if row - major order traversal of the matrix is is palindrome ; Loop to check if the matrix is matrix is palindrome or not ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } int main ( ) { int n = 3 , m = 3 ; int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { cout << "" YES "" << endl ; } else { cout << "" NO "" << endl ; } }",Check if row.
362,Find the smallest number whose sum of digits is N | C ++ program to find the smallest number whose sum of digits is also N ; Function to get sum of digits ; Function to find the smallest number whose sum of digits is also N ; Checking if number has sum of digits = N ; Driver code,#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } void smallestNumber ( int N ) { int i = 1 ; while ( 1 ) { if ( getSum ( i ) == N ) { cout << i ; break ; } i ++ ; } } int main ( ) { int N = 10 ; smallestNumber ( N ) ; return 0 ; },Find the smallest number whose sum of digits is N.
363,Rare Numbers | C ++ implementation to check if N is a Rare number ; Iterative function to reverse digits of num ; Function to check if N is perfect square ; Find floating point value of square root of x . ; If square root is an integer ; Function to check if N is an Rare number ; Find reverse of N ; Number should be non - palindromic ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } bool isRare ( int N ) { int reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; } int main ( ) { int n = 65 ; if ( isRare ( n ) ) cout << "" Yes "" ; else cout << "" No "" ; return 0 ; }",Rare Numbers.
364,"Count numbers from range whose prime factors are only 2 and 3 using Arrays | Set 2 | C ++ program to count the elements in the range [ L , R ] whose prime factors are only 2 and 3. ; Function which will calculate the elements in the given range ; Store the current power of 2 ; Store the current power of 3 ; power23 [ ] will store pairwise product of elements of power2 and power3 that are <= r ; Insert in power23 ] [ ] only if mul <= r ; Store the required answer ; Print the result ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void calc_ans ( ll l , ll r ) { vector < ll > power2 , power3 ; ll mul2 = 1 ; while ( mul2 <= r ) { power2 . push_back ( mul2 ) ; mul2 *= 2 ; } ll mul3 = 1 ; while ( mul3 <= r ) { power3 . push_back ( mul3 ) ; mul3 *= 3 ; } vector < ll > power23 ; for ( int x = 0 ; x < power2 . size ( ) ; x ++ ) { for ( int y = 0 ; y < power3 . size ( ) ; y ++ ) { ll mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ; if ( mul <= r ) power23 . push_back ( mul ) ; } } ll ans = 0 ; for ( ll x : power23 ) { if ( x >= l && x <= r ) ans ++ ; } cout << ans << endl ; } int main ( ) { ll l = 1 , r = 10 ; calc_ans ( l , r ) ; return 0 ; }",Count numbers from range whose prime factors are only 2 and 3 using Arrays.
365,Count of K length subsequence whose product is even | C ++ implementation to Count of K length subsequence whose Product is even ; Function to calculate nCr ; Returns factorial of n ; Function for finding number of K length subsequences whose product is even number ; counting odd numbers in the array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) ; int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int countSubsequences ( int arr [ ] , int n , int k ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 4 } ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequences ( arr , N , K ) ; return 0 ; }",Count of K length subsequence whose product is even.
366,Find most significant bit of a number X in base Y | C ++ Program to find the first digit of X in base Y ; Function to find the first digit of X in base Y ; calculating number of digits of x in base y ; finding first digit of x in base y ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void first_digit ( int x , int y ) { int length = log ( x ) / log ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; } int main ( ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; return 0 ; }",Find most significant bit of a number X in base Y.
367,Curzon Numbers | C ++ implementation of the approach ; Function to check if a number is a Curzon number or not ; Find 2 ^ N + 1 ; Find 2 * N + 1 ; Check for divisibility ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkIfCurzonNumber ( int N ) { long int powerTerm , productTerm ; powerTerm = pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; } int main ( ) { long int N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; return 0 ; }",Curzon Numbers.
368,Minimum count of numbers required ending with 7 to sum as a given number | C ++ implementation of the approach ; Function to return the count of minimum numbers ending with 7 required such that the sum of these numbers is n ; hasharr [ i ] will store the minimum numbers ending with 7 so that it sums to number ending with digit i ; Its always possible to write numbers > 69 to write as numbers ending with 7 ; If the number is atleast equal to the sum of minimum numbers ending with 7 ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TEN = 10 ; int minCount ( int n ) { int hasharr [ TEN ] = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % TEN ] ; else { if ( n >= hasharr [ n % TEN ] * 7 ) return ( hasharr [ n % TEN ] ) ; else return -1 ; } } int main ( ) { int n = 38 ; cout << minCount ( n ) ; return 0 ; }",Minimum count of numbers required ending with 7 to sum as a given number.
369,Program to print modified Binary triangle pattern | C ++ implementation to print the modified binary triangle pattern ; Function to print the modified binary pattern ; Loop to traverse the rows ; Loop to traverse the numbers in each row ; Check if j is 1 or i In either case print 1 ; Else print 0 ; Change the cursor to next line after each row ; Driver Code ; Function Call,#include <bits/stdc++.h> NEW_LINE using namespace std ; void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) cout << 1 ; else cout << 0 ; } cout << endl ; } } int main ( ) { int n = 7 ; modifiedBinaryPattern ( n ) ; },Program to print modified Binary triangle pattern.
370,Find the real and imaginary part of a Complex number | C ++ program to find the real and imaginary parts of a Complex Number ; Function to find real and imaginary parts of a complex number ; string length stored in variable l ; variable for the index of the separator ; Storing the index of ' + ' ; else storing the index of ' - ' ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRealAndImag ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - i - 2 ) ; cout << "" Real ▁ part : ▁ "" << real << "" STRNEWLINE "" ; cout << "" Imaginary ▁ part : ▁ "" << imaginary << "" STRNEWLINE "" ; } int main ( ) { string s = ""3 + 4i "" ; findRealAndImag ( s ) ; return 0 ; }",Find the real and imaginary part of a Complex number.
371,"Distinct powers of a number N such that the sum is equal to K | C ++ implementation to find distinct powers of N that add upto K ; Function to return the highest power of N not exceeding K ; Loop to find the highest power less than K ; Initializing the PowerArray with all 0 's. ; Function to print the distinct powers of N that add upto K ; Getting the highest power of n before k ; To check if the power is being used twice or not ; Print - 1 if power is being used twice ; If the power is not visited , then mark the power as visited ; Decrementing the value of K ; Printing the powers of N that sum up to K ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPower ( int n , int k ) { int i = 0 ; int a = pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = pow ( n , i ) ; } return i - 1 ; } int b [ 50 ] = { 0 } ; int PowerArray ( int n , int k ) { while ( k ) { int t = highestPower ( n , k ) ; if ( b [ t ] ) { cout << -1 ; return 0 ; } else b [ t ] = 1 ; k -= pow ( n , t ) ; } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] ) { cout << i << "" , ▁ "" ; } } } int main ( ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; return 0 ; }",Distinct powers of a number N such that the sum is equal to K.
372,"Sum of elements in an array having composite frequency | C ++ program to find sum of elements in an array having composite frequency ; Function to create Sieve to check primes ; If composite [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to composite ; Function to return the sum of elements in an array having composite frequency ; Map is used to store element frequencies ; To store sum ; Traverse the map using iterators ; Count the number of elements having composite frequencies ; Driver code ; Function call","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( vector < bool > & composite ) { for ( int i = 0 ; i < N ; i ++ ) composite [ i ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( int i = p * 2 ; i < N ; i += p ) composite [ i ] = true ; } } } int sumOfElements ( int arr [ ] , int n ) { vector < bool > composite ( N ) ; SieveOfEratosthenes ( composite ) ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( composite [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfElements ( arr , n ) ; return 0 ; }",Sum of elements in an array having composite frequency.
373,Delete all odd frequency elements from an Array | C ++ program to removes all odd frequency elements from an Array ; Function that removes the elements which have odd frequencies in the array ; Create a map to store the frequency of each element ; Remove the elements which have odd frequencies ; If the element has odd frequency then skip ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void remove ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( m [ arr [ i ] ] & 1 ) ) continue ; cout << arr [ i ] << "" , ▁ "" ; } } int main ( ) { int arr [ ] = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; remove ( arr , n ) ; return 0 ; }",Delete all odd frequency elements from an Array.
374,Maximize the first element of the array such that average remains constant | C ++ implementation of to maximize the first element of the array such that average of the array remains constant ; Maximum value of the first array element that can be attained ; Variable to store the sum ; Loop to find the sum of array ; Desired maximum value ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getmax ( arr , arr_size , x ) ; return 0 ; }",Maximize the first element of the array such that average remains constant.
375,"Minimum length of the shortest path of a triangle | C ++ program to illustrate the above problem ; function to get the minimum length of the shorter side of the triangle ; traversing through each points on the plane ; if sum of a points is greater than the previous one , the maximum gets replaced ; print the length ; Driver code ; initialize the number of points ; points on the plane","#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << "" Length ▁ - > ▁ "" << answer << endl ; cout << "" Path ▁ - > ▁ "" << "" ( ▁ 1 , ▁ "" << answer << "" ▁ ) "" << "" and ▁ ( ▁ "" << answer << "" , ▁ 1 ▁ ) "" ; } int main ( ) { int n = 4 ; int x [ n ] = { 1 , 4 , 2 , 1 } ; int y [ n ] = { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; return 0 ; }",Minimum length of the shortest path of a triangle.
376,Intersecting rectangle when bottom | CPP program to find intersection rectangle of given two rectangles . ; function to find intersection rectangle of given two rectangles . ; gives bottom - left point of intersection rectangle ; gives top - right point of intersection rectangle ; no intersection ; gives top - left point of intersection rectangle ; gives bottom - right point of intersection rectangle ; Driver code ; bottom - left and top - right corners of first rectangle ; bottom - left and top - right corners of first rectangle ; function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << "" No ▁ intersection "" ; return ; } cout << "" ( "" << x5 << "" , ▁ "" << y5 << "" ) ▁ "" ; cout << "" ( "" << x6 << "" , ▁ "" << y6 << "" ) ▁ "" ; int x7 = x5 ; int y7 = y6 ; cout << "" ( "" << x7 << "" , ▁ "" << y7 << "" ) ▁ "" ; int x8 = x6 ; int y8 = y5 ; cout << "" ( "" << x8 << "" , ▁ "" << y8 << "" ) ▁ "" ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; return 0 ; }",Intersecting rectangle when bottom.
377,Find Corners of Rectangle using mid points | C ++ program to find corner points of a rectangle using given length and middle points . ; Structure to represent a co - ordinate point ; This function receives two points and length of the side of rectangle and prints the 4 corner points of the rectangle ; horizontal rectangle ; vertical rectangle ; slanted rectangle ; calculate slope of the side ; calculate displacements along axes ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Point { float x , y ; Point ( ) { x = y = 0 ; } Point ( float a , float b ) { x = a , y = b ; } } ; void printCorners ( Point p , Point q , float l ) { Point a , b , c , d ; if ( p . x == q . x ) { a . x = p . x - ( l / 2.0 ) ; a . y = p . y ; d . x = p . x + ( l / 2.0 ) ; d . y = p . y ; b . x = q . x - ( l / 2.0 ) ; b . y = q . y ; c . x = q . x + ( l / 2.0 ) ; c . y = q . y ; } else if ( p . y == q . y ) { a . y = p . y - ( l / 2.0 ) ; a . x = p . x ; d . y = p . y + ( l / 2.0 ) ; d . x = p . x ; b . y = q . y - ( l / 2.0 ) ; b . x = q . x ; c . y = q . y + ( l / 2.0 ) ; c . x = q . x ; } else { float m = ( p . x - q . x ) / float ( q . y - p . y ) ; float dx = ( l / sqrt ( 1 + ( m * m ) ) ) * 0.5 ; float dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } cout << a . x << "" , ▁ "" << a . y << "" ▁ n "" << b . x << "" , ▁ "" << b . y << "" n "" ; << c . x << "" , ▁ "" << c . y << "" ▁ n "" << d . x << "" , ▁ "" << d . y << "" nn "" ; } int main ( ) { Point p1 ( 1 , 0 ) , q1 ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; Point p ( 1 , 1 ) , q ( -1 , -1 ) ; printCorners ( p , q , 2 * sqrt ( 2 ) ) ; return 0 ; }",Find Corners of Rectangle using mid points.
378,Minimize cost to modify the Array such that even indices have even elements and vice versa | C ++ program for the above approach ; Function to find the minimum cost to modify the array according to the given criteria ; Count of wrong positioned odd and even elements ; Odd Count ; Even Count ; Swapping Cost ; Decrementing cost after swapping ; Only decrementing cost ; Return the minimum cost of the two cases ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } int cost1 = X * min ( odd_count , even_count ) ; int cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return min ( cost1 + cost2 , cost3 ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumCost ( arr , N , X , Y ) ; return 0 ; }",Minimize cost to modify the Array such that even indices have even elements and vice versa.
379,Minimum product of maximum and minimum element over all possible subarrays | C ++ program for the above approach ; Function to find the minimum product of the minimum and maximum among all the possible subarrays ; Stores resultant minimum product ; Traverse the given array arr [ ] ; Min of product of all two pair of consecutive elements ; Return the resultant value ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinMax ( vector < int > & a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . size ( ) ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; } int main ( ) { vector < int > arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; cout << findMinMax ( arr ) ; return 0 ; }",Minimum product of maximum and minimum element over all possible subarrays.
380,"Sum of all nodes with smaller values at a distance K from a given node in a BST | C ++ program for the above approach ; Structure of Tree ; Constructor ; Function to add the node to the sum below the target node ; Base Case ; If Kth distant node is reached ; Recur for the left and the right subtrees ; Function to find the K distant nodes from target node , it returns - 1 if target node is not present in tree ; Base Case 1 ; If target is same as root . ; Recurr for the left subtree ; Tree is BST so reduce the search space ; Check if target node was found in left subtree ; If root is at distance k from the target ; Node less than target will be present in left ; When node is not present in the left subtree ; If Kth distant node is reached ; Node less than target at k distance maybe present in the left tree ; If target was not present in the left nor in right subtree ; Function to insert a node in BST ; If root is NULL ; Insert the data in right half ; Insert the data in left half ; Return the root node ; Function to find the sum of K distant nodes from the target node having value less than target node ; Stores the sum of nodes having values < target at K distance ; Print the resultant sum ; Driver Code ; Create the Tree","#include <bits/stdc++.h> NEW_LINE using namespace std ; struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; void kDistanceDownSum ( TreeNode * root , int k , int & sum ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { sum += root -> data ; return ; } kDistanceDownSum ( root -> left , k - 1 , sum ) ; kDistanceDownSum ( root -> right , k - 1 , sum ) ; } int kDistanceSum ( TreeNode * root , int target , int k , int & sum ) { if ( root == NULL ) return -1 ; if ( root -> data == target ) { kDistanceDownSum ( root -> left , k - 1 , sum ) ; return 0 ; } int dl = -1 ; if ( target < root -> data ) { dl = kDistanceSum ( root -> left , target , k , sum ) ; } if ( dl != -1 ) { if ( dl + 1 == k ) sum += root -> data ; return -1 ; } int dr = -1 ; if ( target > root -> data ) { dr = kDistanceSum ( root -> right , target , k , sum ) ; } if ( dr != -1 ) { if ( dr + 1 == k ) sum += root -> data ; else kDistanceDownSum ( root -> left , k - dr - 2 , sum ) ; return 1 + dr ; } return -1 ; } TreeNode * insertNode ( int data , TreeNode * root ) { if ( root == NULL ) { TreeNode * node = new TreeNode ( data ) ; return node ; } else if ( data > root -> data ) { root -> right = insertNode ( data , root -> right ) ; } else if ( data <= root -> data ) { root -> left = insertNode ( data , root -> left ) ; } return root ; } void findSum ( TreeNode * root , int target , int K ) { int sum = 0 ; kDistanceSum ( root , target , K , sum ) ; cout << sum ; } int main ( ) { TreeNode * root = NULL ; int N = 11 ; int tree [ ] = { 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 } ; for ( int i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } int target = 7 ; int K = 2 ; findSum ( root , target , K ) ; return 0 ; }",Sum of all nodes with smaller values at a distance K from a given node in a BST.
381,Find Nth item distributed from infinite items of infinite types based on given conditions | C ++ program for the above approach ; Function to find the type of the item given out according to the given rules ; Stores the count of item given out at each step ; Iterate over the days from 1 ; Iterate over type of item on that day ; Count of items given out should exceed n ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; },Find Nth item distributed from infinite items of infinite types based on given conditions.
382,Find the sum of all array elements that are equidistant from two consecutive powers of 2 | C ++ program for the above approach ; Function to print the sum of array elements that are equidistant from two consecutive powers of 2 ; Stores the resultant sum of the array elements ; Traverse the array arr [ ] ; Stores the power of 2 of the number arr [ i ] ; Stores the number which is power of 2 and lesser than or equal to arr [ i ] ; Stores the number which is power of 2 and greater than or equal to arr [ i ] ; If arr [ i ] - LesserValue is the same as LargerValue - arr [ i ] ; Increment res by arr [ i ] ; Return the resultant sum res ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindSum ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = log2 ( arr [ i ] ) ; int LesserValue = pow ( 2 , power ) ; int LargerValue = pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; } int main ( ) { int arr [ ] = { 10 , 24 , 17 , 3 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << FindSum ( arr , N ) ; return 0 ; }",Find the sum of all array elements that are equidistant from two consecutive powers of 2.
383,"Find the person who will finish last | C ++ program for the above approach ; Function to find the person who will finish last ; To keep track of rows and columns having 1 ; Available rows and columns ; Minimum number of choices we have ; If number of choices are odd ; P1 will finish last ; Otherwise , P2 will finish last ; Given matrix","#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLast ( int mat [ ] [ 3 ] ) { int m = 3 ; int n = 3 ; set < int > rows ; set < int > cols ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . insert ( i ) ; cols . insert ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = min ( avRows , avCols ) ; if ( choices & 1 ) cout << "" P1"" ; else cout << "" P2"" ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; }",Find the person who will finish last.
384,"Sum of decimals that are binary representations of first N natural numbers | C ++ program for the above approach ; Function to find the sum of first N natural numbers represented in binary representation ; Stores the resultant sum ; Iterate until the value of N is greater than 0 ; If N is less than 2 ; Store the MSB position of N ; Iterate in the range [ 1 , x ] and add the contribution of the numbers from 1 to ( 2 ^ x - 1 ) ; Update the value of the cur and add ; Add the cur to ans ; Store the remaining numbers ; Add the contribution by MSB by the remaining numbers ; The next iteration will be repeated for 2 ^ x - 1 ; Print the result ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1e9 + 7 ; void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( 1 ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = log2 ( n ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } cout << ans ; } int main ( ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; return 0 ; }",Sum of decimals that are binary representations of first N natural numbers.
385,Nearest Fibonacci Number to N | C ++ program for the above approach ; Function to find the Fibonacci number which is nearest to N ; Base Case ; Initialize the first & second terms of the Fibonacci series ; Store the third term ; Iterate until the third term is less than or equal to num ; Update the first ; Update the second ; Update the third ; Store the Fibonacci number having smaller difference with N ; Print the result ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestFibonacci ( int num ) { if ( num == 0 ) { cout << 0 ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( abs ( third - num ) >= abs ( second - num ) ) ? second : third ; cout << ans ; } int main ( ) { int N = 17 ; nearestFibonacci ( N ) ; return 0 ; }",Nearest Fibonacci Number to N.
386,"Permutation of first N natural numbers having given array as the prefix maximum array | C ++ program for the above approach ; Function to check if the maximum prefix array of ans [ ] is equal to array arr [ ] ; Initialize a variable , Max ; Traverse the array , ans [ ] ; Store the maximum value upto index i ; If it is not equal to a [ i ] , then return false ; Otherwise return false ; Function to find the permutation of the array whose prefix maximum array is same as the given array a [ ] ; Stores the required permutation ; Stores the index of first occurrence of elements ; Traverse the array a [ ] ; If a [ i ] is not present in um , then store it in um ; Update the ans [ i ] to a [ i ] ; Stores the unvisited numbers ; Fill the array , v [ ] ; Store the index ; Traverse the array , ans [ ] ; Fill v [ j ] at places where ans [ i ] is 0 ; Check if the current permutation maximum prefix array is same as the given array a [ ] ; If true , the print the permutation ; Otherwise , print - 1 ; Driver Code ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPermutation ( int ans [ ] , int a [ ] , int n ) { int Max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { Max = max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } void findPermutation ( int a [ ] , int n ) { int ans [ n ] = { 0 } ; unordered_map < int , int > um ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . find ( a [ i ] ) == um . end ( ) ) { ans [ i ] = a [ i ] ; um [ a [ i ] ] = i ; } } vector < int > v ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( um . find ( i ) == um . end ( ) ) { v . push_back ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << "" ▁ "" ; } } else cout << "" - 1"" ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPermutation ( arr , N ) ; return 0 ; }",Permutation of first N natural numbers having given array as the prefix maximum array.
387,Count pairs of equal elements possible by excluding each array element once | C ++ program for the above approach ; Function to count the number of required pairs for every array element ; Initialize a map ; Update the frequency of every element ; Stores the count of pairs ; Traverse the map ; Count the number of ways to select pairs consisting of equal elements only ; Traverse the array ; Print the count for every array element ; Driver code ; Given array ; Size of the array,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEqualElementPairs ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; } int total = 0 ; for ( auto i : mp ) { total += ( i . second * ( i . second - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { cout << total - ( mp [ arr [ i ] ] - 1 ) << "" ▁ "" ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEqualElementPairs ( arr , N ) ; }",Count pairs of equal elements possible by excluding each array element once.
388,Count of Octal numbers upto N digits | C ++ program to find the count of natural octal numbers upto N digits ; Function to return the count of natural octal numbers upto N digits ; Loop to iterate from 1 to N and calculating number of octal numbers for every ' i ' th digit . ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; } int main ( ) { int N = 4 ; cout << count ( N ) ; return 0 ; }",Count of Octal numbers upto N digits.
389,"Palindromic divisors of a number | C ++ program to find all the palindromic divisors of a number ; Function to check is num is palindromic or not ; Convert n to string str ; Starting and ending index of string str ; If char at s and e are not equals then return false ; Function to find palindromic divisors ; To sore the palindromic divisors of number n ; If n is divisible by i ; Check if number is a perfect square ; Check divisor is palindromic , then store it ; Check if divisors are palindrome ; Check if n / divisors is palindromic or not ; Print all palindromic divisors in sorted order ; Driver code ; Function call to find all palindromic divisors","#include "" bits / stdc + + . h "" NEW_LINE using namespace std ; bool isPalindrome ( int n ) { string str = to_string ( n ) ; int s = 0 , e = str . length ( ) - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; } void palindromicDivisors ( int n ) { vector < int > PalindromDivisors ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . push_back ( n / i ) ; } } } } sort ( PalindromDivisors . begin ( ) , PalindromDivisors . end ( ) ) ; for ( int i = 0 ; i < PalindromDivisors . size ( ) ; i ++ ) { cout << PalindromDivisors [ i ] << "" ▁ "" ; } } int main ( ) { int n = 66 ; palindromicDivisors ( n ) ; }",Palindromic divisors of a number.
390,Remove minimum numbers from the array to get minimum OR value | C ++ implementation of the approach ; Function to return the minimum deletions to get minimum OR ; To store the minimum element ; Find the minimum element from the array ; To store the frequency of the minimum element ; Find the frequency of the minimum element ; Return the final answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDel ( int * arr , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinDel ( arr , n ) ; return 0 ; }",Remove minimum numbers from the array to get minimum OR value.
391,Number of subarrays with GCD equal to 1 | C ++ implementation of the approach ; Function to return the required count ; To store the final answer ; To store the GCD starting from index ' i ' ; Loop to find the gcd of each subarray from arr [ i ] to arr [ i ... n - 1 ] ; Increment the count if curr_gcd = 1 ; Return the final answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubArr ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubArr ( arr , n ) ; return 0 ; }",Number of subarrays with GCD equal to 1.
392,Program to print prime numbers from 1 to N . | C ++ program to display first N Prime numbers ; Function to print first N prime numbers ; Declare the variables ; Print display message ; Traverse each number from 1 to N with the help of for loop ; Skip 0 and 1 as they are neither prime nor composite ; flag variable to tell if i is prime or not ; flag = 1 means i is prime and flag = 0 means i is not prime ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_primes_till_N ( int N ) { int i , j , flag ; cout << "" Prime numbers between 1 and "" << N < < "" ▁ are : STRNEWLINE "" ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << "" ▁ "" ; } } int main ( ) { int N = 100 ; print_primes_till_N ( N ) ; return 0 ; }",Program to print prime numbers from 1 to N ..
393,Maximize the expression ( A AND X ) * ( B AND X ) | Bit Manipulation | C ++ implementation of the approach ; Function to find X according to the given conditions ; int can have 32 bits ; Temporary ith bit ; Compute ith bit of X according to given conditions Expression below is the direct conclusion from the illustration we had taken earlier ; Add the ith bit of X to X ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  32 NEW_LINE int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; } int main ( ) { int A = 11 , B = 13 ; cout << findX ( A , B ) ; return 0 ; }",Maximize the expression ( A AND X ) * ( B AND X ).
394,Number of subsets whose mean is maximum | C ++ implementation of the approach ; Function to return the count of subsets with the maximum mean ; Maximum value from the array ; To store the number of times maximum element appears in the array ; Return the count of valid subsets ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubSets ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubSets ( arr , n ) ; return 0 ; }",Number of subsets whose mean is maximum.
395,"Probability that a random pair chosen from an array ( a [ i ] , a [ j ] ) has the maximum sum | C ++ implementation of the approach ; Function to return the probability of getting the maximum pair sum when a random pair is chosen from the given array ; Initialize the maximum sum , its count and the count of total pairs ; For every single pair ; Get the sum of the current pair ; If the sum is equal to the current maximum sum so far ; Increment its count ; If the sum is greater than the current maximum ; Update the current maximum and re - initialize the count to 1 ; Find the required probability ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; float findProb ( int arr [ ] , int n ) { long maxSum = INT_MIN , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findProb ( arr , n ) ; return 0 ; }","Probability that a random pair chosen from an array ( a [ i ] , a [ j ] ) has the maximum sum."
396,Maximum count of common divisors of A and B such that all are co | C ++ implementation of the approach ; Function to return the count of common factors of a and b such that all the elements are co - prime to one another ; GCD of a and b ; Include 1 initially ; Find all the prime factors of the gcd ; If gcd is prime ; Return the required answer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCommonFactors ( int a , int b ) { int gcd = __gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd /= i ; } } if ( gcd != 1 ) ans ++ ; return ans ; } int main ( ) { int a = 12 , b = 18 ; cout << maxCommonFactors ( a , b ) ; return 0 ; }",Maximum count of common divisors of A and B such that all are co.
397,"Find the day number in the current year for the given date | C ++ implementation of the approach ; Function to return the day number of the year for the given date ; Extract the year , month and the day from the date string ; If current year is a leap year and the date given is after the 28 th of February then it must include the 29 th February ; Add the days in the previous months ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 ) ) ; int month = stoi ( date . substr ( 5 , 2 ) ) ; int day = stoi ( date . substr ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; } int main ( ) { string date = ""2019-01-09"" ; cout << dayOfYear ( date ) ; return 0 ; }",Find the day number in the current year for the given date.
398,Find the number of cells in the table contains X | CPP program to find number of cells in the table contains X ; Function to find number of cells in the table contains X ; Driver code ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; } int main ( ) { int n = 6 , x = 12 ; cout << Cells ( n , x ) ; return 0 ; }",Find the number of cells in the table contains X.
399,Smallest power of 4 greater than or equal to N | C ++ implementation of above approach ; Function to return the smallest power of 4 greater than or equal to n ; If n is itself is a power of 4 then return n ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextPowerOfFour ( int n ) { int x = floor ( sqrt ( sqrt ( n ) ) ) ; if ( pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return pow ( x , 4 ) ; } } int main ( ) { int n = 122 ; cout << nextPowerOfFour ( n ) ; return 0 ; }",Smallest power of 4 greater than or equal to N.
400,"Minimum operations required to convert X to Y by multiplying X with the given co | C ++ implementation of the approach ; Function to return the minimum operations required ; Not possible ; To store the greatest power of p that divides d ; While divible by p ; To store the greatest power of q that divides d ; While divible by q ; If d > 1 ; Since , d = p ^ a * q ^ b ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) return -1 ; int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a ++ ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b ++ ; } if ( d != 1 ) return -1 ; return ( a + b ) ; } int main ( ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; cout << minOperations ( x , y , p , q ) ; return 0 ; }",Minimum operations required to convert X to Y by multiplying X with the given co.
401,Number of Quadruples with GCD equal to K | C ++ implementation of the approach ; Function to calculate NC4 ; Base case to calculate NC4 ; Function to return the count of required quadruples using Inclusion Exclusion ; Effective N ; Iterate over 2 to M ; Number of divisors of i till M ; Count stores the number of prime divisors occurring exactly once ; To prevent repetition of prime divisors ; If repetition of prime divisors present ignore this number ; If prime divisor count is odd subtract it from answer else add ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n ) { if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; } int countQuadruples ( int N , int K ) { int M = N / K ; int answer = nCr ( M ) ; for ( int i = 2 ; i < M ; i ++ ) { int j = i ; int temp2 = M / i ; int count = 0 ; int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; } int main ( ) { int N = 10 , K = 2 ; cout << countQuadruples ( N , K ) ; return 0 ; }",Number of Quadruples with GCD equal to K.
402,"Find the number which when added to the given ratio a : b , the ratio changes to c : d | C ++ implementation of the approach ; Function to return the required number X ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; } int main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; cout << getX ( a , b , c , d ) ; return 0 ; }","Find the number which when added to the given ratio a : b , the ratio changes to c : d."
403,Number of ways to arrange a word such that no vowels occur together | C ++ code for above approach ; Function to check if a character is vowel or consonent ; Function to calculate factorial of a number ; Calculating no of ways for arranging vowels ; Iterate the map and count the number of vowels and calculate no of ways to arrange vowels ; calculating no of ways to arrange the given word such that all vowels come together ; calculate no of ways to arrange vowels ; to store denominator of fraction ; count of consonents ; calculate the number of ways to arrange the word such that all vowels come together ; To calculate total number of permutations ; To store length of the given word ; denominator of fraction ; return total number of permutations of the given word ; Function to calculate number of permutations such that no vowels come together ; to store frequency of character ; count frequency of all characters ; calculate total number of permutations ; calculate total number of permutations such that all vowels come together ; substrat vwl_tgthr from total to get the result ; return the result ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; } ll fact ( ll n ) { if ( n < 2 ) return 1 ; return n * fact ( n - 1 ) ; } ll only_vowels ( map < char , int > & freq ) { ll denom = 1 ; ll cnt_vwl = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_vwl += itr -> second ; } } return fact ( cnt_vwl ) / denom ; } ll all_vowels_together ( map < char , int > & freq ) { ll vow = only_vowels ( freq ) ; ll denom = 1 ; ll cnt_cnst = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( ! isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_cnst += itr -> second ; } } ll ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; } ll total_permutations ( map < char , int > & freq ) { ll cnt = 0 ; ll denom = 1 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { denom *= fact ( itr -> second ) ; cnt += itr -> second ; } return fact ( cnt ) / denom ; } ll no_vowels_together ( string & word ) { map < char , int > freq ; for ( int i = 0 ; i < word . size ( ) ; i ++ ) { char ch = tolower ( word [ i ] ) ; freq [ ch ] ++ ; } ll total = total_permutations ( freq ) ; ll vwl_tgthr = all_vowels_together ( freq ) ; ll res = total - vwl_tgthr ; return res ; } int main ( ) { string word = "" allahabad "" ; ll ans = no_vowels_together ( word ) ; cout << ans << endl ; word = "" geeksforgeeks "" ; ans = no_vowels_together ( word ) ; cout << ans << endl ; word = "" abcd "" ; ans = no_vowels_together ( word ) ; cout << ans << endl ; return 0 ; }",Number of ways to arrange a word such that no vowels occur together.
404,Program to find the number of men initially | C ++ implementation of above approach . ; Function to return the number of men initially ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; } int main ( ) { int D = 5 , m = 4 , d = 4 ; cout << numberOfMen ( D , m , d ) ; return 0 ; }",Program to find the number of men initially.
405,Area of triangle formed by the axes of co | C ++ program area of triangle formed by the axes of co - ordinates and a given straight line ; Function to find area ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double area ( double a , double b , double c ) { double d = fabs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; } int main ( ) { double a = -2 , b = 4 , c = 3 ; cout << area ( a , b , c ) ; return 0 ; }",Area of triangle formed by the axes of co.
406,Sum of two numbers where one number is represented as array of digits | C ++ implementation of the approach ; Function to return the vector containing the answer ; Vector v is to store each digits sum and vector ans is to store the answer ; No carry in the beginning ; Start loop from the end and take element one by one ; Array index and last digit of number ; Maintain carry of summation ; Push the digit value into the array ; K value is greater then 0 ; Push digits of K one by one in the array ; Also maintain carry with summation ; Reverse the elements of vector v and store it in vector ans ; Driver code ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > addToArrayForm ( vector < int > & A , int K ) { vector < int > v , ans ; int rem = 0 ; int i = 0 ; for ( i = A . size ( ) - 1 ; i >= 0 ; i -- ) { int my = A [ i ] + K % 10 + rem ; if ( my > 9 ) { rem = 1 ; v . push_back ( my % 10 ) ; } else { v . push_back ( my ) ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { int my = K % 10 + rem ; v . push_back ( my % 10 ) ; if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v . push_back ( rem ) ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) ans . push_back ( v [ i ] ) ; return ans ; } int main ( ) { vector < int > A { 2 , 7 , 4 } ; int K = 181 ; vector < int > ans = addToArrayForm ( A , K ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] ; return 0 ; }",Sum of two numbers where one number is represented as array of digits.
407,Compute maximum of the function efficiently over all sub | C ++ implementation of the above approach ; Function to return maximum sum of a sub - array ; Function to return maximum value of function F ; Compute arrays B [ ] and C [ ] ; Find maximum sum sub - array of both of the arrays and take maximum among them ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define MAX  100005 NEW_LINE using namespace std ; int kadaneAlgorithm ( const int * ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = max ( maxSum , sum ) ; } return maxSum ; } int maxFunction ( const int * arr , int n ) { int b [ MAX ] , c [ MAX ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i & 1 ) { b [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxFunction ( arr , n ) ; return 0 ; }",Compute maximum of the function efficiently over all sub.
408,Third last digit in 5 ^ N for given N | C ++ implementation of the above approach ; Function to find the element ; if n < 3 ; If n is even return 6 If n is odd return 1 ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; } int main ( ) { int n = 7 ; cout << findThirdDigit ( n ) ; return 0 ; },Third last digit in 5 ^ N for given N.
409,Probability of A winning the match when individual probabilities of hitting the target given | C ++ implementation of the approach ; Function to return the probability of A winning ; p and q store the values of fractions a / b and c / d ; To store the winning probability of A ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } int main ( ) { int a = 1 , b = 2 , c = 10 , d = 11 ; cout << getProbability ( a , b , c , d ) ; return 0 ; }",Probability of A winning the match when individual probabilities of hitting the target given.
410,Largest palindromic number in an array | C ++ implementation of above approach ; Function to check if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digits are not same then return false ; Removing the leading and trailing digits from the number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function to find the largest palindromic number ; If a palindrome larger than the currentMax is found ; Return the largest palindromic number from the array ; Driver program ; print required answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } int largestPalindrome ( int A [ ] , int n ) { int currentMax = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; } int main ( ) { int A [ ] = { 1 , 232 , 54545 , 999991 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << largestPalindrome ( A , n ) ; return 0 ; }",Largest palindromic number in an array.
411,Reduce the array to a single element with the given operation | C ++ implementation of the approach ; Function to return the final element ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; } int main ( ) { int N = 12 ; cout << getFinalElement ( N ) ; return 0 ; },Reduce the array to a single element with the given operation.
412,"Sum of elements in an array having prime frequency | C ++ program to find sum of elements in an array having prime frequency ; Function to create Sieve to check primes ; False here indicates that it is not prime ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to return the sum of elements in an array having prime frequency ; Map is used to store element frequencies ; Traverse the map using iterators ; Count the number of elements having prime frequencies ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int sumOfElements ( int arr [ ] , int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , n + 1 ) ; int i , j ; unordered_map < int , int > m ; for ( i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; } int main ( ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfElements ( arr , n ) ; return 0 ; }",Sum of elements in an array having prime frequency.
413,"Sum of all odd length palindromic numbers within the range [ L , R ] | C ++ program to find the sum of all odd length palindromic numbers within the given range ; Function that returns true if the given number is a palindrome ; Here we are generating a new number ( reverse_num ) * by reversing the digits of original input number ; If the original input number ( num ) is equal to * to its reverse ( reverse_num ) then its palindrome * else it is not . ; Function that returns true if the given number is of odd length ; Function to return the sum of all odd length palindromic numbers within the given range ; if number is palindrome and of odd length ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) { return true ; } return false ; } bool isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; } int main ( ) { int L = 110 , R = 1130 ; cout << "" ▁ "" << sumOfAllPalindrome ( L , R ) << endl ; }","Sum of all odd length palindromic numbers within the range [ L , R ]."
414,Number of ways to arrange a word such that all vowels occur together | C ++ program to calculate the no . of ways to arrange the word having vowels together ; Factorial of a number ; calculating ways for arranging consonants ; Ignore vowels ; calculating ways for arranging vowels ; Function to count total no . of ways ; Count vowels and consonant ; total no . of ways ; Driver code,"#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll fact ( int n ) { ll f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; } ll waysOfConsonants ( int size1 , int freq [ ] ) { ll ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; } ll waysOfVowels ( int size2 , int freq [ ] ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; } ll countWays ( string str ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; } int main ( ) { string str = "" geeksforgeeks "" ; cout << countWays ( str ) << endl ; return 0 ; }",Number of ways to arrange a word such that all vowels occur together.
415,Sum of Fibonacci Numbers with alternate negatives | C ++ Program to find alternate sum of Fibonacci numbers ; Computes value of first fibonacci numbers and stores their alternate sum ; Initialize result ; Add remaining terms ; For even terms ; For odd terms ; Return the alternating sum ; Driver program to test above function ; Get n ; Find the alternating sum,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; } int main ( ) { int n = 8 ; cout << "" Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ "" << n << "" ▁ terms : ▁ "" << calculateAlternateSum ( n ) << endl ; return 0 ; }",Sum of Fibonacci Numbers with alternate negatives.
416,Find nth Term of the Series 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | CPP Program to find Nth term ; Function that will return nth term ; Driver Code ; Get n ; Get the value ; Get n ; Get the value,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; } int main ( void ) { int n = 9 ; cout << getValue ( n ) << endl ; n = 1025 ; cout << getValue ( n ) << endl ; }",Find nth Term of the Series 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ....
417,"Construct a frequency array of digits of the values obtained from x ^ 1 , x ^ 2 , ... ... . . , x ^ n | CPP implementation of above approach ; Function that traverses digits in a number and modifies frequency count array ; Array to keep count of digits ; Traversing through x ^ 1 to x ^ n ; For power function , both its parameters are to be in double ; calling countDigits function on x ^ i ; Printing count of digits 0 - 9 ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void countDigits ( double val , long arr [ ] ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; } void countFrequency ( int x , int n ) { long freq_count [ 10 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { double val = pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { cout << freq_count [ i ] << "" ▁ "" ; } } int main ( ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; }","Construct a frequency array of digits of the values obtained from x ^ 1 , x ^ 2 , ... ... . . , x ^ n."
418,Number of values of b such that a = b + ( a ^ b ) | C ++ program to find the number of values of b such that a = b + ( a ^ b ) ; function to return the number of solutions ; check for every possible value ; Driver Code,#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; },Number of values of b such that a = b + ( a ^ b ).
419,Number of values of b such that a = b + ( a ^ b ) | C ++ program to find the number of values of b such that a = b + ( a ^ b ) ; function to return the number of solutions ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = __builtin_popcount ( a ) ; count = pow ( 2 , count ) ; return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; }",Number of values of b such that a = b + ( a ^ b ).
420,Sum of Area of all possible square inside a rectangle | CPP program to calculate the sum of area of all possible squares that comes inside the rectangle ; Function to calculate the sum of area of all possible squares that comes inside the rectangle ; Square with max size possible ; calculate total square of a given size ; calculate area of squares of a particular size ; total area ; increment size ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } int main ( ) { int l = 4 , b = 3 ; cout << calculateAreaSum ( l , b ) ; return 0 ; }",Sum of Area of all possible square inside a rectangle.
421,Hyperfactorial of a number | / C ++ program to find the hyperfactorial of a number ; function to calculate the value of hyperfactorial ; initialise the val to 1 ; returns the hyperfactorial of a number ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; }",Hyperfactorial of a number.
422,Hyperfactorial of a number | C ++ program to find the hyperfactorial of a number using boost libraries ; function to calculate the value of hyperfactorial ; initialise the val to 1 ; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . . ; returns the hyperfactorial of a number ; Driver code,#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace boost :: multiprecision ; using namespace std ; int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; },Hyperfactorial of a number.
423,Subtract 1 without arithmetic operators | C ++ code to subtract one from a given number ; Flip all the set bits until we find a 1 ; Flip the rightmost 1 bit ; Driver code,#include <iostream> NEW_LINE using namespace std ; int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << subtractOne ( 13 ) << endl ; return 0 ; },Subtract 1 without arithmetic operators.
424,Find the mean vector of a Matrix | C ++ program to find mean vector of given matrix ; Function to find mean vector ; loop to traverse each column ; to calculate mean of each row ; to store sum of elements of a column ; Drivers code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define rows  3 NEW_LINE #define cols  3 NEW_LINE void meanVector ( int mat [ rows ] [ cols ] ) { cout << "" [ ▁ "" ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << "" ▁ "" ; } cout << "" ] "" ; } int main ( ) { int mat [ rows ] [ cols ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; return 0 ; }",Find the mean vector of a Matrix.
425,"Hoax Number | CPP code to check if a number is a hoax number or not . ; Function to find distinct prime factors of given number n ; n is odd at this point , since it is no longer divisible by 2. So we can test only for the odd numbers , whether they are factors of n ; Check if i is prime factor ; This condition is to handle the case when n is a prime number greater than 2 ; Function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained ; Distinct prime factors of n are being stored in vector pf ; If n is a prime number , it cannot be a hoax number ; Finding sum of digits of distinct prime factors of the number n ; Finding sum of digits in current prime factor pf [ i ] . ; Finding sum of digits of number n ; Comparing the two calculated sums ; Driver Method","#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primeFactors ( int n ) { vector < int > res ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . push_back ( 2 ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . push_back ( i ) ; } } if ( n > 2 ) res . push_back ( n ) ; return res ; } bool isHoax ( int n ) { vector < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; } int main ( ) { int n = 84 ; if ( isHoax ( n ) ) cout << "" A ▁ Hoax ▁ Number STRNEWLINE "" ; else cout << "" Not ▁ a ▁ Hoax ▁ Number STRNEWLINE "" ; return 0 ; }",Hoax Number.
426,Primality Test | Set 5 ( Using Lucas | C ++ program to find out Lucas - Lehmer series . ; Function to find out first n terms ( considering 4 as 0 th term ) of Lucas - Lehmer series . ; the 0 th term of the series is 4. ; create an array to store the terms . ; compute each term and add it to the array . ; print out the terms one by one . ; Driver program,"#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void LucasLehmer ( int n ) { unsigned long long current_val = 4 ; vector < unsigned long long > series ; series . push_back ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . push_back ( current_val ) ; } for ( int i = 0 ; i <= n ; i ++ ) cout << "" Term ▁ "" << i << "" : ▁ "" << series [ i ] << endl ; } int main ( ) { int n = 5 ; LucasLehmer ( n ) ; return 0 ; }",Primality Test.
427,Modular multiplicative inverse from 1 to n | C ++ program to find modular inverse of all numbers from 1 to n using naive method ; A naive method to find modular multiplicative inverse of ' a ' under modulo ' prime ' ; Driver Program,"#include <iostream> NEW_LINE using namespace std ; int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return -1 ; } void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) cout << modInverse ( i , prime ) << "" ▁ "" ; } int main ( ) { int n = 10 , prime = 17 ; printModIverses ( n , prime ) ; return 0 ; }",Modular multiplicative inverse from 1 to n.
428,Convert to number with digits as 3 and 8 only | CPP to find min operations required to convert into charming number ; function for minimum operation ; remainder and operations count ; count digits not equal to 3 or 8 ; driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; } int main ( ) { long long int num = 234198 ; cout << "" Minimum ▁ Operations ▁ = "" << minOp ( num ) ; return 0 ; }",Convert to number with digits as 3 and 8 only.
429,Biggest integer which has maximum digit sum in range from 1 to n | CPP program to find the number with maximum digit sum . ; function to calculate the sum of digits of a number . ; Returns the maximum number with maximum sum of digits . ; initializing b as 1 and initial max sum to be of n ; iterates from right to left in a digit ; while iterating this is the number from from right to left ; calls the function to check if sum of cur is more then of ans ; reduces the number to one unit less ; driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( int a ) { int sum = 0 ; while ( a ) { sum += a % 10 ; a /= 10 ; } return sum ; } int findMax ( int x ) { int b = 1 , ans = x ; while ( x ) { int cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x /= 10 ; b *= 10 ; } return ans ; } int main ( ) { int n = 521 ; cout << findMax ( n ) ; return 0 ; }",Biggest integer which has maximum digit sum in range from 1 to n.
430,Interquartile Range ( IQR ) | CPP program to find IQR of a data set ; Function to give index of the median ; Function to calculate IQR ; Index of median of entire data ; Median of first half ; Median of second half ; IQR calculation ; Driver Function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int median ( int * a , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; } int IQR ( int * a , int n ) { sort ( a , a + n ) ; int mid_index = median ( a , 0 , n ) ; int Q1 = a [ median ( a , 0 , mid_index ) ] ; int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; } int main ( ) { int a [ ] = { 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << IQR ( a , n ) ; return 0 ; }",Interquartile Range ( IQR ).
431,Largest palindromic number in an array | C ++ implementation of above approach ; Function to check if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digits are not same then return false ; Removing the leading and trailing digits from the number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function to find the largest palindromic number ; Sort the array ; If number is palindrome ; If no palindromic number found ; Driver program ; print required answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } int largestPalindrome ( int A [ ] , int n ) { sort ( A , A + n ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return -1 ; } int main ( ) { int A [ ] = { 1 , 232 , 54545 , 999991 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << largestPalindrome ( A , n ) ; return 0 ; }",Largest palindromic number in an array.
432,Sum of the multiples of two numbers below N | C ++ program to find the sum of all the integers below N which are multiples of either A or B ; Function to return the sum of all the integers below N which are multiples of either A or B ; If i is a multiple of a or b ; Driver code,"#include <iostream> NEW_LINE using namespace std ; int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } int main ( ) { int n = 10 , a = 3 , b = 5 ; cout << findSum ( n , a , b ) ; return 0 ; }",Sum of the multiples of two numbers below N.
433,Subtract 1 without arithmetic operators | Driver program to test above functions,"#include <stdio.h> NEW_LINE int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } int main ( ) { printf ( "" % d "" , subtractOne ( 13 ) ) ; return 0 ; }",Subtract 1 without arithmetic operators.
434,Pell Number | Pell Number Series using Recursion in C ++ ; calculate nth pell number ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } int main ( ) { int n = 4 ; cout << "" ▁ "" << pell ( n ) ; return 0 ; }",Pell Number.
435,Finding LCM of more than two ( or array ) numbers without using GCD | C ++ program to find LCM of array without using GCD . ; Returns LCM of arr [ 0. . n - 1 ] ; Find the maximum value in arr [ ] ; Initialize result ; Find all factors that are present in two or more array elements . int x = 2 ; Current factor . ; To store indexes of all array elements that are divisible by x . ; If there are 2 or more array elements that are divisible by x . ; Reduce all array elements divisible by x . ; Then multiply all reduced array elements ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long int LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; unsigned long long int res = 1 ; while ( x <= max_num ) { vector < int > indexes ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push_back ( j ) ; if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( int i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LCM ( arr , n ) << "" STRNEWLINE "" ; return 0 ; }",Finding LCM of more than two ( or array ) numbers without using GCD.
436,Find politeness of a number | CPP program for the above approach ; Function to find politeness ; sqrt ( 2 * n ) as max length will be when the sum starts from 1 which follows the equation n ^ 2 - n - ( 2 * sum ) = 0 ; Driver program to test above function,"#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; } int main ( ) { int n = 90 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; n = 15 ; cout << "" Politness ▁ of ▁ "" << n << "" ▁ = ▁ "" << politness ( n ) << "" STRNEWLINE "" ; return 0 ; }",Find politeness of a number.
437,"Program for Goldbachâ €™ s Conjecture ( Two Primes with given Sum ) | C ++ program to implement Goldbach 's conjecture ; Array to store all prime less than and equal to 10 ^ 6 ; Utility function for Sieve of Sundaram ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half This array is used to separate numbers of the form i + j + 2 * i * j from others where 1 <= i <= j ; Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1 ; Since 2 is a prime number ; Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; Function to perform Goldbach 's conjecture ; Return if number is not even or less than 3 ; Check only upto half of number ; find difference by subtracting current prime from n ; Search if the difference is also a prime number ; Express as a sum of primes ; Driver code ; Finding all prime numbers before limit ; Express number as a sum of two primes","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } void findPrimes ( int n ) { if ( n <= 2 n % 2 != 0 ) { cout << "" Invalid ▁ Input ▁ STRNEWLINE "" ; return ; } for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { int diff = n - primes [ i ] ; if ( binary_search ( primes . begin ( ) , primes . end ( ) , diff ) ) { cout << primes [ i ] << "" ▁ + ▁ "" << diff << "" ▁ = ▁ "" << n << endl ; return ; } } } int main ( ) { sieveSundaram ( ) ; findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; return 0 ; }",Program for Goldbachâ €™ s Conjecture ( Two Primes with given Sum ).
438,"k | Program to print kth prime factor ; A function to generate prime factors of a given number n and return k - th prime factor ; Find the number of 2 's that divide k ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , store i and divide n ; This condition is to handle the case where n is a prime number greater than 2 ; Driver Program","# include <bits/stdc++.h> NEW_LINE using namespace std ; int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return -1 ; } int main ( ) { int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; return 0 ; }",k.
439,"k | C ++ program to find k - th prime factor using Sieve Of Eratosthenes . This program is efficient when we have a range of numbers . ; Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if MAX is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7 ; Create a boolean array "" prime [ 0 . . MAX ] "" and initialize all entries in it as false . ; Initializing smallest factor equal to 2 for all the even numbers ; For odd numbers less then equal to n ; s ( i ) for a prime is the number itself ; For all multiples of current prime number ; i is the smallest prime factor for number "" i * j "" . ; Function to generate prime factors and return its k - th prime factor . s [ i ] stores least prime factor of i . ; Keep dividing n by least prime factor while either n is not 1 or count of prime factors is not k . ; To keep track of count of prime factors ; Divide n to find next prime factor ; Driver Program ; s [ i ] is going to store prime factor of i .","#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10001 ; void sieveOfEratosthenes ( int s [ ] ) { vector < bool > prime ( MAX + 1 , false ) ; for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } int kPrimeFactor ( int n , int k , int s [ ] ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return -1 ; } int main ( ) { int s [ MAX + 1 ] ; memset ( s , -1 , sizeof ( s ) ) ; sieveOfEratosthenes ( s ) ; int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k , s ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k , s ) << endl ; return 0 ; }",k.
440,"Find sum of divisors of all the divisors of a natural number | C ++ program to find sum of divisors of all the divisors of a natural number . ; Returns sum of divisors of all the divisors of n ; Calculating powers of prime factors and storing them in a map mp [ ] . ; If n is a prime number ; For each prime factor , calculating ( p ^ ( a + 1 ) - 1 ) / ( p - 1 ) and adding it to answer . ; Driven Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDivisorsOfDivisors ( int n ) { map < int , int > mp ; for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count ) mp [ j ] = count ; } if ( n != 1 ) mp [ n ] = 1 ; int ans = 1 ; for ( auto it : mp ) { int pw = 1 ; int sum = 0 ; for ( int i = it . second + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw *= it . first ; } ans *= sum ; } return ans ; } int main ( ) { int n = 10 ; cout << sumDivisorsOfDivisors ( n ) ; return 0 ; }",Find sum of divisors of all the divisors of a natural number.
441,Nearest prime less than given number n | C ++ program for the above approach ; Function to return nearest prime number ; All prime numbers are odd except two ; It will only be executed when n is 3 ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int prime ( int n ) { if ( n & 1 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > sqrt ( i ) ) return i ; } return 2 ; } int main ( ) { int n = 17 ; cout << prime ( n ) ; return 0 ; }",Nearest prime less than given number n.
442,"Find Recurring Sequence in a Fraction | C ++ program to find repeating sequence in a fraction ; This function returns repeating sequence of a fraction . If repeating sequence doesn 't exits, then returns empty string ; Create a map to store already seen remainders remainder is used as key and its position in result is stored as value . Note that we need position for cases like 1 / 6. In this case , the recurring sequence doesn 't start from first  remainder. ; Find first remainder ; Keep finding remainder until either remainder becomes 0 or repeats ; Store this remainder ; Multiply remainder with 10 ; Append rem / denr to result ; Update remainder ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; string fractionToDecimal ( int numr , int denr ) { map < int , int > mp ; mp . clear ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denr ; res += to_string ( res_part ) ; rem = rem % denr ; } return ( rem == 0 ) ? "" "" : res . substr ( mp [ rem ] ) ; } int main ( ) { int numr = 50 , denr = 22 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == "" "" ) cout << "" No ▁ recurring ▁ sequence "" ; else cout << "" Recurring ▁ sequence ▁ is ▁ "" << res ; return 0 ; }",Find Recurring Sequence in a Fraction.
443,"Count numbers having 0 as a digit | C ++ program to count numbers from 1 to n with 0 as a digit ; Returns 1 if x has 0 , else 0 ; Traverse through all digits of x to check if it has 0. ; If current digit is 0 , return true ; Returns count of numbers from 1 to n with 0 as digit ; Initialize count of numbers having 0 as digit ; Traverse through all numbers and for every number check if it has 0. ; Driver program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int has0 ( int x ) { while ( x ) { if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; } int getCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; } int main ( ) { int n = 107 ; cout << "" Count ▁ of ▁ numbers ▁ from ▁ 1"" << "" ▁ to ▁ "" << n << "" ▁ is ▁ "" << getCount ( n ) ; }",Count numbers having 0 as a digit.
444,Euler 's criterion (Check if square root under modulo p exists) | A Simple C ++ program to check if square root of a number under modulo p exists or not ; Returns true if square root of n under modulo p exists ; One by one check all numbers from 2 to p - 1 ; Driver program to test,"#include <iostream> NEW_LINE using namespace std ; bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } int main ( ) { int p = 7 ; int n = 2 ; squareRootExists ( n , p ) ? cout << "" Yes "" : cout << "" No "" ; return 0 ; }",Euler 's criterion (Check if square root under modulo p exists).
445,"Legendre 's formula (Given p and n, find the largest x such that p^x divides n!) | C ++ program to find largest x such that p * x divides n ! ; Returns largest power of p that divides n ! ; Initialize result ; Calculate x = n / p + n / ( p ^ 2 ) + n / ( p ^ 3 ) + ... . ; Driver code","#include <iostream> NEW_LINE using namespace std ; int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; } int main ( ) { int n = 10 , p = 3 ; cout << "" The ▁ largest ▁ power ▁ of ▁ "" << p << "" ▁ that ▁ divides ▁ "" << n << "" ! ▁ is ▁ "" << largestPower ( n , p ) << endl ; return 0 ; }","Legendre 's formula (Given p and n, find the largest x such that p^x divides n!)."
446,Program for factorial of a number | C ++ program to find factorial of given number ; single line to find factorial ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << "" Factorial ▁ of ▁ "" << num << "" ▁ is ▁ "" << factorial ( num ) ; return 0 ; }",Program for factorial of a number.
447,All about Bit Manipulation | Function to get the bit at the ith position ; Return true if the bit is set . Otherwise return false,"boolean getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }",All about Bit Manipulation.
448,All about Bit Manipulation | Function to clear the ith bit of the given number N ; Create the mask for the ith bit unset ; Return the update value,"int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }",All about Bit Manipulation.
449,"Sum of Bitwise AND of each array element with the elements of another array | C ++ program for the above approach ; Function to compute the AND sum for each element of an array ; Declaring an array of size 32 for storing the count of each bit ; Traverse the array arr2 [ ] and store the count of a bit in frequency array ; Current bit position ; While num is greater than 0 ; Checks if ith bit is set or not ; Increment the count of bit by one ; Increment the bit position by one ; Right shift the num by one ; Traverse in the arr2 [ ] ; Store the ith bit value ; Total required sum ; Traverse in the range [ 0 , 31 ] ; Checks if current bit is set ; Increment the bitwise sum by frequency [ bit_position ] * value_at_that_bit ; ; Right shift num by one ; Left shift vale_at_that_bit by one ; Print the sum obtained for ith number in arr1 [ ] ; Driver Code ; Given arr1 [ ] ; Given arr2 [ ] ; Size of arr1 [ ] ; Size of arr2 [ ] ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_AND_sum << ' ▁ ' ; } return ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; return 0 ; }",Sum of Bitwise AND of each array element with the elements of another array.
450,"Turn off the rightmost set bit | Set 2 | C ++ program to unset the rightmost set bit ; Unsets the rightmost set bit of n and returns the result ; Checking whether bit position is set or not ; If bit position is found set , we flip this bit by xoring given number and number with bit position set ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1ll << bit ) ; break ; } } cout << "" The ▁ number ▁ after ▁ unsetting ▁ the "" ; cout << "" ▁ rightmost ▁ set ▁ bit ▁ "" << n ; } int main ( ) { int N = 12 ; FlipBits ( N ) ; return 0 ; }",Turn off the rightmost set bit.
451,"Bitwise AND of all the odd numbers from 1 to N | C ++ implementation of the approach ; Function to return the bitwise AND of all the odd integers from the range [ 1 , n ] ; Initialize result to 1 ; Starting from 3 , bitwise AND all the odd integers less than or equal to n ; Driver code",#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; },Bitwise AND of all the odd numbers from 1 to N.
452,"Bitwise AND of all the odd numbers from 1 to N | C ++ implementation of the approach ; Function to return the bitwise AND of all the odd integers from the range [ 1 , n ] ; Driver code",#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { return 1 ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; },Bitwise AND of all the odd numbers from 1 to N.
453,Reverse actual bits of the given number | C ++ implementation to reverse bits of a number ; function to reverse bits of a number ; traversing bits of ' n ' from the right ; bitwise left shift ' rev ' by 1 ; if current bit is '1' ; bitwise right shift ' n ' by 1 ; required number ; Driver program to test above,#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int reverseBits ( unsigned int n ) { unsigned int rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( n & 1 == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } int main ( ) { unsigned int n = 11 ; cout << reverseBits ( n ) ; return 0 ; },Reverse actual bits of the given number.
454,"Ways to split array into two groups of same XOR value | CPP Program to count number of ways to split array into two groups such that each group has equal XOR value ; Return the count number of ways to split array into two groups such that each group has equal XOR value . ; We can split only if XOR is 0. Since XOR of all is 0 , we can consider all subsets as one group . ; Driver Program","#include <bits/stdc++.h> NEW_LINE using namespace std ; int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countgroup ( a , n ) << endl ; return 0 ; }",Ways to split array into two groups of same XOR value.
455,Extract ' k ' bits from a given position in a number . | C ++ program to extract k bits from a given position . ; Function to extract k bits from p position and returns the extracted value as integer ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } int main ( ) { int number = 171 , k = 5 , p = 2 ; cout << "" The ▁ extracted ▁ number ▁ is ▁ "" << bitExtracted ( number , k , p ) ; return 0 ; }",Extract ' k ' bits from a given position in a number ..
456,Maximize a given unsigned number number by swapping bits at it 's extreme positions. | C ++ program to find maximum number by swapping extreme bits . ; Traverse bits from both extremes ; Obtaining i - th and j - th bits ; Swapping the bits if lesser significant is greater than higher significant bit and accordingly modifying the number ; Driver code,#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ull  unsigned long long int NEW_LINE ull findMax ( ull num ) { ull num_copy = num ; int j = sizeof ( unsigned long long int ) * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; } int main ( ) { ull num = 4 ; cout << findMax ( num ) ; return 0 ; },Maximize a given unsigned number number by swapping bits at it 's extreme positions..
457,"Efficiently check whether n is a multiple of 4 or not | C ++ implementation to efficiently check whether n is a multiple of 4 or not ; function to check whether ' n ' is a multiple of 4 or not ; if true , then ' n ' is a multiple of 4 ; else ' n ' is not a multiple of 4 ; Driver program to test above","#include <bits/stdc++.h> NEW_LINE using namespace std ; string isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return "" Yes "" ; return "" No "" ; } int main ( ) { int n = 16 ; cout << isAMultipleOf4 ( n ) ; return 0 ; }",Efficiently check whether n is a multiple of 4 or not.
458,"Calculate square of a number without using * , / and pow ( ) | Simple solution to calculate square without using * and pow ( ) ; handle negative input ; Initialize result ; Add n to res n - 1 times ; Driver code","#include <iostream> NEW_LINE using namespace std ; int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; } int main ( ) { for ( int n = 1 ; n <= 5 ; n ++ ) cout << "" n ▁ = ▁ "" << n << "" , ▁ n ^ 2 ▁ = ▁ "" << square ( n ) << endl ; return 0 ; }","Calculate square of a number without using * , / and pow ( )."
459,Find a point that lies inside exactly K given squares | C ++ implementation of the approach ; Driver Program to test above function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int PointInKSquares ( int n , int a [ ] , int k ) { sort ( a , a + n ) ; return a [ n - k ] ; } int main ( ) { int k = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = PointInKSquares ( n , a , k ) ; cout << "" ( "" << x << "" , ▁ "" << x << "" ) "" ; }",Find a point that lies inside exactly K given squares.
460,Number of n digit stepping numbers | Space optimized solution | CPP program to calculate the number of n digit stepping numbers . ; function that calculates the answer ; dp [ j ] stores count of i digit stepping numbers ending with digit j . ; To store result of length i - 1 before updating dp [ j ] for length i . ; if n is 1 then answer will be 10. ; Initialize values for count of digits equal to 1. ; Compute values for count of digits more than 1. ; If ending digit is 0 ; If ending digit is 9 ; For other digits . ; stores the final answer ; driver program to test the above function,#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( int n ) { int dp [ 10 ] ; int prev [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } int main ( ) { int n = 2 ; cout << answer ( n ) ; return 0 ; },Number of n digit stepping numbers.
461,Minimum changes required to make a Catalan Sequence | C ++ implementation of the approach ; To store first N Catalan numbers ; Function to find first n Catalan numbers ; Initialize first two values in table ; Fill entries in catalan [ ] using recursive formula ; Function to return the minimum changes required ; Find first n Catalan Numbers ; a and b are first two Catalan Sequence numbers ; Insert first n catalan elements to set ; If catalan element is present in the array then remove it from set ; Return the remaining number of elements in the set ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE #define ll  long long int NEW_LINE ll catalan [ MAX ] ; void catalanDP ( ll n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } int CatalanSequence ( int arr [ ] , int n ) { catalanDP ( n ) ; unordered_multiset < int > s ; int a = 1 , b = 1 ; int c ; s . insert ( a ) ; if ( n >= 2 ) s . insert ( b ) ; for ( int i = 2 ; i < n ; i ++ ) { s . insert ( catalan [ i ] ) ; } unordered_multiset < int > :: iterator it ; for ( int i = 0 ; i < n ; i ++ ) { it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) s . erase ( it ) ; } return s . size ( ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 41 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CatalanSequence ( arr , n ) ; return 0 ; }",Minimum changes required to make a Catalan Sequence.
462,Sum of all the Composite Numbers from Odd indices of the given array | C ++ implementation to find the sum of all the composite numbers from odd indices of the given array ; Function to check for composite numbers ; Check if the factors are greater than 2 ; Check if the number is composite or not ; Function to print the sum of all composite numbers in the array ; Iterate for odd indices in the array ; Check if the number is composite then add it to sum ; return the sum ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int composite ( int n ) { int flag = 0 ; int c = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } } if ( c >= 3 ) flag = 1 ; return flag ; } void odd_indices ( int arr [ ] , int n ) { int sum = 0 ; for ( int k = 0 ; k < n ; k += 2 ) { int check = composite ( arr [ k ] ) ; if ( check == 1 ) sum += arr [ k ] ; } cout << sum << endl ; } int main ( ) { int arr [ ] = { 13 , 5 , 8 , 16 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; odd_indices ( arr , n ) ; }",Sum of all the Composite Numbers from Odd indices of the given array.
463,Queries on count of points lie inside a circle | C ++ program to find number of points lie inside or on the circumference of circle for Q queries . ; Computing the x ^ 2 + y ^ 2 for each given points and sorting them . ; Return count of points lie inside or on circumference of circle using binary search on p [ 0. . n - 1 ] ; Driven Program ; Compute distances of all points and keep the distances sorted so that query can work in O ( logn ) using Binary Search . ; Print number of points in a circle of radius 3. ; Print number of points in a circle of radius 32.,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void preprocess ( int p [ ] , int x [ ] , int y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( p , p + n ) ; } int query ( int p [ ] , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = sqrt ( p [ start ] ) , tp2 = sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; } int main ( ) { int x [ ] = { 1 , 2 , 3 , -1 , 4 } ; int y [ ] = { 1 , 2 , 3 , -1 , 4 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; int p [ n ] ; preprocess ( p , x , y , n ) ; cout << query ( p , n , 3 ) << endl ; cout << query ( p , n , 32 ) << endl ; return 0 ; }",Queries on count of points lie inside a circle.
464,Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices | c ++ program to Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices ; function to find total number of ways ; No of odd indices in n - digit number ; No of even indices in n - digit number ; No of ways of arranging prime number digits in odd indices ; No of ways of arranging odd number digits in even indices ; returning the total number of ways ; drive code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = pow ( 4 , odd_indices ) ; int arr_even = pow ( 5 , even_indices ) ; return arr_odd * arr_even ; } int main ( ) { int n = 4 ; cout << find_Numb_ways ( n ) << endl ; return 0 ; }",Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices.
465,Check if a given array is sorted in Spiral manner or not | C ++ program to implement the above approach ; Function to check if the array is spirally sorted or not ; Stores start index of the array ; Stores end index of an array ; If arr [ start ] greater than arr [ end ] ; Update start ; If arr [ end ] greater than arr [ start ] ; Update end ; Driver Code ; Function Call,"#include <iostream> NEW_LINE using namespace std ; bool isSpiralSorted ( int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; } int main ( ) { int arr [ ] = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSpiralSorted ( arr , N ) ) cout << "" YES "" << endl ; else cout << "" NO "" << endl ; return 0 ; }",Check if a given array is sorted in Spiral manner or not.
466,Print all strings from given array that can be typed using keys from a single row of a QWERTY keyboard | C ++ program to implement the above approach ; Function to print all strings that can be typed using keys of a single row in a QWERTY Keyboard ; Stores row number of all possible character of the strings ; Traverse the array ; If current string is not an empty string ; Sets true / false if a string can be typed using keys of a single row or not ; Stores row number of the first character of current string ; Stores length of word ; Traverse current string ; If current character can 't be  typed using keys of rowNum only ; Update flag ; If current string can be typed using keys from rowNum only ; Print the string ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWordsSameRow ( vector < string > & arr ) { unordered_map < char , int > mp { { ' q ' , 1 } , { ' w ' , 1 } , { ' e ' , 1 } , { ' r ' , 1 } , { ' t ' , 1 } , { ' y ' , 1 } , { ' u ' , 1 } , { ' o ' , 1 } , { ' p ' , 1 } , { ' i ' , 1 } , { ' a ' , 2 } , { ' s ' , 2 } , { ' d ' , 2 } , { ' f ' , 2 } , { ' g ' , 2 } , { ' h ' , 2 } , { ' j ' , 2 } , { ' k ' , 2 } , { ' l ' , 2 } , { ' z ' , 3 } , { ' x ' , 3 } , { ' c ' , 3 } , { ' v ' , 3 } , { ' b ' , 3 } , { ' n ' , 3 } , { ' m ' , 3 } } ; for ( auto word : arr ) { if ( ! word . empty ( ) ) { bool flag = true ; int rowNum = mp [ tolower ( word [ 0 ] ) ] ; int M = word . length ( ) ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ tolower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { cout << word << "" ▁ "" ; } } } } int main ( ) { vector < string > words = { "" Yeti "" , "" Had "" , "" GFG "" , "" comment "" } ; findWordsSameRow ( words ) ; }",Print all strings from given array that can be typed using keys from a single row of a QWERTY keyboard.
467,Count quadruples of given type from given array | C ++ program of the above approach ; Function to find the count of the subsequence of given type ; Stores the count of quadruples ; Generate all possible combinations of quadruples ; Check if 1 st element is equal to 3 rd element ; Check if 2 nd element is equal to 4 th element ; Driver Code,"#include <iostream> NEW_LINE using namespace std ; const int maxN = 2002 ; int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequece ( a , 7 ) ; return 0 ; }",Count quadruples of given type from given array.
468,Smallest character in a string having minimum sum of distances between consecutive repetitions | C ++ program for the above approach ; Function to find the character repeats with minimum distance ; Stores the first and last index ; Initialize with - 1 ; Get the values of last and first occurence ; Update the first index ; Update the last index ; Initialize min ; Get the minimum ; Values must not be same ; Update the minimum distance ; return ans ; Driver Code ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; char minDistChar ( string s ) { int n = s . length ( ) ; int * first = new int [ 26 ] ; int * last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == -1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = INT_MAX ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = i + ' a ' ; } } return ans ; } int main ( ) { string str = "" geeksforgeeks "" ; cout << minDistChar ( str ) ; return 0 ; }",Smallest character in a string having minimum sum of distances between consecutive repetitions.
469,"Minimum steps required to reach the end of a matrix | Set 2 | C ++ implementation of the approach ; Function to return the minimum steps required to reach the end of the matrix ; Array to determine whether a cell has been visited before ; Queue for bfs ; Initializing queue ; To store the depth of search ; BFS algorithm ; Current queue size ; Top - most element of queue ; To store index of cell for simplicity ; Base case ; If we reach ( n - 1 , n - 1 ) ; Marking the cell visited ; Pushing the adjacent cells in the queue that can be visited from the current cell ; Driver code","#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int minSteps ( int arr [ ] [ n ] ) { bool v [ n ] [ n ] = { 0 } ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { pair < int , int > y = q . front ( ) ; int i = y . first , j = y . second ; q . pop ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( { i + arr [ i ] [ j ] , j } ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( { i , j + arr [ i ] [ j ] } ) ; } depth ++ ; } return -1 ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << minSteps ( arr ) ; return 0 ; }",Minimum steps required to reach the end of a matrix.
470,Largest gap in an array | A C ++ program to find largest gap between two elements in an array . ; function to solve the given problem ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , -4 , -10 , 22 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Largest ▁ gap ▁ is ▁ : ▁ "" << solve ( arr , size ) ; return 0 ; }",Largest gap in an array.
471,Largest gap in an array | A C ++ program to find largest gap between two elements in an array . ; function to solve the given problem ; finding maximum and minimum of an array ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -10 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << "" Largest ▁ gap ▁ is ▁ : ▁ "" << solve ( arr , size ) ; return 0 ; }",Largest gap in an array.
472,Print reverse string after removing vowels | CPP Program for removing characters from reversed string where vowels are present in original string ; Function for replacing the string ; initialize a string of length n ; Traverse through all characters of string ; assign the value to string r from last index of string s ; if s [ i ] is a consonant then print r [ i ] ; Driver function,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void replaceOriginal ( string s , int n ) { string r ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { cout << r [ i ] ; } } cout << endl ; } int main ( ) { string s = "" geeksforgeeks "" ; int n = s . length ( ) ; replaceOriginal ( s , n ) ; return 0 ; }",Print reverse string after removing vowels.
473,"Check if a string can be made equal to another string by swapping or replacement of characters | C ++ program for the above approach ; Function to find if given strings are same or not ; Base Condition ; Stores frequency of characters of the string str1 and str2 ; Traverse strings str1 & str2 and store frequencies in a [ ] and b [ ] ; Check if both strings have same characters or not ; If a character is present in one string and is not in another string , return false ; Sort the array a [ ] and b [ ] ; Check arrays a and b contain the same frequency or not ; If the frequencies are not the same after sorting ; At this point , str1 can be converted to str2 ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sameStrings ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N != M ) { return false ; } int a [ 256 ] = { 0 } , b [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { a [ str1 [ i ] - ' a ' ] ++ ; b [ str2 [ i ] - ' a ' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } sort ( a , a + 256 ) ; sort ( b , b + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( a [ i ] != b [ i ] ) return false ; } return true ; } int main ( ) { string S1 = "" cabbba "" , S2 = "" abbccc "" ; if ( sameStrings ( S1 , S2 ) ) cout << "" YES "" << endl ; else cout << "" ▁ NO "" << endl ; return 0 ; }",Check if a string can be made equal to another string by swapping or replacement of characters.
474,"Reduce given three Numbers by decrementing in Pairs | C ++ program for the above approach ; Function to find the minimum number operations ; Insert the three numbers in array ; Sort the array ; Case 2 ; Case 1 ; Driver Code ; Given A , B , C ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } int main ( ) { int A = 8 , B = 1 , C = 5 ; cout << solution ( A , B , C ) ; return 0 ; }",Reduce given three Numbers by decrementing in Pairs.
475,"Search an element in a sorted and rotated array with duplicates | C ++ implementation of the approach ; Function to return the index of the key in arr [ l . . h ] if the key is present otherwise return - 1 ; The tricky case , just update left and right ; If arr [ l ... mid ] is sorted ; As this subarray is sorted , we can quickly check if key lies in any of the halves ; If key does not lie in the first half subarray then divide the other half into two subarrays such that we can quickly check if key lies in the other half ; If arr [ l . . mid ] first subarray is not sorted then arr [ mid ... h ] must be sorted subarray ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) ; } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int key = 3 ; cout << search ( arr , 0 , n - 1 , key ) ; return 0 ; }",Search an element in a sorted and rotated array with duplicates.
476,Case | C ++ implementation of the approach ; Function to return the sorted string ; Vectors to store the lowercase and uppercase characters ; Sort both the vectors ; If current character is lowercase then pick the lowercase character from the sorted list ; Else pick the uppercase character ; Return the sorted string ; Driver code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; string getSortedString ( string s , int n ) { vector < char > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) v1 . push_back ( s [ i ] ) ; if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) v2 . push_back ( s [ i ] ) ; } sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( s [ k ] >= ' a ' && s [ k ] <= ' z ' ) { s [ k ] = v1 [ i ] ; ++ i ; } else if ( s [ k ] >= ' A ' && s [ k ] <= ' Z ' ) { s [ k ] = v2 [ j ] ; ++ j ; } } return s ; } int main ( ) { string s = "" gEeksfOrgEEkS "" ; int n = s . length ( ) ; cout << getSortedString ( s , n ) ; return 0 ; }",Case.
477,Check if the string contains consecutive letters and each letter occurs exactly once | C ++ program to implement the above approach ; Function to check if the condition holds ; Get the length of the string ; sort the given string ; Iterate for every index and check for the condition ; If are not consecutive ; Driver code ; 1 st example ; 2 nd example,"#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; } int main ( ) { string str = "" dcef "" ; if ( check ( str ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; str = "" xyza "" ; if ( check ( str ) ) cout << "" Yes STRNEWLINE "" ; else cout << "" No STRNEWLINE "" ; return 0 ; }",Check if the string contains consecutive letters and each letter occurs exactly once.
478,Smallest subset with sum greater than all other elements | CPP program to find minimum number of elements such that their sum is greater than sum of remaining elements of the array . ; function to find minimum elements needed . ; calculating HALF of array sum ; sort the array in descending order . ; current sum greater than sum ; Driver function,"#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minElements ( arr , n ) << endl ; return 0 ; }",Smallest subset with sum greater than all other elements.
479,"Minimum increment and decrement by K of each pair elements required to make all array elements equal | C ++ program for the above approach ; Function to check if its possible to make all array elements equal or not ; Stores the sum of the array ; Traverse the array ; If sum is divisible by N ; Otherwise , not possible to make all array elements equal ; Driver Code ; Given array ; Size of the array","#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrayElementEqual ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum % N == 0 ) { cout << "" Yes "" ; } else { cout << "" No "" << endl ; } } int main ( ) { int arr [ ] = { 1 , 5 , 6 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; arrayElementEqual ( arr , N ) ; }",Minimum increment and decrement by K of each pair elements required to make all array elements equal.
480,"Rearrange array to maximize sum of GCD of array elements with their respective indices | C ++ program to implement the above approach ; Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array ; Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements ; Update res ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }",Rearrange array to maximize sum of GCD of array elements with their respective indices.
481,"Polygon with maximum sides that can be inscribed in an N | C ++ program for the above approach ; Function to find the maximum sided polygon that can be inscribed ; Base Case ; Return n / 2 if n is even Otherwise , return - 1 ; Driver Code ; Given N ; Function Call",#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumSides ( int n ) { if ( n < 4 ) return -1 ; return n % 2 == 0 ? n / 2 : -1 ; } int main ( ) { int N = 8 ; cout << MaximumSides ( N ) ; return 0 ; },Polygon with maximum sides that can be inscribed in an N.
482,Mean of array generated by products of all pairs of the given array | C ++ program for the above approach ; Function to find the mean of pair product array of arr [ ] ; Initializing suffix sum array ; Build suffix sum array ; Size of pairProductArray ; Stores sum of pairProductArray ; Store the mean ; Find mean of pairProductArray ; Return the resultant mean ; Driver Code ; Given array arr [ ] ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }",Mean of array generated by products of all pairs of the given array.
483,"Minimize count of unique paths from top left to bottom right of a Matrix by placing K 1 s | C ++ Program to implement the above approach ; Function to return the value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ] ; Function to find the minimum count of paths from top left to bottom right by placing K 1 s in the matrix ; Count of ways without 1 s ; Count of paths from starting point to mid point ; Count of paths from mid point to end point ; Driver Code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int ncr ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; } int main ( ) { int N = 3 ; int M = 3 ; int K = 1 ; cout << countPath ( N , M , K ) ; return 0 ; }",Minimize count of unique paths from top left to bottom right of a Matrix by placing K 1 s.
484,Maximum number of operations required such that no pairs from a Matrix overlap | C ++ Program to implement the above approach ; Function to find maximum count of operations ; Initialize count by 0 ; Iterate over remaining pairs ; Check if first operation is applicable ; Check if 2 nd operation is applicable ; Otherwise ; Return the count of operations ; Driver Code,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_max ( vector < pair < int , int > > v , int n ) { int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] . first < ( v [ i ] . first - v [ i ] . second ) ) count ++ ; else if ( v [ i + 1 ] . first > ( v [ i ] . first + v [ i ] . second ) ) { count ++ ; v [ i ] . first = v [ i ] . first + v [ i ] . second ; } else continue ; } return count ; } int main ( ) { int n = 3 ; vector < pair < int , int > > v ; v . push_back ( { 10 , 20 } ) ; v . push_back ( { 15 , 10 } ) ; v . push_back ( { 20 , 16 } ) ; cout << find_max ( v , n ) ; return 0 ; }",Maximum number of operations required such that no pairs from a Matrix overlap.
485,Count of substrings formed using a given set of characters only | C ++ program for the above approach ; Function to find the number of substrings that can be formed using given characters ; Boolean array for storing the available characters ; Mark indices of all available characters as 1 ; Initialize lastPos as - 1 ; Initialize ans with the total no of possible substrings ; Traverse the string from left to right ; If the current character is not present in B ; Subtract the total possible substrings ; Update the value of lastpos to current index ; Print the final answer ; Driver Code ; Given String ; Given character array ; Function Call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberofsubstrings ( string str , int k , char charArray [ ] ) { int N = str . length ( ) ; bool available [ 26 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; } int lastPos = -1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - ' a ' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } cout << ans << endl ; } int main ( ) { string str = "" abcb "" ; int k = 2 ; char charArray [ k ] = { ' a ' , ' b ' } ; numberofsubstrings ( str , k , charArray ) ; return 0 ; }",Count of substrings formed using a given set of characters only.
486,Minimum cost to reach a point N from 0 with two different operations allowed | CPP implementation of above approach ; Function to return minimum cost to reach destination ; Initialize cost to 0 ; going backwards until we reach initial position ; if 2 * X jump is better than X + 1 ; if X + 1 jump is better ; return cost ; Driver program,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } int main ( ) { int N = 9 , P = 5 , Q = 1 ; cout << minCost ( N , P , Q ) ; return 0 ; }",Minimum cost to reach a point N from 0 with two different operations allowed.
487,"Number of ways to reach at starting node after travelling through exactly K edges in a complete graph | C ++ program for the above approach ; Function to find number of ways to reach from node 1 to 1 again , after moving exactly K edges ; Initialize a dp [ ] array , where dp [ i ] stores number of ways to reach at a i node ; Initialize the dp array with 0 ; Base Case ; Iterate for the number of edges moved ; Sum will store number of ways to reach all the nodes ; Iterate for every possible state for the current step ; Update the value of the dp array after travelling each edge ; Print dp [ 0 ] as the answer ; Driver Code ; Given Input ; Function Call","#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberOfWays ( int n , int k ) { int dp [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { int numWays = 0 ; for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } } cout << dp [ 0 ] << endl ; } int main ( ) { int N = 5 , K = 3 ; numberOfWays ( N , K ) ; return 0 ; }",Number of ways to reach at starting node after travelling through exactly K edges in a complete graph.
488,"Count possible decoding of a given digit sequence with hidden characters | C ++ program for the above approach ; If s [ i ] = = ' * ' there can be 9 possible values of * ; If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 ) ; If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 ) ; If the previous digit is * then all 15 2 - digit characters can be formed ; If s [ i ] != ' * ' ; Adding first in second if s [ i - 1 ] = 1 ; Adding first in second if s [ i - 1 ] = = 2 and s [ i ] <= '6' ; If s [ i - 1 ] = = ' * ' the union of above 2 cases has to be done ; Driver code","#include <bits/stdc++.h> NEW_LINE using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { long first = 1 , second = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { long temp = second ; if ( s [ i ] == ' * ' ) { second = 9 * second ; if ( s [ i - 1 ] == '1' ) second = ( second + 9 * first ) % M ; else if ( s [ i - 1 ] == '2' ) second = ( second + 6 * first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + 15 * first ) % M ; } else { second = s [ i ] != '0' ? second : 0 ; if ( s [ i - 1 ] == '1' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + ( s [ i ] <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; } int main ( ) { string s = "" * "" ; cout << waysOfDecoding ( s ) ; return 0 ; }",Count possible decoding of a given digit sequence with hidden characters.
489,Minimum cost of purchasing at least X chocolates | C ++ program for the above approach ; Function to calculate minimum cost of buying least X chocolates ; Base Case ; Include the i - th box ; Exclude the i - th box ; Return the minimum of the above two cases ; Driver Code ; Given array and value of X ; Store the size of the array ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return INT_MAX ; int inc = findMinCost ( arr , X - arr [ i ] . first , n , i + 1 ) ; if ( inc != INT_MAX ) inc += arr [ i ] . second ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return min ( inc , exc ) ; } int main ( ) { pair < int , int > arr [ ] = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = findMinCost ( arr , X , n ) ; if ( ans != INT_MAX ) cout << ans ; else cout << -1 ; return 0 ; }",Minimum cost of purchasing at least X chocolates.
490,Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers | C ++ program for above approach ; Function to calculate the probability for the given sum to be equal to sum in N throws of dice ; Base cases ; Driver Code ; Print the answer,"#include <bits/stdc++.h> NEW_LINE using namespace std ; long double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } long double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; long double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }",Probability that the sum of all numbers obtained on throwing a dice N times lies between two given integers.
491,Minimum steps to reduce N to 0 by given operations | C ++ program for the above approach ; Function to find the minimum number to steps to reduce N to 0 ; Base case ; Recursive call to count the minimum steps needed ; Return the answer ; Driver Code ; Given number N ; Function call,"#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; } int main ( ) { int N = 6 ; cout << minDays ( N ) ; return 0 ; }",Minimum steps to reduce N to 0 by given operations.
